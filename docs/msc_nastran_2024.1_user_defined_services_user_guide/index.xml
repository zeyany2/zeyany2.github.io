<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DOC REPO – MSC Nastran manuals</title>
    <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/</link>
    <description>Recent content in MSC Nastran manuals on DOC REPO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>User&#39;s Manual P1</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_001/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_001/</guid>
      <description>
        
        
        &lt;p&gt;MSC Nastran 2024.1
User Defined Services User’s GuideMSC Nastran User Defined Services User’s Guide&lt;/p&gt;
&lt;p&gt;Worldwide Web
&lt;a href=&#34;https://www.hexagon.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.hexagon.com&lt;/a&gt;
Support
&lt;a href=&#34;https://simcompanion.hexagon.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://simcompanion.hexagon.com&lt;/a&gt;
Disclaimer
Hexagon reserves the right to make changes in specifications and other information contained in this document without prior notice.
The concepts, methods, and examples presented in this text are for illustrative and educational purposes only, and are not intended
to be exhaustive or to apply to any particular engineering problem or design. Hexagon assumes no liability or responsibility to any
person or company for direct or indirect damages resulting from the use of any information contained herein.
User Documentation: Copyright 2024 Hexagon AB and/or its subsidiaries. All Rights Reserved.
This notice shall be marked on any reproduction of this documentation, in whole or in part. Any reproduction or distribution of this
document, in whole or in part, without the prior written consent of Hexagon is prohibited.
This software may contain certain third-party software that is protected by copyright and licensed from Hexagon suppliers. Additional
terms and conditions and/or notices may apply for certain third party software. Such additional third party software terms and
conditions and/or notices may be set forth in documentation and/or at third-party software information  (or successor website designated
by Hexagon from time to time).
PCGLSS 8.0, Copyright © 1992-2016, Computational Applications and System Integration Inc. All rights reserved. PCGLSS 8.0 is
licensed from Computational Applications and System Integration Inc.
The Hexagon logo, Hexagon, MSC Software logo, MSC, Dytran, Marc, MSC Nastran, Patran, e -Xstream, Digimat, and Simulating
Reality are trademarks or registered trademarks of Hexagon AB and/or its subsidiaries in the United States and/or other countries.
NASTRAN is a registered trademark of NASA. FLEXlm and FlexNet Publisher are trademarks or registered trademarks of Flexera
Software. All other trademarks are the property of their respective owners.
Use, duplicate, or disclosure by the U.S. Government is subjected to restrictions as set forth in FAR 12.212 (Commercial Computer
Software) and DFARS 227.7202 (Commercial Computer Software and Commercial Computer Software Documentation), as
applicable.
U.S. Patent 9,361,413
May 16, 2024
NA:V2024.1:Z:Z:Z:DC-USR-PDFCorporate Office
Hexagon Manufacturing Intelligence, Inc. UK
78 Portsmouth Road Cedar House
Cobham, Surrey KT11 1HY
Telephone: (+44) 02070686555&lt;/p&gt;
&lt;p&gt;Documentation Feedback
At Hexagon Manufacturing Intelligence, we strive to produce the highest quality documentation and
welcome your feedback. If you have comments or suggestions about our documentation, write to us .
Please include the following information with your feedback:
Document name
Release/Version number
Chapter/Section name
Topic title (for Online Help)
Brief description of the content (for example, incomplete/incorrect information, grammatical
errors, information that requires clarification or more details and so on).
Your suggestions for correcting/improving documentation
Note:   The above mentioned e-mail address is only for providing documentation specific
feedback. If you have any technical problems, issues, or queries, please contact Technical
Support .&lt;/p&gt;
&lt;p&gt;C o n t e n t s
User Defined Services User’s Guide&lt;/p&gt;
&lt;p&gt;Main Index
Contents
Preface
List of MSC Nastran Guides . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10
Technical Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11
Training and Internet Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11
1 User Defined Subroutines
Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14
Changes to UDS/UDR for 2024.1  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14
Changes to UDS/UDR for 2023.4  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14
Changes to UDS for 2023.1  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14
Changes to UDS for 2021.2  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15
Supported User Defined Subroutines  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15
SOL 400 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15
SOL 700 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16
Build Environment  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17
Path Descriptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  20
Implementation with Templates  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  20
SOL 400 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  20
SOL 700 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  21
Implementation without Templates  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  22
Building the Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  24
SOL 400 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  24
Environment Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  25
Using the Service  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  25
Error Handling  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  27
Utility Routines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  28
F06 Printing Routine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  28
Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  57
Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  61&lt;/p&gt;
&lt;p&gt;User Defined Services User’s Guide6
Main Index
EXFAIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  149
EXFAIL1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  150
EXFAIL2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  153
EXFLOW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  154
EXFLOW3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  157
EXFUNC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  160
EXINIT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  161
EXOUT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  162
EXPOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  165
EXSHR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  167
EXSPR  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  168
EXTVEL  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  171
EXVISC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  172
EXYLD  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  174
User Service Ease of Use . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  177
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  177
Requirement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  177
Usage of Keyword uds and udssave . . . . . . . . . . . . . . . . . . . .  177
User Routines Ease of Use . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  180
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  180
Requirement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  183
Usage of keywords UDR, UDRPATH  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  184
UDS for Rotordynamics  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  184
2 User Defined Module Service UDMSRV
User Defined Module Service UDMSRV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  188
Utility Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  189
Memory Management Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  189
Database Access  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  190
3 OpenFSI
Running an OpenFSI MSC Nastran Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  196
OpenFSI input deck  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  196
Running MSC Nastran  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  204
Simple Example Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  205
Creating an OpenFSI SCA Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  207
Build Tools and Source Files  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  207
OpenFSI Interface and Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  208
OpenFSI_Ex Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  209
Creating an OpenFSI_Ex SCA Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  210&lt;/p&gt;
&lt;p&gt;7 Contents
Main Index
OpenFSI and OpenFSI_Ex Interface Call  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  211
Appendix 1: OpenFSI Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  211
Interface Definition Language File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  211
Service Definition Language File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  219
Component Definition Language File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  220
OpenFSI Data Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  220
Run Time Errors and Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  222
Appendix 2: OpenFSI_Ex Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  224
Interface Definition Language File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  224
Service Definition Language File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  230
Component Definition Language File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  231
OpenFSI_Ex Data Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  232
References  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  232
4 OpenFSI MSC Nastran &amp;amp; SimXpert Quick Start Tutorial
Launch SimXpert and Import the Structural Model  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  234
Define the Service for the Coupled Solution  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  235
Define the OpenFSI LBCs (Wetted Surfaces) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  236
Define a Nonlinear Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  238
Launch MSC Nastran OpenFSI-MpCCI Simulation (for Fluent &amp;amp; StarCD) . . . . . . . . . . . . . . . . . . . . . . . . . .  243
Examine the Results Using SimXpert  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  244
5 OpenMDO
Run MSC Nastran OpenMDO Optimization  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  252
OpenMDO Input Deck . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  252
Running MSC Nastran . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  252
Creating an OpenMDO SCA service  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  254
Build tools  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  254
Build an Example myOpenMDO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  254
Building a New OpenMDO Service from Scratch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  255
Appendix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  257
Interface Definition Language file  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  257
Reference  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  260
A Quick Start
MSC SDK Delivery Contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  262&lt;/p&gt;
&lt;p&gt;User Defined Services User’s Guide8
Main Index
Services Implementation Examples  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  262
Supported Operating Systems and Compilers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  263
Compiling User Defined Services  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  264
Defining the Path to User Defined Service  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  265
Pointing to a User Defined Services from MSC Nastran . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  266
Running MSC Nastran with a User Defined Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  266
SDK User Services on Other Operating Systems  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  267
Errors Messages and Diagnostics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  268
FAQ. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  271
B Compatibility Matrix
Product Compatibility Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  274&lt;/p&gt;
&lt;p&gt;Main Index
Preface
Preface
List of MSC Nastran Guides     10
Technical Support     11
Training and Internet Resources     11&lt;/p&gt;
&lt;p&gt;MSC Nastran User Defined Services User’s Guide
10
Main Index
List of MSC Nastran Guides
A list of some of the MSC Nastran guides is as follows:
Installation and Release Guides
Installation and Operations Guide
Release Guide
Reference Guides
Quick Reference Guide
DMAP Programmer’s Guide
Reference Guide
Utilities Guide
Getting Started Guide
SOL 400 Getting Started Guide
MSC Nastran Error Messages Guide
Demonstration Guides
Linear Analysis
Implicit Nonlinear (SOL 400)
Explicit Nonlinear (SOL 700)
MSC Nastran Verification Guide
User’s Guides
Automated Component Modal Synthesis (ACMS)
Access Manual
Aeroelastic Analysis
Design Sensitivity and Optimization
DEMATD
Dynamic Analysis
Embedded Fatigue
Embedded Vibration Fatigue
Explicit Nonlinear (SOL 700)
High Performance Computing
Linear Static Analysis
Nonlinear (SOL 400)
Numerical Methods
Rotordynamics&lt;/p&gt;
&lt;p&gt;11 MSC Nastran User Defined Services User’s Guide
Preface
Main Index
You may find any of these documents from Hexagon at:
&lt;a href=&#34;https://simcompanion.hexagon.com/customers/s/article/MSC-Nastran-Support-Home-Page&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://simcompanion.hexagon.com/customers/s/article/MSC-Nastran-Support-Home-Page&lt;/a&gt;
Technical Support
For technical support phone numbers and contact information, please visit:
&lt;a href=&#34;https://simcompanion.hexagon.com/customers/s/article/support-contact-information-kb8019304&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://simcompanion.hexagon.com/customers/s/article/support-contact-information-kb8019304&lt;/a&gt;
Support Center ( &lt;a href=&#34;http://simcompanion.hexagon.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://simcompanion.hexagon.com&lt;/a&gt;)
The SimCompanion link above gives you access to the wealth of resources for Hexagon products. Here you
will find product and support contact information, product documentations, knowledge base articles,
product error list, knowledge base articles and SimAcademy Webinars. It is a searchable database which
allows you to find articles relevant to your inquiry. Valid MSC customer entitlement and login is required to
access the database and documents. It is a single sign-on that gives you access to product documentation for
complete list of products from Hexagon, allows you to manage your support cases, and participate in our
discussion forums.
Training and Internet Resources
The Hexagon corporate site has the information on the latest events, products, and services for the
CAD/CAE/CAM marketplace.
Design and Engineering e-Learning
The above link will point you to schedule and description of seminars. Following courses are recommended
for beginning MSC Nastran users.
NAS120 - Linear Static Analysis using MSC Nastran and Patran
This seminar introduces basic finite element analysis techniques for linear static, normal modes, and
buckling analysis of structures using MSC Nastran and Patran. MSC Nastran data structure, the element
library, modeling practices, model validation, and guidelines for efficient solutions are discussed and
illustrated with examples and workshops. Patran will be an integral part of the examples and workshops and
will be used to generate and verify illustrative MSC Nastran models, manage analysis submission requests,
and visualize results. This seminar provides the foundation required for intermediate and advanced MSC
Nastran applications.Superelements and Modules
Thermal Analysis
User Defined Services&lt;/p&gt;
&lt;p&gt;MSC Nastran User Defined Services User’s Guide
12
Main Index&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 1: User Defined Subroutines
User Defined Services User’s Guide
1 User Defined Subroutines
Overview      14
Supported User Defined Subroutines      15
Build Environment      17
Implementation with Templates      20
Implementation without Templates      22
Building the Service      24
Environment Variables      25
Using the Service      25
Error Handling      27
Utility Routines     28
User Service Ease of Use     177
UDS for Rotordynamics     184&lt;/p&gt;
&lt;p&gt;14User Defined Services User’s Guide
User Defined Subroutines
Main Index
The purpose of this manual is to describe the User Defined Services (UDS) capability in MSC Nastran. This capability
gives you a mechanism to utilize your own user subroutines or applications within an MSC Nastran execution. There are
many benefits to this new feature, such as using your own proprietary element formulations. You can also use this feature
to extend MSC Nastran’s material property formulations or apply specific rules to a contact problem. The tools provided
can be used to integrate your own CFD application within MSC Nastran.  The Quick Start  describes how to compile and run
the user-defined services examples delivered with MSC Nastran.
Overview
The process of enabling User Defined Services consists of the following four steps:
1.Creating the desired implementation for the User Defined Services in the form of dynamic-link libraries.
2.Defining the location of the user-defined service, service catalogue, and service resource directory.
3.Specifying the proper commands in the model to load the service.
4.Identifying the elements that use the user supplied implementation.
In order to create a dynamic-link library suitable for usage with MSC Nastran, a build environment is delivered to assist
users in building the library. Please refer to the SCA Service Guide  document that describes the features and capabilities
of the build system.
Included in the MSC Nastran installation are implementation templates for user subroutines. These templates simplify the
implementation of user subroutines, and can be found in the following directory tree:
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/{Contact, Elements,
Materials, GeneralInfo, OpenFSI, OpenMDO, Udmsrv}
For Nastran Nonlinear Explicit (SOL 700) these templates and examples can be found in the following directory tree:
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/ services/s700uds
Changes to UDS/UDR for 2024.1
Nastran SOL 700: The option for UDS was retired. It was replaced by the UDR option.
Changes to UDS/UDR for 2023.4
A UDR command line option has been added to the Nastran command line.   It will use a script to compile, create
SO/DLL and attach the file to Nastran rather than SCA Services.
The UDS option will be retired in a future version and be replaced by the new UDR command line option.
Changes to UDS for 2023.1
The libtirpc-devel RPM is required on Red Hat 8 and SuSE 15SP3 systems
When using many processors, the following may be needed:&lt;/p&gt;
&lt;p&gt;15 CHAPTER 1
Main Index
export DEBUG_REMOTEBRIDGE=&amp;ldquo;Yd”
Changes to UDS for 2021 .2
The sconsi8 command has been deprecated. Scons builds-in 32 bits by default. In order to build in 64 bits add
lines similar to your SConscript files:
if env_base[&amp;lsquo;MACHINE&amp;rsquo;].startswith(&amp;lsquo;WIN&amp;rsquo;):
env.Propagate(env.Append,
FORTRANFLAGS=[&amp;quot;/integer_size:64&amp;rdquo;,&amp;quot;/real_size:64&amp;quot;,&amp;quot;/double_size:128&amp;quot;])
else:
env.Propagate(env.Append,
FORTRANFLAGS=[&amp;quot;-integer_size 64&amp;quot;,&amp;quot;-real_size 64&amp;quot;,&amp;quot;-double_size 128&amp;quot;])
&amp;quot;scons.cmd&amp;quot; will be required on some window&amp;rsquo;s systems that do not identify the .cmd extention
Previous SCons used Python 2.7. This version of SCons uses Python 3.6.
Supported User Defined Subroutines
SOL 400
Contact
•MOTION  – rigid surface motion
•SEPFOR  – separation force
•SEPSTR  – separation stress
•UFRIC  – friction coefficients
•UBSQUEAL  – friction coefficient and effective stiffness in brake squeal analysis
For Complex Eigen Value Analysis (SOL 107/110)
•CBUSH2DA
For Frequency Response Analysis (SOL 108/111/128)
•CBUSH2D
•CBUSH2DA
For Transient Analysis (SOL400)
•CBUSH2DA
Elements
•NLRSFD - (SOL400) nonlinear transient load proportional to a squeeze film damper (also supported in SOL
129)
•NLRSFDA - nonlinear transient (SOL400) and nonlinear frequency response (SOL128) analysis.&lt;/p&gt;
&lt;p&gt;16User Defined Services User’s Guide
User Defined Subroutines
Main Index
Materials
•CRPLAW  – specify increment of creep strain
•HYPELA2  – implement arbitrary material models in conjunction with the hypoelastic model
•ORIENT  – specification of preferred orientation
•UELASTOMER  – generalized strain energy function
•UFAIL  – user-defined failure criterion
•UPROGFAIL  – definition of material stiffness reduction factors for progressive failure analysis
•UMAT  – implement arbitrary material models with user defined state variables and internal variable data
•UCOHES  – implement cohesive model used by interface elements
GeneralInfo
•NOTIFY  – notify and pass runtime info and user-supplied dat a
SOL 700
Material s
•EXEOS  - Equation of state model
•EXSHR  - Shear model
•EXYLD - Yield model
•EXFAIL  - Failure model
•EXFAIL1  - Alternative failure model
•EXFAIL2  - Second alternative failure model
•EXCOMP  - Failure properties for an orthotropic material for shell element
Properties
•EXELAS  - Elastic Spring
•EXSPR  - Linear-Elastic Spring
•EXVISC  - Linear-Damper
Flow
•EXFLOW  - Flow definition of an Euler boundary
•EXFLOW3  - Alternative flow definition of an Euler Boundary
•EXPOR  - Flow definition of a coupling surface
InitOut
•EXINIT - Initial condition of Lagrangian grid points or Euler elements
•EXOUT  - Output request for Lagrangian grid points or Euler elements&lt;/p&gt;
&lt;p&gt;17 CHAPTER 1
Main Index
Loads
•EXVEL - Enforced velocity of Lagrangian grid points
•EXFUNC  - Table definition
Connections
•EXBRK  - BJOIN connection failure model
Build Environment
In order to build User Defined Services, the build environment has to be properly configured. Chapter 3 of the SCA
Service Guide  details the process of setting up the build environment. Once the build environment is setup properly, you
can easily build service libraries.
For this release, the build environment requires proper compiler versions to be installed on the target platform. The target
compilers are listed in Table 1-1 in Appendix A.
If you have issues with the compilers on windows:
In the &amp;ldquo;Windows Settings&amp;rdquo; window, click App and Features .
In the search box, type in &amp;ldquo;visual studio&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;18User Defined Services User’s Guide
User Defined Subroutines
Main Index
In the list presented, select Visual Studio Professional 2017  to see its version number. If you have more than one, make
sure to pick the one and click Modify .
The Modify  button also shows the list of components.
Select Individual Components , and make sure that following two entries (with EXACT version number) are checked:
1.under Compilers, build tools, and runtimes  category:
VC++ 2017 version 15.5 v14.12 toolset
2.under SDKs, libraries, and frameworks  category:
Windows 10 SDK (10.0.16299.0) for Desktop C++ [x86 and x64]&lt;/p&gt;
&lt;p&gt;19 CHAPTER 1
Main Index
If any one of them is not checked, it is recommended to install them by adding a check-mark and clicking Modify  button
(lower-right corner). It&amp;rsquo;s better to reboot the machine before trying the build again.
UDR compiler changes:
If a user would like to change compiler options or locations they may modify:
MSC_BASE/MSC_VERSD/MSC_ARCH/bld_usr_so.sh or bld_usr_dll.bat
and
MSC_BASE/MSC_VERSD/MSC_ARCH/nastran,lcl&lt;/p&gt;
&lt;p&gt;20User Defined Services User’s Guide
User Defined Subroutines
Main Index
Path Descriptions
msc_base:  path of the MSC base directory.
SCA_OBJECT : path of directory tree containing all temporary files generated by the build. Included are source files, object
files, and libraries.
APPS_LOCAL : path of directory tree containing copies of the files generated during a build that will override or add to
the files in the SCA application system tree.
The SCA_OBJECT and APPS_LOCAL paths are chosen by the user and can optionally be set by creating or modifying a
SCons configuration file in the home directory: SConopts.user. If this file exists with values for SCA_OBJECT and
APPS_LOCAL defined, they do not have to be specified in the build command.  For the APPS2_SYSTEM variable,
&amp;lt;msc_base&amp;gt; has to be replaced with the correct MSC base path prior to building.
Sample SConopts.user file with undefined paths:
BUILDTYPE    = &amp;lsquo;opt&amp;rsquo;
APPS_DIR     = &amp;lsquo;SCAKernel&amp;rsquo;
TOOLS_DIR    = &amp;lsquo;Tools&amp;rsquo;
PRODUCT_LINE = &amp;rsquo;nastran&amp;rsquo;
if (SCASCons.MACHINE).startswith(&amp;lsquo;WIN&amp;rsquo;):
SCA_OBJECT = &amp;lsquo;&amp;lt;SCA_OBJECT_PATH&amp;gt;&amp;rsquo;
APPS_LOCAL = &amp;lsquo;&amp;lt;APPS_LOCAL_PATH&amp;gt;&amp;rsquo;
else:
SCA_OBJECT = &amp;lsquo;&amp;lt;SCA_OBJECT_PATH&amp;gt;&amp;rsquo;
APPS_LOCAL = &amp;lsquo;&amp;lt;APPS_LOCAL_PATH&amp;gt;&amp;rsquo;
Implementation with Templates
The user subroutines can be implemented in either C++ or FORTRAN. Calls to the FORTRAN subroutines originate from
their respective C++ implementation, so modifying the C++ function body is not recommended if that particular
subroutine will be implemented in FORTRAN.
SOL 400
Source files in C++ contain both i4 and i8 64 bit versions and may also contain various user subroutines, whereas
FORTRAN source files have only a single version. Source files containing various user subroutines are either of type contact
or material.
Contact.cpp  (motion, sepfor, sepstr, ubsqueal, ufric)
Materials.cpp  (crplaw, hypela2, orient, ucohes, uelastomer, ufail, umat, uprogfail)
T o begin the implementation process, copy the &lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt; /nast/services/  directory to a directory
with write access; then modify the desired user subroutine in either C++ or FORTRAN.
C++ implementations
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Contact/src/Contact.cpp&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P10</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_010/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_010/</guid>
      <description>
        
        
        &lt;p&gt;181 CHAPTER 1
EXYLD Subroutine
Main Index
1.3Modify your source. In the past you might have had one routine such as ext_motion.F. Now that file will
need to include all entry points. The unmodified subroutine names may be obtained from
MSC_BASE/MSC_VERSD/nast/UDR/GROUP/*.F
where GROUP is one of: contact, elements, general, or materials
1.4The name of the file is used to determine the group. E.g. files with “motion” will replace the default
“contact” SO/DLL.
*UDR, UDRPATH are described in the Installation and Operations Guide.
2.Details of new SO/DLL files.
There are four SO/DLL files that contain the external files.
SO/DLL Entry Name
Contact ext_motion
ext_sepfor
ext_sepforbbc
ext_ubsqueal
ext_ufric
ext_ugrowrigid
Elements ext_cbush2d
ext_cbush2da
ext_cbush2dadv
ext_nlrsfd
ext_nlrsfda
ext_uselem
General ext_notify
Materials ext_crplaw
ext_hypela2
ext_hpyela2a
ext_orient
ext_uchohes
ext_ucohesive
ext_uelastomer&lt;/p&gt;
&lt;p&gt;182 User Defined Services User’s Guide
User Defined Subroutines
Main Index
3.Details of SO/DLL build
Files are compiled with a script rather than with SDK/SCons. The scripts and compile options are in
$MSC_BASE/$MSC_VERSD/nast/comp* , $MSC_BASE/$MSC_VERSD/$MSC_ARCH/bld_usr* . These scripts
contain pointers to the compilers.  E.g.:
On linux:
msc20241/nast/compf.sh contains:
INTEL_ROOT=/opt/intel/oneapi/compiler/2023.1.0/
FFLAGS=&amp;quot;-mp1 -WB -i8 -integer-size 64 -real-size 64 &amp;quot;
msc20241/linux64i8/bld_usr_so.sh contains:
FORT=/opt/intel/oneapi/compiler/2023.1.0/linux/bin/intel64/ifort
FFLAGS=&amp;quot;-c -assume byterecl -safe-cray-ptr -mp1 -WB -fp-model
source -qopenmp -qopenmp-threadprivate=compat -fPIC -O1 -i8
-integer-size 64 -real-size 64 &amp;quot;
CC=/opt/intel/oneapi/compiler/2023.1.0/linux/bin/intel64/icpc
CFLAGS=&amp;quot;-c -std=c++0x -fPIC -O2 -Wp64 -U__STRICT_ANSI__ -fPIC
-I/usr/include/tirpc -DLX86 &lt;br&gt;
On Windows:
msc20241/nast/compf.bat contains:
set INTEL_ROOT=C:\Program Files (x86)\Intel\oneAPI\compiler\2023.1.0&lt;br&gt;
set FORT=%INTEL_ROOT%\windows\bin\intel64\ifort.exe
set FFLAGS=/nologo /nbs /WB -D_WINDOWS /names:uppercase /Qdyncom XNSTRN
/Qzero /Qsave /O2 /warn:usage /integer-size:64 /real-size:64
/double-size:128 /fpp
&amp;ldquo;/IC:\Program Files (x86)\Intel\oneAPI&lt;br&gt;
compiler\2022.1.0\windows\compiler\include\intel64&amp;rdquo;
set DEVSTUDIO_ROOT=
&amp;ldquo;C:\Program Files\Microsoft Visual Studio\2022\Professional&amp;rdquo;
set DEV_DIR=&amp;quot;%DEVSTUDIO_ROOT%\VC\Tools\MSVC\14.36.32532&amp;quot;
set DEV_LIB=%DEV_DIR%\lib\x64ext_ufail
ext_umat
ext_uprogfailSO/DLL Entry Name&lt;/p&gt;
&lt;p&gt;183 CHAPTER 1
EXYLD Subroutine
Main Index
set INT_PATH=%INTEL_ROOT%\windows\bin\intel64
set DEV_PATH=%DEV_DIR%\bin\Hostx64\x64
set KIT_PATH=%WINDOWSKITS%\10\lib\10.0.22621.0\ucrt\x64
set INT_LIB=%INTEL_ROOT%\windows\compiler\lib\intel64
set KT2_PATH=%WINDOWSKITS%\10\lib\10.0.22621.0\um\x64
msc20234/win64i8/bld_usr_dll.bat currently uses PATHs already defined by comp*.bat
or msc20241/win64i8/nastran.lcl:
if &amp;ldquo;%%INTEL_ROOT%%&amp;rdquo; == &amp;quot;&amp;quot;
set INTEL_ROOT=C:\Program Files (x86)&lt;br&gt;
Intel\oneAPI\compiler\2023.1.0\windows
if &amp;ldquo;%%DEVSTUDIO_ROOT%%&amp;rdquo; == &amp;quot;&amp;quot;
set DEVSTUDIO_ROOT=C:\Program Files&lt;br&gt;
Microsoft Visual Studio\2022\Professional
Requirement
Currently supported compilers and environment needs to be installed.  Other compilers and compiler options may work,
but have not been tested.
While FORTRAN processes the CASE and trailing underscores properly, C++ code varies. It is recommended that a header
such as the following be added to CPP files:
#ifdef WIN8664
#define EXT_MOTION    EXT_MOTION
#define EXT_SEPFOR    EXT_SEPFOR
#define EXT_SEPFORBBC EXT_SEPFORBBC
#define EXT_SEPSTR    EXT_SEPSTR
#define EXT_UBSQUEAL  EXT_UBSQUEAL
#define EXT_UFRIC     EXT_UFRIC
#define EXT_UFRICBBC  EXT_UFRICBBC
#define EXT_GROWRIGID EXT_GROWRIGID
#else
#define EXT_MOTION    ext_motion_
#define EXT_SEPFOR    ext_sepfor_
#define EXT_SEPFORBBC ext_sepforbbc_
#define EXT_SEPSTR    ext_sepstr_
#define EXT_UBSQUEAL  ext_ubsqueal_&lt;/p&gt;
&lt;p&gt;184 User Defined Services User’s Guide
User Defined Subroutines
Main Index
#define EXT_UFRIC     ext_ufric_
#define EXT_UFRICBBC  ext_ufricbbc_
#define EXT_GROWRIGID ext_ugrowrigid_
#endif
Then use the UPPERCASE names as a reference.
Usage of keywords UDR, UDRPATH
In the following example job1 uses exn_orient.F  to create and use /scratch/KEEP/libusr_materials_lib.so
Then, in the subsequent run, job2 uses the .SO created in the first run.
nast20241 job1 scr=yes bat=no udr=exn_orient.F udrpath=/scratch/KEEP
nast20241 job2 scr=yes bat=no                  udrpath=/scratch/KEEP&lt;br&gt;
UDS for Rotordynamics
For Rotordynamics analysis, the UDS option in NLRSFD and CBUSH2D elements are very helpful to model realistic
bearing/damper behavior.
The CBUSH2D element with CBUSH2D service call is available in frequency response analysis (SOL 108/ SOL 111/ SOL
128). An example for ext_cbush2d.F  is available with the Nastran build ( C:\Program
Files\MSC.Software\MSC_Nastran\ 20241\msc20241\nast\services\Implementations\
Elements\src\cbush2d ) and the corresponding example can be found at ..\tpl\uds\nuds_cbush2d.dat
The CBUSH2D element with CBUSH2DA advanced service call is available in complex eigenvalue analysis (SOL 107/
SOL 110), frequency response analysis (SOL 108/ SOL 111/ SOL 128) and transient analysis (SOL 400 only). An example
for ext_cbush2da.F  is available with the NASTRAN build ( C:\Program
Files\MSC.Software\MSC_Nastran\ 20241\msc20241\nast\services\Implementations\
Elements\src\cbush2da ) and corresponding example can be found at ..\tpl\uds\nuds_s107_cb2da.dat
The NLRSFD element with NLRSFD service call is available in nonlinear frequency response (SOL128) and nonlinear
transient analysis (SOL 400). An example for ext_nlrsfd.F  is available with the Nastran build ( C:\Program
Files\MSC.Software\MSC_Nastran\ 20241\msc20241\nast\services\
Implementations\Elements\src\Nlrsfd ) and the corresponding example can be found at
..\tpl\uds\e1_128.dat
The NLRSFD element with NLRSFDA advanced service call is available in nonlinear frequency response (SOL128) and
nonlinear transient analysis (SOL 400). An example for ext_nlrsfda.F  is available with the Nastran build
(C:\Program Files\MSC.Software\MSC_Nastran\ 20241\msc20241\
nast\services\Implementations\Elements\src\Nlrsfda ) and the corresponding example can be found at
..\tpl\uds\e1_128_nlrsfda.dat
The analysis is run using:&lt;/p&gt;
&lt;p&gt;185 CHAPTER 1
EXYLD Subroutine
Main Index
•nastran nuds_cbush2d.dat uds= ext_cbush2d.F udssave=temp1
•nastran nuds_cbush2da.dat uds=ext_cbush2da.F udssave=temp1
•nastran e1_128.dat uds=ext_nlrsfd.F udssave=temp1
•nastran e1_128_nlrsfda.dat uds=ext_nlrsfda.F udssave=temp1&lt;/p&gt;
&lt;p&gt;186 User Defined Services User’s Guide
User Defined Subroutines
Main Index&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 2: User Defined Module Service UDMSRV
User Defined Services User’s Guide
2User Defined Module
Service UDMSRV
User Defined Module Service UDMSRV      188
Utility Services      189
Memory Management Interface      189
Database Access     190&lt;/p&gt;
&lt;p&gt;188 User Defined Services User’s Guide
User Defined Module Service UDMSRV
Main Index
User Defined Module Service UDMSRV
A new module called UDMSRV  has been added to the set of DMAP  modules accessible from the standard user interface
(input file). By default, the new module is simply a place holder for potential user developed DMAP  module functionality.
There is a predefined list of input and output data blocks, but these may be matrix or table data blocks defined in any order,
according to the user&amp;rsquo;s requirements, up to a maximum of 25 inputs and 25 outputs; any or all inputs and outputs may be
purged. As with any other DMAP  module, the parameter list has predefined data types; the first parameters is reserved to
define the service name of the user defined module. The UDMSRV  module may also read and write to one or more scratch
data blocks, again as required according to the functionality of the module. The UDMSRV  module is callable as any other
DMAP  module and may be used as such in DMAP  sequences and alters.
UDMSRV  module provides a mechanism for Nastran users to develop their own user defined modules and integrate them
into Nastran&amp;rsquo;s solution sequence through DMAP  solution sequences. The module services are callable from DMAP&lt;br&gt;
programming language.
T o activate user defined services ( UDMSRV ) you will need to follow these steps:
1.Add a CONNECT  entry to FMS section, e.g: CONNECT SERVICE  statement .
2.Add an alter to insert UDMSRV  model in the DMAP  solution sequence .
3.Implement the user defined module service in C++ for each of the Service Module referenced in the DMAP
UDMSRV .
Since the UDMSRV  is a DMAP  module, DMAP code rules such as Last Time Use, Output T wice, will be applied to the
data blocks referenced in the UDMSRV  module. The database clean up will be made after UDMSRV  completed execution
as in a regular Nastran Module.
The DMAP  signature for UDMSRV  models is as follows:
25 input data blocks
25 output data blocks
25 scratch data blocks
1 string parameter (8 character long); this is alias name of the service defined in CONNECT SERVICE  statement
10 integer parameters, default value is 0
10 real double parameters default value is 0.d0
10 string parameters, non default value
Example Format and Syntax of the UDMSRV DMAP Statement:
UDMSRV input1,..,input25/
output1,&amp;hellip;,outout25/
mysrv1,
Iparm1,,,Iparam10,
RDparam1,&amp;hellip;RDparam10,
Cparam1,&amp;hellip;Cparam10 $&lt;/p&gt;
&lt;p&gt;189 Chapter 2: User Defined Module Service UDMSRV
Utility Services
Main Index
Example for the Job Data Input to Run UDMSRV:
$ Prepare the connection for 2 User Define Modules, mysrv1 and mysrv2
$
CONNECT SERVICE mysrv1 &amp;lsquo;Test.MySrv1&amp;rsquo;
CONNECT SERVICE mysrv2 &amp;lsquo;Test.MySrv2&amp;rsquo;
$
SOL MYDMAP
COMPILE MYDMAP list
SUBDMAP MYDMAP $
TYPE DB,ZUZR11  $
$
TYPE PARM,NDDL,I,N,ZUZR1
ZUZR1=100 $
$
$ Call mysrv1 to pack a matrix ZUZR1
$ Note that ZUZR11 is the first output datablock on the DMAP
$
UDMSRV ,/ ZUZR11 / &amp;lsquo;mysrv1&amp;rsquo;/s,N,zuzr1 $
$
$ Call mysrv2 to unpack a matrix ZUZR1
$ Note that ZUZR11 is the first input datablock on the DMAP
$
UDMSRV ZUZR11 / / &amp;lsquo;mysrv2&amp;rsquo; $
$
end $
diag 8
cend
begin bulk
end data
Utility Services
A set of utility interfaces are available to provide access to MSC Nastran’s working memory area (scratch memory) and to
allow users to read and write to and from MSC Nastran database (IO subsystem). In Nastran 2021.2,  these interfaces are
only directly available in C++ service implementations. This means that there are no Fortran callable interfaces available.
Fortran callable interfaces will be supported in future releases.
Memory Management Interface
This interface allows users to create a memory pool within the existing memory area allocated by MSC Nastran application.
It is worth noting that the pools are generated within the scratch memory area, which implies that the content on the
memory area is purged after exiting from the module. The interface for memory management routines are illustrated below:
class IMemoryManager : public IMemoryPoolFactory
{
public:
//
// allocate - allocates a block of memory&lt;/p&gt;
&lt;p&gt;190 User Defined Services User’s Guide
Database Access
Main Index
//
virtual void *allocate( SCA::SCASizeType size ) = 0;
//
// free - releases the memory back to the pool
//
virtual void free( void *ptr ) = 0;
//
// reallocate - resizes a block of memory
//
virtual void &lt;em&gt;reallocate( void&lt;/em&gt; ptr,
SCA::SCASizeType size ) = 0;
//
// allocateAndInit - allocates a block of memory and initializes it to the input bit pattern
//
virtual void *allocateAndInit( SCA::SCASizeType size,
SCA::SCAUInt8 bitPattern = 0 ) = 0;
//
// clear - releases all memory allocated by the pool
//
//virtual void clear() = 0;
//
// largestAvailableBlockSize - returns the size of the largest chunk of available memory in bytes
//
virtual SCA::SCASizeType largestAvailableBlockSize( SCA::SCABool quick = false ) = 0;
//
// tagMemoryPool - assigns an alias (a string name) to the memory pool
//                  returns 0 on success
//                          1 if the name already exists
//                          2 if the pool already has another tag
//                          3 if the name is &amp;quot;&amp;quot; (blank)
//
virtual int tagMemoryPool(  const SCA::SCAString&amp;amp; tag, SCA::MemoryPool&amp;amp; pool ) = 0;
//
// findMemoryPool - finds the an alias (a string name) to the memory pool
//                  returns 0 on success
//                          1 if the name does not exist exists
//
virtual int findMemoryPool(  const SCA::SCAString&amp;amp; tag, SCA::MemoryPool&amp;amp; pool ) = 0;
};
Database Access
The interface to MSC Nastran IO subsystem is done through a service called GinoEmb. The prototype for this service
resides in SCAIGinoEmbService.h that is part of MSC Nastran delivery. Below are the available methods:
SCAResult setFileHandle(in SCAInt32 handle);
SCAResult getFileHandle(out SCAInt32 handle);
SCAResult open(in SCAInt32 mode,  out SCAInt32 code);
SCAResult close(in SCAInt32 code);
SCAResult readTrailer(out SCAInt32Sequence trailer);
SCAResult writeTrailer(in SCAInt32Sequence trailer);
SCAResult read(in SCAString schema, out SCAAnySequence blob, out SCABool
endOfRecord, out SCABool endOfFile);
SCAResult write(in SCAAnySequence blob, in SCAInt32 eorCode);
SCAResult skipRecord(in SCAInt32 numberOfRecords);
SCAResult useMachinePrecision(in SCABool flag);
SCAResult useNastStringSize(in SCABool flag);
SCAResult dbcreate( in SCAString cstr, out SCAInt32 handle, out SCAInt32
stat);
SCAResult getName( out SCAString fname);
SCAResult locate( in IDType recordID, out SCAInt32Sequence flag );&lt;/p&gt;
&lt;p&gt;191 Chapter 2: User Defined Module Service UDMSRV
Database Access
Main Index
The schema for read a write operation is a sequence of type code that matches the content of the data sequence that is to
be read/written to the database file. Currently, MSC Nastran database supports the following type codes:
TCID_Int32:                   // 32 bit integer
TCID_Int64:                   // 64 bit integer
TCID_Real32:                  // 32 bit real
TCID_Real64:                  // 64 bit real
TCID_String:                  // string
TCID_Bool:                    // Boolean
Code Examples
Please refer to examples that are supplied under &amp;lt;MSC_VERD&amp;gt;/nast/services  directory.&lt;/p&gt;
&lt;p&gt;192 User Defined Services User’s Guide
Database Access
Main Index&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 3: OpenFSI
User Defined Services User’s Guide
3 OpenFSI
Running an OpenFSI MSC Nastran Simulation     196
Creating an OpenFSI SCA Service     207
OpenFSI_Ex Interface     209
Appendix 1: OpenFSI Interface     211
Appendix 2: OpenFSI_Ex Interface     224
References     232&lt;/p&gt;
&lt;p&gt;194 User Defined Services User’s Guide
Main Index
The OpenFSI functionality provides a mechanism to exchange fluid structure interaction data between the MSC
NastranTMsolver and an external code. The nonlinear solution sequence in MSC Nastran (SOL400) reads nodal force
vectors from the external code, and sends back nodal displacement and velocity vectors. Data communication is done using
the OpenFSI interface on nodes that belong to so-called wetted surfaces, which are the surfaces where the fluid is in contact
with the solid structures. This data transfer is done once or several times per time step in a transient simulation. The surface
elements and corresponding nodes that belong to wetted surfaces are defined in the MSC Nastran input deck [ Reference 1 ],
and are sent to the external code in the initialization stage, before the transient loop. At the conclusion of the transient loop,
a message indicating that the simulation is set to terminate is sent to the external code. An overview of the simulation
scenario is shown in Figure 3-1.
Figure 3-1  Basic Flow Chart of an OpenFSI Simulation
Wetted surfaces for MSC Nastran and the external CFD code may use dissimilar mesh discretizations (see Figure 3-2); in
which case, the data must be mapped by the external code since MSC Nastran only communicates the data on the wetted
nodes corresponding to the wetted surfaces defined in the MSC Nastran input deck.&lt;/p&gt;
&lt;p&gt;195 Chapter 3: OpenFSI
Main Index
Figure 3-2  Example of CFD and MSC Nastran wetted surface meshes.
A schematics of the data flow using the OpenFSI interface is shown in Figure 3-3. The OpenFSI interface is implemented
using a Simulation Component Architecture (SCA) [References 2, 3], which allows for communication from MSC Nastran
to a different process, possibly running on a different computer.
Figure 3-3  Schematics of OpenFSI interface.&lt;/p&gt;
&lt;p&gt;196 User Defined Services User’s Guide
Running an OpenFSI MSC Nastran Simulation
Main Index
MSC Nastran reads force vectors from the external (CFD) code, and sends displacement and velocity (not shown in
Figure 3-3) vectors back.
T o run an OpenFSI simulation the following software components are required:
MSC Nastran 2012 (or later).
An OpenFSI SCA component.
External code with OpenFSI interface implementation.
OpenFSI SCA components can be of two types:
1.Prebuilt components used with certain commercial CFD solvers.
2.User defined SCA components built with the OpenFSI software development kit (SDK).
This document explains how to run an OpenFSI simulation using an existing OpenFSI SCA component, and how to build
a user-defined OpenFSI SCA component.
Running an OpenFSI MSC Nastran Simulation
OpenFSI input deck
T o define an OpenFSI simulations, there are essentially two fundamental entities that must be added to the MSC Nastran
input deck: (i) the OpenFSI SCA service component, which is a single entry in the file management section, and (ii) the
wetted surface data where the loads are applied, which consist of one entry in the case control section, and several entries
in the bulk data section. The constituents related to the definition of an OpenFSI input deck are given in Table 3-1.
As indicated in Table 3-1, for a user to run a simulation using the OpenFSI interface, a SCA service must be defined in the
File Management  section in the MSC Nastran input file. The SCA service is associated with one ore more wetted surfaces
defined in the Bulk Data  section in the input file. The connection between the SCA service and a wetted surface is done by Table 3-1  MSC Nastran Input File Entries Related to
OpenFSI Simulations
File Management CONNECT SERVICE
Executive Control Must be SOL NONLIN
Case Control DLOAD
OpenFSI Bulk Data FSICTRL
WETLOAD
WETSURF
WETELMG
WETELME
GeneraL Bulk Data DLOAD
TLOAD1
TABLED1&lt;/p&gt;
&lt;p&gt;197 Chapter 3: OpenFSI
Running an OpenFSI MSC Nastran Simulation
Main Index
defining a load on the wetted surface, which is tagged with the SCA service name. The load on the wetted surface is specified
as a dynamic load in the Case Control  section in the MSC Nastran file, but it must be done using a TLOAD1  bulk data entry.
To this end, the DLOAD  entry in the Case Control  section references a TLOAD1  entry in the Bulk Data  section, which in
turn references the load on the wetted surface, defined by the new WETLOAD  entry. The structure of a MSC Nastran input
deck for a single wetted surface and load is shown in Table 3-2, and for multiple wetted surfaces and loads in Table 3-3.
Note that the service name (here SCAFSI) is converted to all upper-case characters if lower-case characters are used, and
that the external service ’ExternalCodeVendor.OpenFSI’  must be given with (right) single quotes, and only one space
character may be used as separator between the key words in the file management section.
The dependency between the entries used for OpenFSI using a single load (with input file structure as Table 3-3) is illustrated
in the diagram below:Table 3-2  MSC Nastran Input File Structure for Single Wetted Load WL1
and a Single Wetted Surface WS1
File Management CONNECT SERVICE SCAFSI’ExternalCodeVendor.OpenFSI’
Executive Control SOL NONLIN
CEND
Case Control SUBCCASE 1
Analysis = NLTRAN
DLOAD - SID
.
.
.
Bulk Data BEGIN BULK
.
.
.
TLOAD1 SID WL1 T1
TABLED1 T1 LINEAR LINEAR
0.0 1.0 1.0e10 1.0ENDT
FSICTRL SCAFSI EXPLICIT 1
WETLOAD WL1 WS1 SCAFSI
WETSURF WS1 surfname
WE1 WE2 WE3 etc.
WETELMG WE1 TYPE
G1 G2 G3 G4G5G6
G7 G8
WETELME WE2 E1 SIDE
.
.
.&lt;/p&gt;
&lt;p&gt;198 User Defined Services User’s Guide
Running an OpenFSI MSC Nastran Simulation
Main Index
Note:   Unless indicated differently, the entries are defined in the bulk data section in the MSC Nastran input file.WETSURF
WETELME WETELMGCase Control File Management
OpenFSI
SCA serviceTLOAD1 WETLOAD FSICTRL DLOAD&lt;/p&gt;
&lt;p&gt;199 Chapter 3: OpenFSI
Running an OpenFSI MSC Nastran Simulation
Main Index
Table 3-3  MSC Nastran Input File Structure for Multiple Wetted Loads WL1, WL2,&amp;hellip; and Multiple Wetted Surfaces WS1,
WS2, &amp;hellip;.
File Management CONNECT SERVICE SCAFSI’ExternalCodeVendor.OpenFSI’
Executive Control SOL NONLIN
CEND
Case Control SUBCCASE 1
Analysis = NLTRAN
DLOAD - SID
.
.
.
Bulk Data BEGIN BULK
.
.
.
TLOAD1 TL1 WL1 1 T1
TLOAD1 TL2 WL2 T1
.
.
.
TABLED1 T1 &amp;hellip;
FSICTRL SCAFSI EXPLICIT 1
WETLOAD WL1 WS1 SCAFSI
WETLOAD WL2 WS2 SCAFSI
.
.
.
WETSURF WS1 surface1
WE1 WE2 WE3 etc.
WETSURF WS2 surface2
WE101 WE2 WE103 etc.
.
.
.
WETELMG WE1 TYPE
G1 G2 G3 G4G5G6
G7 G8
WETELME WE2 E1 SIDE
.
.
.
WETELMG WE101 TYPE
G991 G992 G993 G994G995G996
G997 G998
.
.
.&lt;/p&gt;
&lt;p&gt;200 User Defined Services User’s Guide
Running an OpenFSI MSC Nastran Simulation
Main Index
For OpenFSI, the DLOAD  scale factors should be unity, S=S1=S2= &amp;hellip;  =1:0 .
If a linear combination of TLOAD1  entries are specified in the DLOAD  bulk data entry (as in Table 3-3), we have the
dependency between the entries used for OpenFSI as follows:
The definitions of the OpenFSI bulk data entries are given in Table 3-4,Table 3-5, Table 3-6, Table 3-7, Table 3-8. The FSICTRL&lt;br&gt;
and WETLOAD  entries reference SERV ID , an OpenFSI SCA service. If more than one FSICTRL  and WETLOAD  entries are
used, they may reference different OpenFSI SCA services, which is useful if different external codes are used for different
sets of wetted surfaces. T wo different approaches may be used to define the wetted surface elements: (i) Using the WETELMG&lt;br&gt;
entry, the grid points making up a wetted element are specified explicitly; or (ii) using the WETELME  entry, a wetted element
is defined by referencing a face (or a side) of a parent structural element.
Table 3-4  Definition of a FSICTRL Entry
Format:  FSICTRL
Examples:1 2 3 4 5 6 7 8 9 10
FSICTRL SERV_ID TYPE FREQ ANALYSIS
FSICTRL SCAFSI EXPLICIT 1DLOAD
WETSURF
WETELME WETELMGCase Control File Management
OpenFSI
SCA serviceTLOAD1 WETLOAD FSICTRL DLOAD&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P11</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_011/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_011/</guid>
      <description>
        
        
        &lt;p&gt;201 Chapter 3: OpenFSI
Running an OpenFSI MSC Nastran Simulation
Main Index
Table 3-5  Definition of a WETLOAD Entry
Format:  WETLOAD
Example:
Table 3-6  Definition of a WETSURF Entry
Format: WETSURFField Contents Type Default
SERV_ID OpenFSI SCA service name associated with the wetted surface loads. The
OpenFSI SCA service is defined using the CONNECT SERVICE  File
Management Section statementCharacter None
TYPE Type of solution strategy coupling between the external code and MSC
Nastran. TYPE  can be either EXPLICIT  or IMPLICIT.Character EXPLICIT
FREQ External force and displacement update frequency per time step, for the
exchange with the external code using the IMPLICIT  solution strategy
TYPE .Integer &amp;gt; 0 1
ANALYSIS OpenFSI service type, it is either DV or U. The DV indicates the service
implements OpenFSI interface, the U means the service implements
OpenFSI_Ex interface. Character DV
1 2 3 4 5 6 7 8 9 10
WETLOAD WLID WSIDSERV_ID
WETLOAD 11001 SCAFSI
Field Contents Type Default
WLID Load set ID, referenced by the EXCITEID  field in the TLOAD1  entry. INTEGER &amp;gt; 0 None
WSID Wetted surface identification number. The wetted surface must be defined in
the WETSURF  Bulk Data entry. INTEGER &amp;gt; 0 None
SERV_ID OpenFSI SCA service name associated with the wetted surface loads. The
OpenFSI SCA service is defined using the CONNECT SERVICE file
management section entry.. CHARACTER None
1 2 3 4 5 6 7 8 9 10
WETSURF WSID WTAG
WEID1 WEID2 WEID3 WEID4 WEID5 WEID6 WEID7 WEID8
WEID9 WEID10 -etc.-&lt;/p&gt;
&lt;p&gt;202 User Defined Services User’s Guide
Running an OpenFSI MSC Nastran Simulation
Main Index
Alternate Format:
Example:
Table 3-7  Definition of a WETELMG Entry
Format: WETELMG
Example:WETSURF WSID WTAG
WEID1 “THRU” WEID2 “BY” INC
WETSURF 10001 wall1
5THRU 21 BY 4
27 30 33
35 THRU 44
67 68 70 72 77 82 86 79
89 THRU 110 BY 3
Field Contents Type Default
WSID Wetted surface identification number. INTEGER &amp;gt; 0 None
WTAG Wetted surface tag name exported to an external code using the
OpenFSI SCA interface. CHARACTER None
WEID1,
WEID2, &amp;hellip;Wetted element identification numbers defined using the WETELMG  or
WETELME  Bulk Data entries. INTEGER &amp;gt; 0 None
THRU, BY Keywords to specify a range of wetted elements. CHARACTER None
INC Increment to use with the THRU  and BY keywords. INTEGER &amp;gt; 0 1
1 2 3 4 5 6 7 8 9 10
WETELMG WEID TYPE
G1 G2 G3 G4 G5 G6 G7 G8
WETELMG 10001 QUAD4
23 35 124 28&lt;/p&gt;
&lt;p&gt;203 Chapter 3: OpenFSI
Running an OpenFSI MSC Nastran Simulation
Main Index
Field Contents Type Default
WEID Wetted element identification number. INTERGER &amp;gt; 0 None
TYPE Wetted element type, which can be any of TRIA3, TRAI6, QUAD4,
QUAD8, LINE2  or LINE3 . CHARACTER None
G1, &amp;hellip;, G8 Grid point identification numbers for the wetted surface element WEID .INTERGER &amp;gt; 0 None&lt;/p&gt;
&lt;p&gt;204 User Defined Services User’s Guide
Running an OpenFSI MSC Nastran Simulation
Main Index
Table 3-8  Definition of a WETELME Entry
Format: WETELME
Example:
Running MSC Nastran
T o run an OpenFSI MSC Nastran simulation, a SCA service catalog, which contains references to available SCA services
components, and an associated library path, pointing to the interface functions library, must be specified. A resource
directory may also be specified. This is done by setting environment variables as follows:
setenv SCA SERVICE CATALOG $SCAPATH/Apps/res/SCAServiceCatalog.xml
setenv SCA LIBRARY PATH $SCAPATH/Apps/LX8664/lib/
setenv SCA RESOURCE DIR $SCAPATH/Apps/res/
if a csh shell is used. Here $SCAPATH  refers to the path where the SCA service components are installed on the system. For
a Bourne shell, like sh or bash, the environment variables are defined as:
export SCA SERVICE CATALOG=$SCAPATH/Apps/res/SCAServiceCatalog.xml
export SCA LIBRARY PATH=$SCAPATH/Apps/LX8664/lib/
export SCA RESOURCE DIR=$SCAPATH/Apps/res/
T o execute MSC Nastran with the input deck model.dat  simply enter the following line:
nastran model.dat
(See section Run Time Errors and Debugging  for possible run time errors, if there is a problem.)1 2 3 4 5 6 7 8 9 10
WETELME WEID EID SIDE
WETELME 10001 34 3
Field Contents Type Default
WEID Wetted element identification number. INTERGER &amp;gt; 0 None
EID Structural element identification number, which corresponds to a surface
element CQUAD4, CQUAD8, CQUADR, CQUAD, CTRIA3, CTRIA6,
CTRIAR ; or a solid element CTETRA, CPENTA, or CHEXA . INTERGER &amp;gt; 0 None
SIDE Side identification number of element EID. 1   INTEGER  6 None
Note:   For Windows, the library paths are:
set SCA_SERVICE_CATALOG=$SCAPATH/Apps/res/SCAServiceCatalog.xml
set SCA_LIBRARY_PATH=$SCAPATH/Apps/WINNT/lib
set SCA_RESOURCE_DIR=$SCAPATH/Apps/res&lt;/p&gt;
&lt;p&gt;205 Chapter 3: OpenFSI
Running an OpenFSI MSC Nastran Simulation
Main Index
Simple Example Model
Table 3-9 shows a trivial example with three elements, where the two triangular elements CTRIA3  belong to a wetted surface
srf1, and the single quadrilateral element CQUAD4  belongs to a different wetted surface srf2. The format of this input deck
can easily be extended to a larger mesh by defining multiple GRID, CTRIA3  or CQUAD4  entries and the corresponding
WETELMG, WETSURF  and WETLOAD  entries. T o run this model, the service ’ myService.OpenFSI ’ must be available as
a SCA component, with the corresponding SCAServiceCatalog.xml file and library, e.g. libmyService.so .
To run the example input deck example.dat  (defined in Table 3-9) in a csh shell, the following procedure is used:
setenv SCA_SERVICE_CATALOG $SCAPATH/Apps/res/SCAServiceCatalog.xml
setenv SCA_LIBRARY_PATH $SCAPATH/Apps/LX8664/lib/
setenv SCA_RESOURCE_DIR $SCAPATH/Apps/res/
where $SCAPATH  is replaced by the path to the SCA service installation on the local machine where MSC Nastran is to be
executed. MSC Nastran can now be executed:
nastran example.dat
Note that this procedure will execute MSC Nastran which will make function calls to the OpenFSI SCA service during
execution. If the specified OpenFSI SCA implementation depends on an additional process that the OpenFSI SCA module
relies on, as in the case of some CFD solver implementations, that process must be launched separately. Follow the
instructions for the particular CFD solver in question on how to launch that process.&lt;/p&gt;
&lt;p&gt;206 User Defined Services User’s Guide
Running an OpenFSI MSC Nastran Simulation
Main Index
Table 3-9  MSC Nastran Example Input Deck: example.dat
File Management CONNECT SERVICE SCAFSI’ExternalCodeVendor.OpenFSI’
Executive Control SOL NONLIN
CEND
Case Control TITLE = OpenFSI example
SUBCCASE 1
Analysis = NLTRAN
SPC = 1
DLOAD = 10
TSTEPNL = 1
Bulk Data BEGIN BULK
PSHELL 1 1 0.001 1
MAT1 1 2.1e11 0.337.0
DLOAD 10 1.0 1.0 111.012
TLOAD1 11 11 1 T1
TLOAD1 12 12 T1
TABLED1 100 LINEAR LINEAR
0.0 1.0 1.0e10 1.0ENDT
FSICTRL scafsi EXPLICIT 1
WETLOAD 11 1 scafsi
WETLOAD 12 2 scafsi
WETSURF 1 srf1
1 2
WETSURF 2 srf2
3
WETELMG 1 TRIA3
1 2 3
WETELME 2 TRIA3
2 4 3
WETELMG 3 QUAD
4 5 6 3
CIRIA3 1 1 1 23
CIRIA3 2 1 2 43
CQUAD4 3 1 4 563
GRID 1 0.0 0.00.0
GRID 2 2.0 0.00.0
GRID 3 1.0 2.00.0
GRID 4 4.0 2.00.0
GRID 5 4.0 4.00.0
GRID 6 1.0 4.00.0
SPC1 1 12345 1 2
TSTEPNL 1 100 0.01 1PFNT-1100
0.01 0.01 0.01
8 0
ENDDATA&lt;/p&gt;
&lt;p&gt;207 Chapter 3: OpenFSI
Creating an OpenFSI SCA Service
Main Index
Creating an OpenFSI SCA Service
Build Tools and Source Files
To create a user defined OpenFSI SCA service, the SDK provided with the MSC Nastran distribution is used. In addition,
a C/C++ compiler is needed to compile the source code. The SCA services are built using the scons tools included in the
distribution.
To build a user defined OpenFSI service called myOpenFSI  the following files are needed in the source directory:
myOpenFSI.cdl
myOpenFSI.cpp
myOpenFSI.h
myOpenFSI.sdl
OpenFSI.idl
SConscript
All these files are already created as a simple OpenFSI example located in&lt;br&gt;
$MSC_BASE/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/OpenFSI .
The procedure to build the SCA components in the SDK is the following:
1.Change directory to the source code root directory:
$MSC_BASE/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services
2.Build the SCA component from the source code root directory by simply entering scons .
The OpenFSI.idl  and SConscript  files that are provided with the SDK, are normally used to make all OpenFSI
services, so that only the files with root name myOpenFSI  need to be recreated (or use a different name) if a new services
is created from scratch. T o make a new OpenFSI component from scratch, use the following procedure:
1.Create a new myOpenFSI.sdl  file. A different name can be used if desired (but the extension should be .sdl ).
2.Use the executable genskeleton  to create skeletons for myOpenFSI.cpp  and myOpenFSI.h , i.e. files that
contain all method (function) signatures defining the OpenFSI interface, but no source code.
3.Implement the source code in the myOpenFSI.cpp  and myOpenFSI.h  skeleton files.
4.Create a new myOpenFSI.cdl  file
5.Build the SCA component from the source code root directory using scons.
Alternatively, it’s possible to only build the OpenFSI SCA component as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Locate the OpenFSI.idl  file and copy to the source directory.&lt;/li&gt;
&lt;li&gt;Create a new myOpenFSI.sdl  file.
3.Use the executable genskeleton to create skeletons for myOpenFSI.cpp  and myOpenFSI.h , i.e. files that contain
all method (function) signatures defining the OpenFSI interface, but no source code.
4.Implement the source code in the myOpenFSI.cpp  and myOpenFSI.h  skeleton files.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;208 User Defined Services User’s Guide
Creating an OpenFSI SCA Service
Main Index
5. Create a new myOpenFSI.cdl  file.
6.Build the SCA component from the OpenFSI source code directory by entering  scons &amp;ndash;qb4 .
T o include a static library add the following line to the SConscript  file:
env.AddLinkLibrary(&amp;quot;$LIBPATH/lib/libMyLib.a&amp;quot;)
where $LIBPATH  is the path to the install location of the library.
T o include a dynamic library add the following line to the SConscript  file:
env.AddLinkSharedLibrary(&amp;quot;$LIBPATH/lib/libMyLib.so&amp;quot;)
The document [ Reference 3 ] provides a tutorial on how an interface definition ( .idl ) file is created from scratch, along with
the creation of the service definition ( .sdl ) and component definition ( .cdl ) files. Here, the interface definition file is
already provided (see Interface Definition Language File ), and the service and component definition files provide the
interface for only one component, so the content in those files is straightforward (see Service Definition Language File  and
Component Definition Language File ). An overview of the interface definition and implementation of the OpenFSI
methods is given in the next section.
OpenFSI Interface and Implementation
As mentioned above, the interface for the OpenFSI SCA component is defined in the OpenFSI.idl  file, see Section
Interface Definition Language File , which provides the Application Programming Interface (API) for implementing the
external code connecting to the MSC Nastran solver.
The interface has the following basic structure for the solution data transfer:
 Initialization stage:
• initialize( wettedSurfaceMesh, initialCondition)
 Solver stage:
• initializeTimeStep( time, deltaTime)
• getWettedNodeForces( wettedNodeForces )
• putWettedNodeDisplacementsAndVelocities( wettedNodeDisplacement ,
wettedNodeVelocities)
• finalizeTimeStep(time)
Finalize stage:
•terminate(message)
where  indicates that discretization or solution data is sent from MSC Nastran to the service; indicatesNote:   Excluding the simulation control flags redoTimeStep and endSimulation, which data transfer is bidirectional.
The exact definition of the interface is given in Interface Definition Language File .&lt;/p&gt;
&lt;p&gt;209 Chapter 3: OpenFSI
OpenFSI_Ex Interface
Main Index
that force data is sent from the service and received by MSC Nastran; and  indicates that time and time step data is sent
from MSC Nastran to the service and (possibly different) time step received by MSC Nastran. Also see OpenFSI Data Flow .
To generate the skeleton code where the service methods are implemented, enter:
genskeleton myOpenFSI.sdl
This command will create the skeleton code files myOpenFSI.cpp  and myOpenFSI.h , based on the OpenFSI.idl file
within the name space provided in myOpenFSI.sdl.  The header file myOpenFSI.h  contains the declarations for the
OpenFSI service ’ myOpenFSI ’. The service implementation file myOpenFSI.cpp  contains a constructor and a destructor
for the service object, along with prototypes for the OpenFSI service methods that need to be populated with source code.
Once the source code has implemented, and the component definition file myOpenFSI.cdl  has been created, the service
component is built using scons from the source code root directory. Just enter:
scons
from the directory where the SConstruct  file is located. This command should create the OpenFSI SCA component files,
including the service catalog file SCAServiceCatalog.xml  in the Apps/res directory and e.g. the library
libmyService.so  in the Apps/LX8664/lib  for a Linux x86 64 system. The library name and directory name will
depend on the platform where the SCA component is built. The location must be consistent with the path defined by the
environment variables SCA_SERVICE_CATALOG, SCA_LIBRARY_PATH and SCA_RESOURCE_DIR  when executing
MSC Nastran.
See Run Time Errors and Debugging  for possible run time errors and debugging options.
OpenFSI_Ex Interface
The OpenFSI_Ex is an extension of the OpenFSI interface. The simulation flow chart of Nastran and external fluid solver
is the same as of the OpenFSI interface, but the data passed between the two sides are extended. In OpenFSI_Ex interface
method, the nodes displacement, velocity and acceleration are passed from Nastran to fluid solver, whereas the OpenFSI
method only passes displacement and velocity. In addition, the passed data includes both translational and rotational
DOFs, so there are total six DOFs for each node. For the nodal force obtained from fluid solver, it will include both force
and moment.
OpenFSI OpenFSI_Ex
T ranslational: T ranslational
Displacement;    Displacement;
Velocity    Velocity;
Acceleration
Rotational
Displacement;
Velocity;&lt;/p&gt;
&lt;p&gt;210 User Defined Services User’s Guide
OpenFSI_Ex Interface
Main Index
Creating an OpenFSI_Ex SCA Service
Like creating OpenFSI service described above, an OpenFSI_Ex service requires to implement the OpenFSI_Ex interface.
An example of OpenFSI_Ex service is provided with the installation at
$MSC_BASE/&lt;!-- raw HTML omitted --&gt;/$MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/OpenFSI_EX, the files are listed below.
OpenFSI_Ex.cdl
OpenFSI_Ex.cpp
OpenFSI_Ex.h
OpenFSI_Ex.sdl
SConscript
These files can be taken as a template and user implementation can be put in the corresponding source files. The build
procedure is the same as building other SCA services.
OpenFSI_Ex interface and implementation
The OpenFSI_Ex interface methods are defined in OpenFSI_Ex.idl, these methods will be called in analysis stages as the
following. See the interface IDL file and data flow figure in appendix for detail.
Initialization stage:
•initialize(wettedNodeSeq&amp;amp; seqNode,
wettedNodeExSeq&amp;amp; seqDisp,
wettedNodeExSeq&amp;amp; seqVelo,
wettedNodeExSeq&amp;amp; seqAcce,
wettedSurfaceSeq&amp;amp; seqSurf,
paramSeq&amp;amp; seqParam)
Solver stage:
•initializeTimeStep(SCAReal64 time,
SCAReal64&amp;amp; delta,
SCAReal64 minDelta,
SCAReal64 maxDelta,
SCABool&amp;amp; redoTimeStep)
•getWettedNodeForces(wettedNodeExSeq&amp;amp; seqForce,
SCABool&amp;amp; redoTimeStep)   Acceleration
Force Force;
MomentOpenFSI OpenFSI_Ex&lt;/p&gt;
&lt;p&gt;211 Chapter 3: OpenFSI
Appendix 1: OpenFSI Interface
Main Index
•putWettedNodeDispVeloAcce(wettedNodeExSeq&amp;amp; seqDisp,
wettedNodeExSeq&amp;amp; seqVelo,
wettedNodeExSeq&amp;amp; seqAcce,
SCABool&amp;amp; redoTimeStep)
•finalizeTimeStep(SCAReal64 time,
SCABool&amp;amp; endSimulation,
SCABool&amp;amp; redoTimeStep)
Finalize stage:
•terminate(SCAString message)
OpenFSI and OpenFSI_Ex Interface Call
The ANALYSIS filed in FSICTRL decides which interface methods will be called during analysis. It should be set in
accordance with the service implementation, i.e. it should be DV If the fluid service implement OpenFSI interface and U
for OpenFSI_Ex interaface.
Appendix 1: OpenFSI Interface
Interface Definition Language File
The IDL file used to build a SCA service connecting to the OpenFSI interface has the following form:
#ifndef SCA MDSOLVER UTIL OPENFSI OPENFSI IDL INCLUDED
#define SCA MDSOLVER UTIL OPENFSI OPENFSI IDL INCLUDED
#include &amp;ldquo;SCA/Service.idl&amp;rdquo;
module SCA {module MDSolver { module Util { module OpenFSI {
///
/// The following Type is used to define the &amp;ldquo;wetted element&amp;rdquo;.
///
enum wettedElementType
{
TRIA,
QUAD,
LINE
}
/// WETTED NODE:
///&lt;/p&gt;
&lt;p&gt;212 User Defined Services User’s Guide
Appendix 1: OpenFSI Interface
Main Index
/// The &amp;ldquo;wettedNode struct&amp;rdquo; consists of a grid point ID and a triplet of 64 bit
real numbers.
///
/// The grid point ID is a unique integer identifier for the wetted grid point.
///
/// The triplet is used to define any of the following:
/// (X,Y,Z) coordinates of the wetted grid point in the underformed (stress-
free) configuration of the structure.
/// (Ux,Uy,Uz) components of its TOTAL displacements.
/// (Vx,Vy,Vz) components of its velocity.
/// (Fx,Fy,Fz) components of the fluid force acting on it.
/// ALL the previous, measured in an orthogonal Cartesian coordinate system
which is referred to as the &amp;ldquo;BASIC&amp;rdquo; coordinates system.
///
/// Remark 1:
/// Let (X,Y,Z) be the UNDEFORMED (STRESS-FREE) coordinates of a given wetted
grid point.
/// Let (X0,Y0,Z0) be the coordinates of the same wetted grid point at the
initial time t=0.
/// Let (Xt,Yt,Zt) be the coordinates of the same wetted grid point at the
current time t.
/// By TOTAL displacements (at time t) we mean (Uxt,Uyt,Uzt) = (Xt,Yt,Zt) -
(X,Y,Z)
/// By TOTAL displacement at initial time t=0 (or INITIAL TOTAL displacements)
we mean (Ux0,Uy0,Uz0) = (X0,Y0,Z0) - (X,Y,Z)
/// Remark 2:
/// Notice that the undeformed configuration (or coordinates) of the structure
might be different from its INITIAL configuration.
/// In other words, at the initial time t=0, the structure might be &amp;ldquo;displaced&amp;rdquo;
from its Undeformed or stress-free configuration.
/// i.e, (X,Y,Z) might be different from (X0,Y0,Z0) and therefore (Ux0,Uy0,Uz0)
might be different from (0,0,0).
/// However, this INITIAL TOTAL displacement IS NOT CAUSED by fluid forces but
by other factors totally independent from the fluid.
/// Remark 3:
/// The TOTAL displacements shouldn’t be confused with the so called
INCREMENTAL displacements which
/// measure the displacement of a grid point between time &amp;ldquo;t&amp;rdquo; and the next time
step &amp;ldquo;t+dt&amp;rdquo;.
/// The structure code is concerned with the TOTAL displacements but NOT the
incremental displacements.
/// Remark 4:
/// By undeformed (or stress-free) configuration we mean the position of the
structure when all forces are zero (either fluid or non-fluid related).
/// and all (Dirichlet) boundary conditions and initial conditions are zero.
///
struct wettedNode
{
SCAInt64 id;
SCAReal64 x;&lt;/p&gt;
&lt;p&gt;213 Chapter 3: OpenFSI
Appendix 1: OpenFSI Interface
Main Index
SCAReal64 y;
SCAReal64 z;
};
/// WETTED ELEMENT:
///
/// A wetted element is either a line (with 2 or 3 nodes), quadrilateral (with
4 or 8 nodes) or a triangle (with 3 or 6 nodes).
/// A wetted element is defined by specifying its type, and its connectivity
table.
/// Grid points are listed in the following order:
/// G3
/// G1 o&amp;mdash;o&amp;mdash;o G2
///
///
///
///   G3 G4 G7  G3
///  o    o&amp;mdash;&amp;mdash;-o&amp;mdash;&amp;mdash;o
/// /     \ | |
/// G6 o          o G5                                   G8 o o G6
///           /                \ | |
/// o&amp;mdash;&amp;mdash;o&amp;mdash;&amp;mdash;o   o&amp;mdash;&amp;mdash;-o&amp;mdash;&amp;mdash;-o
/// G1 G4 G2 G1  G5 G2
///
/// The type (type) can be either LINE, TRIA or QUAD
/// The number of Nodes (numberOfNodes) can be either 2,3 for LINE, or 3,6 for TRIA or
4,8 for QUAD.
///
/// Notice that for quadratic triangles (TRIA-6) or quadratic quadrilaterals (QUAD-8),
the
/// corner grid points are mandatory (nonzero grid ids), however the mid-edge grid points
might be zero.
///
/// In other words, we are allowing the possibility of &amp;ldquo;incomplete quadratic&amp;rdquo; or
&amp;ldquo;partially quadratic&amp;rdquo; elements&lt;/p&gt;
&lt;p&gt;214 User Defined Services User’s Guide
Appendix 1: OpenFSI Interface
Main Index
/// where some of the edges are parabolas (defined with a non-zero mid-edge grid point)
and some of the edges
/// are straight lines (defined with a zero mid-edge grid point).
///
/// For example, consider the following &amp;ldquo;incomplete quadratic&amp;rdquo; quadrilateral with two
parabolic edges and two
/// straight edges
///     G4        G7      G3
///                                    o&amp;mdash;&amp;mdash;-o&amp;mdash;&amp;mdash;o
/// |           |
/// G8      o         |
/// |          |
/// o&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;o
///  G1     G2
///
/// In this case the TYPE is QUAD, NumberOfNodes is 8 (not 6) and the connectivity table
is the
sequence fG1,G3,G3,G4,0,0,G7,G8g
///
struct wettedElement
{
SCAInt64 id;          ///id of this wetted element
wettedElementType type;                   ///type of this wetted element. either LINE,
TRIA or QUAD
SCAUInt32 numberOfNodes;            ///Number of nodes. 2 or 3 for LINE, 3 or 6 for TRIA;
4 or
8 for QUAD
SCAInt64Sequence connectivity;    ///sequence of wetted node IDs.
};
///
/// WETTED SURFACE:
///&lt;/p&gt;
&lt;p&gt;215 Chapter 3: OpenFSI
Appendix 1: OpenFSI Interface
Main Index
/// A wetted surface is a sequence or collection of wetted elements.
/// For each wetted surface, we define also an integer identification number and a
character label.
///
typedef sequence&lt;!-- raw HTML omitted --&gt; wettedElementSeq;
struct wettedSurface
{
SCAInt64 wettedSurfaceId;                               ///Integer ID of this wetted surface
SCAString wettedSurfaceTag;                          ///Character string tag to identify
this surface
wettedElementSeq wettedElements;                ///Sequence of wetted elements, in any
order, possibly with
mixed types (TRIA and QUAD)
};
///
/// A wetted node sequence collects all the wetted nodes
/// This sequence will be used to get or pass any of the following
/// -Undeformed (stress-free) coordinates of wetted nodes (wettedNodeCoordinates)
/// -Initial displacements of wetted nodes (wettedNodeDisplacements)
/// -Initial velocities of wetted nodes (wettedNodeVelocities)
/// -Current displacements of wetted nodes (wettedNodeDisplacements)
/// -Current velocities of wetted nodes (wettedNodeVelocities)
/// -Current forces on wetted nodes (wettedNodeForces)
typedef sequence&lt;!-- raw HTML omitted --&gt; wettedNodeSeq;
///
/// A wetted surface sequence collects all the wetted surfaces.
///
typedef sequence&lt;!-- raw HTML omitted --&gt; wettedSurfaceSeq;
interface SCAIMDSolverOpenFSI : SCAIService
{
///&lt;/p&gt;
&lt;p&gt;216 User Defined Services User’s Guide
Appendix 1: OpenFSI Interface
Main Index
/// INITIALIZE METHOD:
///
/// The initialize method sends from the structure to the fluid the following data:
/// 1-The UNDEFORMED or STRESS-FREE positions of &amp;ldquo;wetted&amp;rdquo; grid points.
/// 2-The initial TOTAL displacements of &amp;ldquo;wetted&amp;rdquo; grid points.
/// 2-The initial velocities of &amp;ldquo;wetted&amp;rdquo; grid points.
/// 3-The &amp;ldquo;wetted elements&amp;rdquo; with are either lines (LINE), triangles (TRIA) or
quadrilaterals (QUAD)
///
with
2,3 or 3,6 or 4,8 &amp;ldquo;wetted nodes&amp;rdquo;.
////Remark 1:
/// The wetted elements are not sent as a single sequence but as a sequence of wetted
surfaces,each of which is a sequence of wetted elements.
/// Each wetted surface is assigned and integer and character id to help the fluid code
map structural grids with fluid grids.
/// Remark 2:
/// We emphasize that the &amp;ldquo;initial&amp;rdquo; configuration (or positions) of the structure does
not necessarily coincide with the &amp;ldquo;undeformed&amp;rdquo; or &amp;ldquo;stress-free&amp;rdquo; configuration.
/// The user of the structural code typically defines the &amp;ldquo;undeformed&amp;rdquo; positions (X,Y,Z)
and initial displacements (Ux0,Uy0,Uz0) and velocities (Vx0,Vy0,Vz0) of
/// the structural grid points.
/// Then, the &amp;ldquo;initial positions&amp;rdquo; ( X0,Y0,Z0 ) are defined as &amp;ldquo;undeformed position +
initial displacement&amp;rdquo;: ( X0,Y0,Z0 ) = (X,Y,Z) + (Ux0,Uy0,Uz0)
/// The fluid code will get from the structural code the UNDEFORMED positions (X,Y,Z)
and initial displacements (Ux0,Uy0,Uz0)
/// (everything measured in BASIC coordinate system) but NOT the initial positions
(X0,Y0,Z0).
/// Remark 3:
/// A Wetted Surface is a collection (sequence) of &amp;ldquo;Wetted Elements&amp;rdquo; with an integer id
and a character label.
/// A &amp;ldquo;Wetted Surface Sequence&amp;rdquo; is a collection of &amp;ldquo;Wetted surfaces&amp;rdquo;.
/// Remark 4:
/// Wetted surfaces can list mixed types (TRIA,QUAD) in any order.&lt;/p&gt;
&lt;p&gt;217 Chapter 3: OpenFSI
Appendix 1: OpenFSI Interface
Main Index
///
SCAResult initialize( in wettedNodeSeq wettedNodeCoordinates,           ///undeformed
(stress-free)
coordinates of wetted nodes (X,Y,Z)
in wettedNodeSeq wettedNodeDisplacements,        ///initial TOTAL displacements of wetted
nodes
(Ux0,Uy0,Uz0)
in wettedNodeSeq wettedNodeVelocities,      ///initial TOTAL velocities of wetted nodes
(Vx0,Vy0,Vz0)
in wettedSurfaceSeq wettedSurfaces );         ///collection of wetted surfaces (which
define
the connectivity of all the elements)
///
/// Time step intitialization
///
SCAResult initializeTimeStep( in SCAReal64 time,
inout SCAReal64 deltaTime,
in SCAReal64 minimumDeltaTime,
in SCAReal64 maximumDeltaTime,
inout SCABool redoTimeStep );
///
/// Time step termination
///
SCAResult finalizeTimeStep( in SCAReal64 time,
inout SCABool endSimulation,
inout SCABool redoTimeStep );
///
/// GET FORCES METHOD:
///
/// The getWettedNodeForces method sends the following information from the fluid to the
structure code:
/// &amp;ldquo;current&amp;rdquo; fluid forces (fx,fy,fz) acting on all wetted node &amp;ldquo;id&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;218 User Defined Services User’s Guide
Appendix 1: OpenFSI Interface
Main Index
/// Remark 1:
/// The forces are collected in a sequence of wettedNode struct fid,fx,fy,fzg
/// Remark 2:
/// Forces are measured in the BASIC coordinate system.
/// Remark 3:
/// It is anticipated that the fluid mesh is different (and finer) than the structural
mesh.
/// The structural code expects forces at the structural (wetted) grid points.
/// A &amp;ldquo;mapping&amp;rdquo; between the fluid mesh and the structural (wetted) mesh is typically
required
as part of this method.
/// The (wetted) structural mesh is provided from the structural code to the fluid code
when
the INITIALIZE method is called to facilitate this mapping if required.
///
///
SCAResult getWettedNodeForces( out wettedNodeSeq wettedNodeForces,
inout SCABool redoTimeStep );
///
/// PUT DISPLACEMENTS AND VELOCITIES METHOD:
///
/// The putWettedNodeDisplacementsAndVelocities method sends the following information
from the structure to the fluid code:
/// &amp;ldquo;current&amp;rdquo; TOTAL displacements (Ux,Uy,Uz) of all wetted node &amp;ldquo;id&amp;rdquo;.
/// &amp;ldquo;current&amp;rdquo; velocities (Vx,Vy,Vz) of all wetted node &amp;ldquo;id&amp;rdquo;.
///
/// Remark 1:
/// The displacements and velocities are collected in sequences of wettedNode struct
fid,Ux,Uy,Uzg and fid,Vx,Vy,Vzg
/// Remark 2:
/// Displacements and Velocities are measured in the BASIC coordinate system.
/// Remark 3:&lt;/p&gt;
&lt;p&gt;219 Chapter 3: OpenFSI
Appendix 1: OpenFSI Interface
Main Index
/// This method concerns TOTAL displacements, i.e., displacements with respect to the
UNDEFORMED or stress-free configuration.
/// (as opposed to INITIAL displacements (those measured from initial configuration) or
INCREMENTAL displacements (those measured from the previous time step).
///
SCAResult putWettedNodeDisplacementsAndVelocities( in wettedNodeSeq
wettedNodeDisplacements,                  ///&amp;ldquo;Current&amp;quot;TOTAL displacements of wetted nodes
(Ux,Uy,Uz) in wettedNodeSeq wettedNodeVelocities,      ///&amp;ldquo;Current&amp;rdquo; TOTAL velocities of
wetted nodes (Vx,Vy,Vz)&lt;br&gt;
inout SCABool redoTimeStep ) ;
///
/// Termination with message
///
SCAResult terminate( in SCAString message );
};
}; }; }; };
#endif
Service Definition Language File
The OpenFSI service definition language file has the content:
#ifndef MYOPENFSI OPENFSI SDL INCLUDE
#define MYOPENFSI OPENFSI SDL INCLUDE
#include &amp;ldquo;SCA/OpenFSI.idl&amp;rdquo;
module OpenFSI {
service myOpenFSI
{
interface SCA::MDSolver::Util::OpenFSI::SCAIMDSolverOpenFSI;
};
};
#endif&lt;/p&gt;
&lt;p&gt;220 User Defined Services User’s Guide
Appendix 1: OpenFSI Interface
Main Index
Component Definition Language File
The OpenFSI component definition language file has the content:
#ifndef MYOPENFSI OPENFSI CDL INCLUDE
#define MYOPENFSI OPENFSI CDL INCLUDE
#include &amp;ldquo;myOpenFSI.sdl&amp;rdquo;
component Test.OpenFSI
{
service myOpenFSI;
};
#endif
OpenFSI Data Flow
The data flow for an OpenFSI MSC Nastran simulation is illustrated in Figures 3-4 and 3-5.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P12</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_012/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_012/</guid>
      <description>
        
        
        &lt;p&gt;221 Chapter 3: OpenFSI
Appendix 1: OpenFSI Interface
Main Index
Figure 3-4  Data Flow for the MSC Nastran Nonlinear Solver Module for an Explicit OpenFSI SCA service
This is the simplest type of service, as the nodal forces from the external code are only read at the beginning of the time
step, and the nodal results, the displacement and velocity, are only sent at the end of the time step. The arrows indicate the
data flow besides the Boolean parameters redoTimeStep  and endSimulation .&lt;/p&gt;
&lt;p&gt;222 User Defined Services User’s Guide
Appendix 1: OpenFSI Interface
Main Index
Figure 3-5  Data Flow For The Mdnastran Nonlinear Solver Module For An Implicit Openfsi Sca Service
In the implicit service, the data is communicated inside the Newton-Raphson loop at a frequency specified by the FSICTRL&lt;br&gt;
entry in the bulk data  section. Note that the nodal forces are also read at the beginning of the time step before entering the
Newton-Raphson loop (not shown here), in which case the FSI forces do not have to be read at the first iteration. The
arrows indicate the data flow besides the Boolean parameters redoTimeStep  and endSimulation .
Run Time Errors and Debugging
Reasons for a run time failure can be:
Mispelled service name. If the correct service name is myOpenFSI  but the service name wrongServiceName  is
used in the input deck, the following error message will show in the .f06  file:&lt;/p&gt;
&lt;p&gt;223 Chapter 3: OpenFSI
Appendix 1: OpenFSI Interface
Main Index
Also note that the CONNECT SERVICE scafsi ’myOpenFSI’  statement must use a single  space as separator.
 Incorrect SCA_LIBRARY_PATH  specification gives the error message:
Note that if the library is specified to be located in a subdirectory to lib, say lib/Test , (it will say
library=&amp;ldquo;Test/OpenFSI&amp;rdquo; in the SCAServiceCatalog.xml  file), the specified path should still point to
lib.
Incorrect SCA_SERVICE_CATALOG  specification gives the error message:
Note that similarity with error messages above.
Incorrect or misspelled SERV ID  name in WETLOAD  entry gives the error message (in the .f06 ) file:
(The OpenFSI service will subsequently not be loaded.)
A WETSURF  entry without a corresponding WETLOAD  entry will give the error message (in the .f06 ) file:
An incorrect res/types  directory gives the error (in the .log  file):*** USER FATAL MESSAGE 7831 (SCA Service Loader)
SCA wrongServiceName service initialization failed.
Table 3-1&lt;br&gt;
*** USER FATAL MESSAGE 7831 (SCA Service Loader)
SCA myOpenFSI service initialization failed.
Table 3-2&lt;br&gt;
*** USER FATAL MESSAGE 7831 (SCA Service Loader)
SCA myOpenFSI service initialization failed.
Table 3-3&lt;br&gt;
Error: Missing FSICTRL
Table 3-4&lt;br&gt;
*** USER FATAL MESSAGE 13 (GPWET)
ERROR IN DMAP INSTRUCTION Incorrect number of WETSURFs INSTRUCTION NO.WETSURFs
Table 3-5&lt;br&gt;
Failed to initialize SCA kernel.
Error message is: SCA.SCASystemException - XML
TypeCodes: &amp;ldquo;Error 55&amp;rdquo; (ID=2000000150) ** ERROR **
SCA KERNEL INIT FAILED. STOP IN NASTMAIN&lt;/p&gt;
&lt;p&gt;224 User Defined Services User’s Guide
Appendix 2: OpenFSI_Ex Interface
Main Index
(T ry deleting res/types/Test/OpenFSIComp.xml .)
T o include more diagnostic messages during run time, set DIAG 51  in the executive control section in the input deck. In
addition, the environment variable SCA_KERNEL_DEBUG  can be used to debug the SCA service, e.g.:
setenv SCA KERNEL DEBUG
’SvcCatalogDump=all,SvcLoad=all,SvcTableDump=all,ShrLibLoad=all’.
Appendix 2: OpenFSI_Ex Interface
Interface Definition Language File
The IDL file of OpenFSI_Ex interface is as the following:
#ifndef SCA_MDSOLVER_UTIL_OPENFSI_EX_IDL_INCLUDED
#define SCA_MDSOLVER_UTIL_OPENFSI_EX_IDL_INCLUDED
#include &amp;ldquo;SCA/Service.idl&amp;rdquo;
module SCA {module MDSolver {module Util {module OpenFSI_Ex {
/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The following type is used to define the &amp;ldquo;wetted element&amp;rdquo;,&lt;/li&gt;
&lt;li&gt;the element type must be TRIA, QUAD or LINE.
&lt;em&gt;/
enum wettedElementType {TRIA, QUAD, LINE, UNKNOWN};
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;The model parameter structure
*&lt;/li&gt;
&lt;li&gt;The model parameters are used to pass Nastran model data to&lt;/li&gt;
&lt;li&gt;external solver. The name indentifies the parameter and&lt;/li&gt;
&lt;li&gt;the value gives the parameter value. The Nastran parameters&lt;/li&gt;
&lt;li&gt;that will be passed to solver are defined as the following.&lt;/li&gt;
&lt;li&gt;On the solver side, the solver can go through the paramter&lt;/li&gt;
&lt;li&gt;sequence and get the interested parameter. Or the solver can ignore&lt;/li&gt;
&lt;li&gt;the parameters if it does not need to access Nastran data.
*&lt;/li&gt;
&lt;li&gt;NS_SERVICE_TAG: the service tag name, string type&lt;/li&gt;
&lt;li&gt;NS_MODEL_NAME: the model name, string type&lt;/li&gt;
&lt;li&gt;NS_INPUT_PATH: the input file path, string type&lt;/li&gt;
&lt;li&gt;NS_DATABLOCK_EPT: the EPT data block number, integer type&lt;/li&gt;
&lt;li&gt;NS_DATABLOCK_EDT: the EDT data block number, integer type&lt;/li&gt;
&lt;li&gt;NS_DATABLOCK_MPT: the MPT data block number, integer type&lt;/li&gt;
&lt;li&gt;NS_DATABLOCK_DIT: the DIT data block number, integer type&lt;/li&gt;
&lt;li&gt;NS_DATABLOCK_GEOM1: the GEOM1 data block number, integer type&lt;/li&gt;
&lt;li&gt;NS_DATABLOCK_GEOM2: the GEOM2 data block number, integer type&lt;/li&gt;
&lt;li&gt;NS_DATABLOCK_DTI: the DTI data block number, integer type&lt;/li&gt;
&lt;li&gt;NS_DATABLOCK_DTIDNX: the DTINDX data block number, integer type
&lt;em&gt;/
struct modelParam { // model parameters that may be used in
//external solver
SCAString name; // the name of the parameter, such as
//NS_DATABLOCK_EPT
SCAAny value; // the value of the parameter
};
/&lt;/em&gt;*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;225 Chapter 3: OpenFSI
Appendix 2: OpenFSI_Ex Interface
Main Index&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The model paramter sequence, it will be passed as argument to&lt;/li&gt;
&lt;li&gt;external solver.With SCA EmbGino service, the external solver&lt;/li&gt;
&lt;li&gt;can get Nastran data using parameters in this sequence.&lt;/li&gt;
&lt;li&gt;For example, the solver can open EDT data block using the passed&lt;/li&gt;
&lt;li&gt;block number identified by name string NS_DATABLOCK_EDT.
&lt;em&gt;/
typedef sequence&lt;!-- raw HTML omitted --&gt; paramSeq;
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;The &amp;ldquo;wettedNode struct&amp;rdquo; consists of a grid point ID and a triplet&lt;/li&gt;
&lt;li&gt;of 64 bit real numbers.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;The grid point ID is a unique integer identifier for the wetted&lt;/li&gt;
&lt;li&gt;grid point, the triplet is used to define the coordinates of&lt;/li&gt;
&lt;li&gt;the wetted grid point in the underformed (stress-free) configuration&lt;/li&gt;
&lt;li&gt;of the structure.
&lt;em&gt;/
struct wettedNode {
SCAInt64 id; //id
SCAReal64 x; //coordinates
SCAReal64 y;
SCAReal64 z;
};
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;The wetted node sequence, it is used to pass wettted node coordinates.
&lt;em&gt;/
typedef sequence&lt;!-- raw HTML omitted --&gt; wettedNodeSeq;
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;The wettedNodeEx struct is an extension of wettedNode, it consists of&lt;/li&gt;
&lt;li&gt;a grid point ID and six 64 bit real number components.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;The grid point ID is a unique integer identifier for the wetted grid&lt;/li&gt;
&lt;li&gt;point.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;The six real numbers are used to define any of the following:&lt;/li&gt;
&lt;li&gt;(Ux,Uy,Uz,Rx,Ry,Rz) components of its TOTAL displacements,&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;                 including rotations.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;(Vx,Vy,Vz,Vrx,Vry,Vrz) components of its velocity,&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;                    including angular velocity.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;(Ax,Ay,Az,Arx,Ary,Arz) components of its acceleration,&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;                    including angular acceleration.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;(Fx,Fy,Fz,Mx,My,Mz) components of the fluid force acting on it,&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;                 including moment.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;ALL the previous, measured in an orthogonal Cartesian coordinate&lt;/li&gt;
&lt;li&gt;system which is referred to as the &amp;ldquo;BASIC&amp;rdquo; coordinates system.
*&lt;/li&gt;
&lt;li&gt;Remark 1:&lt;/li&gt;
&lt;li&gt;Let (X,Y,Z) be the UNDEFORMED (STRESS-FREE) coordinates&lt;/li&gt;
&lt;li&gt;of a given wetted grid point.&lt;/li&gt;
&lt;li&gt;Let (X0,Y0,Z0) be the coordinates of the same wetted&lt;/li&gt;
&lt;li&gt;grid point at the initial time t=0.&lt;/li&gt;
&lt;li&gt;Let (Xt,Yt,Zt) be the coordinates of the same wetted grid&lt;/li&gt;
&lt;li&gt;point at the current time t.&lt;/li&gt;
&lt;li&gt;By TOTAL displacements (at time t) we mean&lt;/li&gt;
&lt;li&gt;(Uxt,Uyt,Uzt) = (Xt,Yt,Zt) - (X,Y,Z)&lt;/li&gt;
&lt;li&gt;By TOTAL displacement at initial time t=0 (or INITIAL TOTAL&lt;/li&gt;
&lt;li&gt;displacements) we mean (Ux0,Uy0,Uz0) = (X0,Y0,Z0) - (X,Y,Z)
*&lt;/li&gt;
&lt;li&gt;Remark 2:&lt;/li&gt;
&lt;li&gt;Notice that the undeformed configuration (or coordinates) of&lt;/li&gt;
&lt;li&gt;the structure might be different from its INITIAL configuration.&lt;/li&gt;
&lt;li&gt;In other words, at the initial time t=0, the structure might be&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;226 User Defined Services User’s Guide
Appendix 2: OpenFSI_Ex Interface
Main Index&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;displaced&amp;rdquo; from its Undeformed or stress-free configuration.&lt;/li&gt;
&lt;li&gt;i.e, (X,Y,Z) might be different from (X0,Y0,Z0) and therefore&lt;/li&gt;
&lt;li&gt;(Ux0,Uy0,Uz0) might be different from (0,0,0).&lt;/li&gt;
&lt;li&gt;However, this INITIAL TOTAL displacement IS NOT CAUSED by fluid&lt;/li&gt;
&lt;li&gt;forces but by other factors totally independent from the fluid.
*&lt;/li&gt;
&lt;li&gt;Remark 3:&lt;/li&gt;
&lt;li&gt;The TOTAL displacements shouldn&amp;rsquo;t be confused with the so called&lt;/li&gt;
&lt;li&gt;INCREMENTAL displacements which measure the displacement of a grid&lt;/li&gt;
&lt;li&gt;point between time &amp;ldquo;t&amp;rdquo; and the next time step &amp;ldquo;t+dt&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;The structure code is concerned with the TOTAL displacements&lt;/li&gt;
&lt;li&gt;but NOT the incremental displacements.
*&lt;/li&gt;
&lt;li&gt;Remark 4:&lt;/li&gt;
&lt;li&gt;By undeformed (or stress-free) configuration we mean the position&lt;/li&gt;
&lt;li&gt;of the structure when all forces are zero (either fluid or&lt;/li&gt;
&lt;li&gt;non-fluid related). and all (Dirichlet) boundary conditions&lt;/li&gt;
&lt;li&gt;and initial conditions are zero.
&lt;em&gt;/
struct wettedNodeEx {
SCAInt64 id;
SCAReal64 x; //transitional
SCAReal64 y;
SCAReal64 z;
SCAReal64 rx; //rotational
SCAReal64 ry;
SCAReal64 rz;
};
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;The wetted node extension structure sequence, it is used to get&lt;/li&gt;
&lt;li&gt;and pass wetted nodes displacement, velocity, acceleration and force.
&lt;em&gt;/
typedef sequence&lt;!-- raw HTML omitted --&gt; wettedNodeExSeq;
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;The wetted element
*&lt;/li&gt;
&lt;li&gt;A wetted element is either a line (with 2 or 3 nodes), quadrilateral&lt;/li&gt;
&lt;li&gt;(with 4 or 8 nodes) or a triangle (with 3 or 6 nodes).&lt;/li&gt;
&lt;li&gt;A wetted element is defined by specifying its type, and its&lt;/li&gt;
&lt;li&gt;connectivity table.Grid points are listed in the following order:
*&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;     G3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;G1 o&amp;mdash;o&amp;mdash;o G2
*
*
*&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;    G3            G4    G7   G3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;    o               o---o---o
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;   / \              |       |
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;G6 o   o G5       G8 o       o G6&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; /     \            |       |
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;o---o---o           o---o---o
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;G1   G4    G2       G1    G5   G2
*&lt;/li&gt;
&lt;li&gt;The type (type) can be either LINE, TRIA or QUAD&lt;/li&gt;
&lt;li&gt;The number of Nodes (numberOfNodes) can be either 2,3 for LINE,&lt;/li&gt;
&lt;li&gt;or 3,6 for TRIA or 4,8 for QUAD.
*&lt;/li&gt;
&lt;li&gt;Notice that for quadratic triangles (TRIA-6) or quadratic&lt;/li&gt;
&lt;li&gt;quadrilaterals (QUAD-8), the corner grid points are mandatory&lt;/li&gt;
&lt;li&gt;(nonzero grid ids), however the mid-edge grid points might be zero.
*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;227 Chapter 3: OpenFSI
Appendix 2: OpenFSI_Ex Interface
Main Index&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In other words, we are allowing the possibility of&lt;/li&gt;
&lt;li&gt;&amp;ldquo;incomplete quadratic&amp;rdquo; or &amp;ldquo;partially quadratic&amp;rdquo; elements&lt;/li&gt;
&lt;li&gt;where some of the edges are parabolas (defined with&lt;/li&gt;
&lt;li&gt;a non-zero mid-edge grid point) and some of the edges&lt;/li&gt;
&lt;li&gt;are straight lines (defined with a zero mid-edge grid point).
*&lt;/li&gt;
&lt;li&gt;For example, consider the following &amp;ldquo;incomplete quadratic&amp;rdquo;&lt;/li&gt;
&lt;li&gt;quadrilateral with two parabolic edges and two straight edges
*&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;        G4   G7   G3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;         o---o---o
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;         |       |
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;    G8   o       |
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;         |       |
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;         o-------o
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;       G1         G2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In this case the TYPE is QUAD, NumberOfNodes is 8 (not 6)&lt;/li&gt;
&lt;li&gt;and the connectivity table is the sequence {G1,G3,G3,G4,0,0,G7,G8}
*
&lt;em&gt;/
struct wettedElement {
SCAInt64 id;                     // id of this wetted element
wettedElementType type;          // type of this wetted element.
// either LINE, TRIA or QUAD
SCAUInt32 numberOfNodes;         // Number of nodes. 2 or 3 for LINE,
// 3 or 6 for TRIA; 4 or 8 for QUAD
SCAInt64Sequence connectivity;   // sequence of wetted node IDs.
};
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;The wetted element sequence
&lt;em&gt;/
typedef sequence&lt;!-- raw HTML omitted --&gt; wettedElementSeq;
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;The wetted surface
*&lt;/li&gt;
&lt;li&gt;The wetted surface is a sequence or collection of wetted elements,&lt;/li&gt;
&lt;li&gt;it has an interger id and character lable.
&lt;em&gt;/
struct wettedSurface {
SCAInt64 wettedSurfaceId;       // Integer ID of this wetted surface
SCAString wettedSurfaceTag;     // Character string tag to identify
// this surface
wettedElementSeq wettedElements;// Sequence of wetted elements,
//in any order, possibly with
//mixed types (TRIA and QUAD)
};
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;The wetted surface sequence
*&lt;/li&gt;
&lt;li&gt;The wetted surface sequence is a collection of wetted surfaces
&lt;em&gt;/
typedef sequence&lt;!-- raw HTML omitted --&gt; wettedSurfaceSeq;
//OpenFSI_Ex interface methods
interface SCAIMDSolverOpenFSI_Ex : SCAIService {
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;Initialization
*&lt;/li&gt;
&lt;li&gt;The initialize method sends from the structure to the fluid the&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;228 User Defined Services User’s Guide
Appendix 2: OpenFSI_Ex Interface
Main Index&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;following data:&lt;/li&gt;
&lt;li&gt;1 - The UNDEFORMED or STRESS-FREE positions of &amp;ldquo;wetted&amp;rdquo; grid&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;points
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;2 - The initial TOTAL displacements of &amp;ldquo;wetted&amp;rdquo; grid points&lt;/li&gt;
&lt;li&gt;3 - The initial velocities of &amp;ldquo;wetted&amp;rdquo; grid points&lt;/li&gt;
&lt;li&gt;4 - The initial accelerations of &amp;ldquo;wetted&amp;rdquo; grid points&lt;/li&gt;
&lt;li&gt;5 - The &amp;ldquo;wetted elements&amp;rdquo; which are either lines (LINE),&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;triangles (TRIA) or quadrilaterals (QUAD)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;with 2,3 or 3,6 or 4,8 &amp;quot;wetted nodes&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;6 - The model paramters for external solver to use
*&lt;/li&gt;
&lt;li&gt;Remark 1:&lt;/li&gt;
&lt;li&gt;The wetted elements are not sent as a single sequence but as&lt;/li&gt;
&lt;li&gt;a sequence of wetted surfaces, each of which is a sequence of&lt;/li&gt;
&lt;li&gt;wetted elements.&lt;/li&gt;
&lt;li&gt;Each wetted surface is assigned and integer and character id&lt;/li&gt;
&lt;li&gt;to help the fluid code map structural grids with fluid grids.&lt;/li&gt;
&lt;li&gt;Remark 2:&lt;/li&gt;
&lt;li&gt;We emphasize that the &amp;ldquo;initial&amp;rdquo; configuration (or positions)&lt;/li&gt;
&lt;li&gt;of the structure does not necessarily coincide with the&lt;/li&gt;
&lt;li&gt;&amp;ldquo;undeformed&amp;rdquo; or &amp;ldquo;stress-free&amp;rdquo; configuration.&lt;/li&gt;
&lt;li&gt;The user of the structural code typically defines the&lt;/li&gt;
&lt;li&gt;&amp;ldquo;undeformed&amp;rdquo; positions (X,Y,Z) and initial displacements&lt;/li&gt;
&lt;li&gt;(Ux0,Uy0,Uz0) and velocities (Vx0,Vy0,Vz0) of the structural&lt;/li&gt;
&lt;li&gt;grid points.&lt;/li&gt;
&lt;li&gt;Then, the &amp;ldquo;initial positions&amp;rdquo; ( X0,Y0,Z0 ) are defined as&lt;/li&gt;
&lt;li&gt;&amp;ldquo;undeformed position + initial displacement&amp;rdquo;:&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;      ( X0,Y0,Z0 ) = (X,Y,Z) + (Ux0,Uy0,Uz0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;The fluid code will get from the structural code the&lt;/li&gt;
&lt;li&gt;UNDEFORMED positions (X,Y,Z) and initial displacements&lt;/li&gt;
&lt;li&gt;(Ux0,Uy0,Uz0)(everything measured in BASIC coordinate system)&lt;/li&gt;
&lt;li&gt;but NOT the initial positions (X0,Y0,Z0).&lt;/li&gt;
&lt;li&gt;Remark 3:&lt;/li&gt;
&lt;li&gt;A Wetted Surface is a collection (sequence) of &amp;ldquo;Wetted Elements&amp;rdquo;&lt;/li&gt;
&lt;li&gt;with an integer id and a character label.&lt;/li&gt;
&lt;li&gt;A &amp;ldquo;Wetted Surface Sequence&amp;rdquo; is a collection of &amp;ldquo;Wetted surfaces&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Remark 4:&lt;/li&gt;
&lt;li&gt;Wetted surfaces can list mixed types (TRIA,QUAD) in any order.
*&lt;/li&gt;
&lt;li&gt;@param seqNode : the original undeformed (stress-free) wetted&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;             node id and coordinates
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;@param seqDisp : the initial wetted node displacement&lt;/li&gt;
&lt;li&gt;@param seqVelo : the initial wetted node velocity&lt;/li&gt;
&lt;li&gt;@param seqVelo : the initial wetted node acceleration&lt;/li&gt;
&lt;li&gt;@param seqSurf : the wetted surfaces, each wet surface consists&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;             of wetted elements.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;@param seqparam: the model parameter sequence&lt;/li&gt;
&lt;li&gt;@return : SCASuccess if the initialization is successful,&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;      otherwise, SCAError.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;/
SCAResult initialize(in wettedNodeSeq seqNode,
in wettedNodeExSeq seqDisp,
in wettedNodeExSeq seqVelo,
in wettedNodeExSeq seqAcce,
in wettedSurfaceSeq seqSurf,
in paramSeq seqParam);
/&lt;/em&gt;*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Get wetted node force from external solver, including node force&lt;/li&gt;
&lt;li&gt;and moment.
*&lt;/li&gt;
&lt;li&gt;The getWettedNodeForces method gets force acting on wetted node&lt;/li&gt;
&lt;li&gt;from the fluid to the structure code, the force includes&lt;/li&gt;
&lt;li&gt;transitional force and moment. If there is no moment on wetted&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;229 Chapter 3: OpenFSI
Appendix 2: OpenFSI_Ex Interface
Main Index&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node, the moment value should be set to zero.
*&lt;/li&gt;
&lt;li&gt;Remark 1:&lt;/li&gt;
&lt;li&gt;The forces are collected in a sequence of wettedNodeEx struct&lt;/li&gt;
&lt;li&gt;{id,fx,fy,fz,mx,my,mz}&lt;/li&gt;
&lt;li&gt;Remark 2:&lt;/li&gt;
&lt;li&gt;Forces are measured in the BASIC coordinate system.&lt;/li&gt;
&lt;li&gt;Remark 3:&lt;/li&gt;
&lt;li&gt;It is anticipated that the fluid mesh is different (and finer)&lt;/li&gt;
&lt;li&gt;than the structural mesh.&lt;/li&gt;
&lt;li&gt;The structural code expects forces at the structural (wetted)&lt;/li&gt;
&lt;li&gt;grid points.&lt;/li&gt;
&lt;li&gt;A &amp;ldquo;mapping&amp;rdquo; between the fluid mesh and the structural (wetted)&lt;/li&gt;
&lt;li&gt;mesh is typically required as part of this method.&lt;/li&gt;
&lt;li&gt;The (wetted) structural mesh is provided from the structural&lt;/li&gt;
&lt;li&gt;codeto the fluid code when the INITIALIZE method is called to&lt;/li&gt;
&lt;li&gt;facilitate this mapping if required.
*&lt;/li&gt;
&lt;li&gt;@param seqForce : the sequence of nodal force, including moment.&lt;/li&gt;
&lt;li&gt;@param redoTimeStep : the redo flag passed between Nastran and&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;                  fluid solver for this time step
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;@return SCASuccess if successful, otherwise, SCAError.
&lt;em&gt;/
SCAResult getWettedNodeForces(inout wettedNodeExSeq seqForce,
inout SCABool redoTimeStep);
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;Send wetted node data to fluid solver
*&lt;/li&gt;
&lt;li&gt;The data sent to solver includes displacement, velocity and&lt;/li&gt;
&lt;li&gt;acceleration.
*&lt;/li&gt;
&lt;li&gt;Remark 1:&lt;/li&gt;
&lt;li&gt;The displacement, velocity and acceleration are collected in&lt;/li&gt;
&lt;li&gt;sequences of wettedNodeEx struct {id,Ux,Uy,Uz, Rx,Ry,Rz},&lt;/li&gt;
&lt;li&gt;{id,Vx,Vy,Vz,Vrx,Vry,Vrz} and {id,Ax,Ay,Az,Arx,Ary,Arz}.&lt;/li&gt;
&lt;li&gt;Remark 2:&lt;/li&gt;
&lt;li&gt;Displacement, velocity and acceleration are measured in&lt;/li&gt;
&lt;li&gt;the BASIC coordinate system.&lt;/li&gt;
&lt;li&gt;Remark 3:&lt;/li&gt;
&lt;li&gt;This method concerns TOTAL displacements, i.e., displacements&lt;/li&gt;
&lt;li&gt;with respect to the UNDEFORMED or stress-free configuration.&lt;/li&gt;
&lt;li&gt;As opposed to INITIAL displacements (those measured from initial&lt;/li&gt;
&lt;li&gt;configuration) or INCREMENTAL displacements (those measured from&lt;/li&gt;
&lt;li&gt;the previous time step).
*&lt;/li&gt;
&lt;li&gt;@param seqDisp : the displacement, including rotation.&lt;/li&gt;
&lt;li&gt;@param seqVelo : the velocity, including angular velocity.&lt;/li&gt;
&lt;li&gt;@param seqAcce : the acceleration, including angular acceleration.&lt;/li&gt;
&lt;li&gt;@param redoTimeStep : the redo flag passed between Nastran and&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;                  fluid solver for this time step
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;@return : SCASuccess if successful, otherwise, SCAError.
&lt;em&gt;/
SCAResult putWettedNodeDispVeloAcce(in wettedNodeExSeq seqDisp,
in wettedNodeExSeq seqVelo,
in wettedNodeExSeq seqAcce,
inout SCABool redoTimeStep);
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;Initialize time and time step
*&lt;/li&gt;
&lt;li&gt;@param time : the current time&lt;/li&gt;
&lt;li&gt;@param delta : the time step&lt;/li&gt;
&lt;li&gt;@param minDelta : the minimum time step&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;230 User Defined Services User’s Guide
Appendix 2: OpenFSI_Ex Interface
Main Index&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@param maxDelta : the maximum time step&lt;/li&gt;
&lt;li&gt;@param redoTimeSttep : the redo flag passed between Nastran&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;                   and fluid solver for this time step
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;@return : SCASuccess if successful, otherwise, SCAError.
&lt;em&gt;/
SCAResult initializeTimeStep(in SCAReal64 time,
inout SCAReal64 delta,
in SCAReal64 minDelta,
in SCAReal64 maxDelta,
inout SCABool redoTimeStep);
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;Finialize time
*&lt;/li&gt;
&lt;li&gt;@param time : the final time of this time step&lt;/li&gt;
&lt;li&gt;@param endSimulation : the end simulation flag passed between&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;                   Nastran and fluid solver
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;@param redoTimeStep : the redo flag passed between Nastran&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;                  and fluid solver for this time step
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;@return : SCASuccess if successful, otherwise, SCAError.
&lt;em&gt;/
SCAResult finalizeTimeStep(in SCAReal64 time,
inout SCABool endSimulation,
inout SCABool redoTimeStep);
/&lt;/em&gt;*&lt;/li&gt;
&lt;li&gt;Temminate call to solver
*&lt;/li&gt;
&lt;li&gt;@param message : the message send to solver&lt;/li&gt;
&lt;li&gt;@return : SCASuccess if successful, otherwise, SCAError.
*/
SCAResult terminate(in SCAString message);
};
}; }; }; };
#endif
Service Definition Language File
The OpenFSI_Ex service definition language file is as the following:
#ifndef TEST_OPENFSI_EX_SDL_INCLUDE
#define TEST_OPENFSI_EX_SDL_INCLUDE
#include &amp;ldquo;SCA/MDSolver/Util/OpenFSI_Ex/OpenFSI_Ex.idl&amp;rdquo;
module Test { module OpenFSI_Ex {
service OpenFSI_Ex
{
interface SCA::MDSolver::Util::OpenFSI_Ex::SCAIMDSolverOpenFSI_Ex;
};
}; };
#endif&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;231 Chapter 3: OpenFSI
Appendix 2: OpenFSI_Ex Interface
Main Index
Component Definition Language File
The OpenFSI_Ex component definition langage file is as the following:
#ifndef TEST_OPENFSI_EX_CDL_INCLUDE
#define TEST_OPENFSI_EX_CDL_INCLUDE
#include &amp;ldquo;OpenFSI_Ex.sdl&amp;rdquo;
component Test.OpenFSI_Ex
{
service OpenFSI_Ex;
};
#endif&lt;/p&gt;
&lt;p&gt;232 User Defined Services User’s Guide
References
Main Index
OpenFSI_Ex Data Flow
References
1.MSC Nastran - Quick Reference Guide
2.MSC Software Development Kit  (SDK).
3.SCA Framework User&amp;rsquo;s Guide 2010&lt;/p&gt;
&lt;p&gt;Chapter 4: OpenFSI MSC Nastran &amp;amp; SimXpert Quick Start Tutorial
User Defined Services User’s Guide
4OpenFSI MSC Nastran &amp;amp;
SimXpert Quick Start Tutorial
Launch SimXpert and Import the Structural Model     234
Define the Service for the Coupled Solution     235
Define the OpenFSI LBCs (Wetted Surfaces)     236
Define a Nonlinear Simulation     238
Launch MSC Nastran OpenFSI-MpCCI Simulation (for Fluent &amp;amp; StarCD)     243
Examine the Results Using SimXpert     244&lt;/p&gt;
&lt;p&gt;234 User Defined Services User’s Guide
Launch SimXpert and Import the Structural Model
Main Index
Launch SimXpert and Import the Structural Model&lt;/p&gt;
&lt;p&gt;235 Chapter 4: OpenFSI MSC Nastran &amp;amp; SimXpert Quick Start Tutorial
Define the Service for the Coupled Solution
Main Index
Define the Service for the Coupled Solution
Note:   The form above shows a generic name (myService.openFSI) for the OpenFSI Service name. This will be
translated to the Connect Service entry in the MSC Nastran input file along with the alias Name (8
characters or less). Check for the actual service in the SCAServiceCatalog.xml as defined by the vendor, for
example, &amp;lsquo;acuSolveService.openFSI&amp;rsquo;&lt;/p&gt;
&lt;p&gt;236 User Defined Services User’s Guide
Define the OpenFSI LBCs (Wetted Surfaces)
Main Index
Define the OpenFSI LBCs (Wetted Surfaces)&lt;/p&gt;
&lt;p&gt;237 Chapter 4: OpenFSI MSC Nastran &amp;amp; SimXpert Quick Start Tutorial
Define the OpenFSI LBCs (Wetted Surfaces)
Main Index&lt;/p&gt;
&lt;p&gt;238 User Defined Services User’s Guide
Define a Nonlinear Simulation
Main Index
Define a Nonlinear Simulation&lt;/p&gt;
&lt;p&gt;239 Chapter 4: OpenFSI MSC Nastran &amp;amp; SimXpert Quick Start Tutorial
Define a Nonlinear Simulation
Main Index&lt;/p&gt;
&lt;p&gt;240 User Defined Services User’s Guide
Define a Nonlinear Simulation
Main Index&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P13</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_013/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_013/</guid>
      <description>
        
        
        &lt;p&gt;241 Chapter 4: OpenFSI MSC Nastran &amp;amp; SimXpert Quick Start Tutorial
Define a Nonlinear Simulation
Main Index&lt;/p&gt;
&lt;p&gt;242 User Defined Services User’s Guide
Define a Nonlinear Simulation
Main Index&lt;/p&gt;
&lt;p&gt;243 Chapter 4: OpenFSI MSC Nastran &amp;amp; SimXpert Quick Start Tutorial
Launch MSC Nastran OpenFSI-MpCCI Simulation (for Fluent &amp;amp; StarCD)
Main Index
Launch MSC Nastran OpenFSI-MpCCI Simulation (for Fluent &amp;amp;
StarCD)&lt;/p&gt;
&lt;p&gt;244 User Defined Services User’s Guide
Examine the Results Using SimXpert
Main Index
Examine the Results Using SimXpert&lt;/p&gt;
&lt;p&gt;245 Chapter 4: OpenFSI MSC Nastran &amp;amp; SimXpert Quick Start Tutorial
Examine the Results Using SimXpert
Main Index&lt;/p&gt;
&lt;p&gt;246 User Defined Services User’s Guide
Examine the Results Using SimXpert
Main Index&lt;/p&gt;
&lt;p&gt;Chapter 5: OpenMDO
User Defined Services User’s Guide
5 OpenMDO
Run MSC Nastran OpenMDO Optimization      252
Creating an OpenMDO SCA service     254
Appendix     257
Reference     260&lt;/p&gt;
&lt;p&gt;248 User Defined Services User’s Guide
OpenMDO
Main Index
MSC Nastran SOL 200 is used for design optimization of an objective function based on design variables and subject to
performance constraints and side constraints. Design sensitivity analysis computes the rates of change of structural
responses with respect to changes in design parameters. These design parameters, or design variables, can be such things as
shell thicknesses, beam dimensions, hole radii, material properties and so on. The responses can be any direct response
(DRESP1) supported by SOL 200, plus any synthesized response (DRESP2) which can be a complex combination of direct
or synthesized responses. There is also the capability for the user to create his own responses (DRESP3) via an external
program that links to MSC Nastran.
The design variables, responses, constraints, and sensitivities can be submitted to an optimization algorithm which can
search for an improved design. There are many optimization algorithms that have been written over the years. In MSC
Nastran, there are two MSC proprietary general purpose optimizers: MSCADS and IPOPT . T o provide more options and
flexibility to the users, MSC has created a Simulation Component Architecture (SCA) plugin to allow users to access other
commercially available optimization codes or their own general or specific purpose optimization codes. MSC refers to this
SCA plugin capability as OpenMDO™.
The OpenMDO interface provides a convenient method to use the power of the MSC Nastran Solver, the MSC Nastran
design sensitivity calculations, and approximation technology with an alternative optimizer. This can benefit both
commercial users and researchers who may want to use or test their own optimizers. OpenMDO also provides a method
for users to plugin other commercial optimizers.
MSC has partnered with VRND (Vanderplaats Research &amp;amp; Development, Inc) who have agreed to implement the
published OpenMDO API (the Application Programming Interface). These interfaces are delivered in the form of a library
and SCA catalog entry that enables the communication between MSC Nastran and VRND&amp;rsquo;s DOT/BIGDOT .
OpenMDO is based on the Simulation Component Architecture (SCA) framework ( Reference 1 ). It allows MSC Nastran
SOL200 (Optimization Solution) to communicate with an external optimizer code to send the objective, constraint
functions, and their gradients to the optimizer and get a new design from the optimizer. MSC Nastran optimization loop
with SCA OpenMDO component is shown in Figure 5-1.
MSC Nastran loads the SCA external optimizer component in DOPR1 module (pre-optimization module) and unloads
the SCA external optimizer component in DOM12 module (pos-optimization module.
In DOM9 (Design Optimization Module), the external optimizer is used to solve a SOL200 approximation problem. MSC
Nastran employs a number of techniques, collectively referred to as Approximation Concepts , to make design optimization
possible for large finite element models. Design variable linking, reduced basis vectors, constraint screening, load case
deletion, and the approximate model are discussed in Reference 2 . These approximation concepts all play a role in reducing
the cost of the design task. MSC / MSC Nastran uses formal approximations (such as Taylor Series expansion) to avoid the
high cost associated with repeated finite element analyses during design optimization. As shown in Figure 5-2, the optimizer
interacts with the approximate model when it requires information. Given a set of design variables, the optimizer needs
information on the function values (the value of the objective and the values of the retained constraints) and the gradient
values (gradient of the objective with respect to the design variables and the gradient of the active constraints with respect
to the design variables).
First, SOL200 calls OpenMDO memory estimate function to allocate memory and initializes optimizer control
parameters, arrays, and work arrays. SOL200 provides some default values to OpenMDO optimizer control parameters that
are discussed in Section II. Then, SOL200 calls the external optimizer and the external optimizer returns information&lt;/p&gt;
&lt;p&gt;249 Chapter 5: OpenMDO
Main Index
parameter INFO, error flag ERROR=IPRM(18), and NGT=IPRM(20) (number of critical constraints) to DOM9 to
perform function or gradient evaluations or terminate shown in Figure 5-3.
Figure 5-1  Flow Chart of MSC Nastran with External Optimizers&lt;/p&gt;
&lt;p&gt;250 User Defined Services User’s Guide
OpenMDO
Main Index
Figure 5-2  Optimizer Role in MSC Nastran Optimization
Since DOT/BIGDOT is a major optimizer and widely used in Auto and Aerospace industry, MSC Nastran OpenMDO
uses the ALLDOT (DOT/BIGDOT interface) calling statement as our OpenMDO API with minor modification.&lt;/p&gt;
&lt;p&gt;251 Chapter 5: OpenMDO
Main Index
Figure 5-3  The Interaction Between SOL200 DOM9 and External Optimizers
To run an OpenMDO optimization the following software components are required:
MSC Nastran 2011 (or later).
An OpenMDO SCA component with an external optimizer
OpenMDO SCA components can be of two types:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Prebuilt components used with certain commercial optimizers.&lt;/li&gt;
&lt;li&gt;User defined SCA components built with the OpenMDO software development kit (SDK).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;252 User Defined Services User’s Guide
OpenMDO
Main Index
Run MSC Nastran OpenMDO Optimization
OpenMDO Input Deck
For a user to run an optimization SOL200 job by using the OpenMDO interface, a SCA service must be defined in the file
management section in the Nastran input file by a CONNECT Service statement. The connection between the SCA
service and SOL200 is done by defining an optimizer code OPTCOD on the DOPTPRM bulk data entry which is tagged
with the SCA service identifier in the CONNECT Service statement. For example as below, input file Connect Service
statement references an external OpenMDO service called &amp;lsquo;ExternalOptimizer.OpenMDO&amp;rsquo;. The word &amp;ldquo;ALLDOT&amp;rdquo;
(Optimizer code in DOPTPRM and service identifier in CONNECT Service statement) connects SOL200 with
&amp;lsquo;ExternalOptimizer.OpenMDO&amp;rsquo; ser.
Running MSC Nastran
T o run an MSC Nastran OpenMDO job, a SCA service catalog, which contains references to available SCA services
components, and an associated library path, pointing to the interface functions library, must be specified. A resource
directory may also be specified. This is done by setting environment variables as follows:
setenv SCA_SERVICE_CATALOG $SCAPATH/Apps/res/SCAServiceCatalog.xml
setenv SCA_LIBRARY_PATH $SCAPATH/Apps/LX8664/lib/
setenv SCA_RESOURCE_DIR $SCAPATH/Apps/res/
if a csh shell is used. Here $SCAPATH  refers to the path where the SCA service components are installed on the system. For
a Bourne shell, like ksh or bash, the environment variables are defined as:
export SCA_SERVICE CATALOG=$SCAPATH/Apps/res/SCAServiceCatalog.xml
export SCA_LIBRARY PATH=$SCAPATH/Apps/LX8664/lib/
export SCA_RESOURCE DIR=$SCAPATH/Apps/res/
T o execute Nastran with the input deck model.dat , simply enter the following line:
nastran model.datFile management CONNECT SERVICE ALLDOT ExternalOptimizer.OpenMDO
Executive controlSOL200
END
Case ControlDESOBJ = 10
DESSUB=20
SUBCASE 1
ANALYSIS = STATICS
.
Bulk dataBEGIN BULK
.
DOPTPRM    OPTCOD   ALLDOT    METHOD    1
.&lt;/p&gt;
&lt;p&gt;253 Chapter 5: OpenMDO
Run MSC Nastran OpenMDO Optimization
Main Index
Example:  ntermediate Complexity Wing ( ICWSE01.dat )
This intermediate complexity wing shown in Figure 5-4 was solved using MSCADS, IPOPT  in MD Nastran 2010 Release
Guide. In this Section, ALLDOT (DOT and BIGDOT) is used as an external optimizer to solve this problem.
Figure 5-4  Intermediate Complexity Wing Model
This composite structure is modeled with 62 CQUAD4  elements, 55 CSHEAR  elements, 39 CROD  elements, and 39 CONM2&lt;br&gt;
elements. T wo static load cases are imposed along with a normal modes subcase. The objective is to minimize the weight.
There are 153 sizing design variables and 414 stress and failure index constraints and a lower and upper bounds on the first
fundamental frequency. T o use ALLDOT , a parameter OPTCOD=ALLDOT  is added on the Bulk Data Entry DOPTPRM :
CONNECT SERVICE ALLDOT ALLDOT.OpenMDO
&amp;hellip;
&amp;hellip;
&amp;hellip;
DOPTPRM APRCOD   2  DESMAX   30   DELP  0.50  DPMIN     0.001
delx   0.49 p1      1    p2  12    OPTCOD    ALLDOT
METHOD  1
METHOD=1 is the DOT&amp;rsquo;s MMFD method, METHOD=4 is the BIGDOT algorithm.
Table 5-1 shows the DOT and BIGDOT results for this example and all results are comparable.
Table 5-1  Intermediate Complexity Wing Optimization Results
Initial ValueOptimum
DOT (MMFD)Optimum
BIGDOTOptimum
IpoptOptimum
MSCADS (MMFD)
Objective 1.6892+2 1.9893+2 1.9570+2 1.9282+2 1.9624+2
Max Con 5.8425+2 1.4267-03 1.5355-04 5.5370-03 2.7015-03&lt;/p&gt;
&lt;h1&gt;Cycles 14 20 20 14&lt;/h1&gt;&lt;p&gt;254 User Defined Services User’s Guide
OpenMDO
Main Index
Creating an OpenMDO SCA service
Build tools
T o create a user defined OpenMDOSCA service, the SDK provided with the MSC Nastran distribution is used. In
addition, a C/C++ compiler (and a Fortran compiler if external optimizer is written in Fortran) is needed to compile the
source code. The SCA services are built using the scons tools included in the SDK distribution. It is recommended that
users read Chapter 1 User Defined Subroutines to understand the following :
Creating the desired implementation for the User Defined Services in the form of dynamic-link libraries.
Defining the location of the user defined service, service catalogue, and service resource directory.
The quick start guide (Appendix A) also describes how to compile and run the user defined services examples delivered with
MSC Nastran by utilizing the MSC Software Development Kit (SDK) on Windows. The implementation examples consist
of ready-to-compile source and one or more models that utilize the user service. The implementation examples include
OpenMDO.
After installing the SDK, make sure that the SDK Tools directory is in your path:
PATH[install_path]\Tools
Build an Example myOpenMDO
T o build the implementation example myOpenMDO delivered with MSC Nastran, the following files are needed in the
source directory:
myOpenMDO.cdl
myOpenMDO.cpp
myOpenMDO.h
myOpenMDO.sdl
SConscript
All these files are already created as a simple OpenMDO example with a dummy optimizer located in
$NASTPATH/&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/OpenMDO .
Here $NASTPATH  is the path to the MSC Nastran installation. An interface definition file OpenMDO.idl  is located in
$NASTPATH/&amp;lt;prod_ver&amp;gt;/nast/sdk/idl/SCA/MDSolver/Util/OpenMDO . There is a dummy optimizer Fortran
source code alldotd.F  (alldots.F ) and dotstrd.F  (dotstrs.F ) in directory&lt;br&gt;
$NASTPATH/&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/OpenMDO/ double or single for a double or single
precision OpenMDO build.
Here is the procedure to build the OpenMDO SCA components:
1.Change directory to the source code root directory: $NASTPATH/&amp;lt;prod_ver&amp;gt;/nast/services
2.Build the SCA component from the source code root directory by simply entering scons  (use a full path
$SDKPATH/Tools/ scons  if not found)&lt;/p&gt;
&lt;p&gt;255 Chapter 5: OpenMDO
Creating an OpenMDO SCA service
Main Index
If the SConopts.user  file does not exist in the home directory or if the paths are not defined in that file, the
SCA_OBJECT  and  APPS_LOCAL  paths must be specified when running scons (see Build Environment and Building the
Service in Chapter 1).  See the FAQ questions in the Quick Start  for advanced usage of the scons command to utilize, for
example, alternate compilers or non-standard compiler installation paths.
The scons  command should create the OpenMDO SCA component files, including the service catalog file
SCAServiceCatalog.xml  in the Apps/res directory and the library  libopenMDO.so  in the Apps/LX8664/lib&lt;br&gt;
for a Linux x8664 system. The library name and directory name will depend on the platform where the SCA component
is built. The location must be consistent with the path defined by the environment variables SCA_SERVICE_CATALOG,
SCA_LIBRARY_PATH  and SCA_RESOURCE _DIR  when executing MSC Nastran.
To run the example job dsgopenmdo.dat, change the directory to the OpenMDO model directory $NASTPATH
/&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/OpenMDO/model  and set  three environment variables
SCA_SERVICE_CATALOG, SCA_LIBRARY_PATH  and SCA_RESOURCE_DIR   (see Run MSC Nastran OpenMDO
Optimization in this Chapter 5). Then enter
nastran  dsgopenmdo.dat (use a full path if the command nastran not found)
Once the run is completed, the user can find the following print in either dsgopenmdo.log  or dsgopenmdo.f06&lt;br&gt;
(depending  on the platform):&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;THIS IS A DUMMY OPTIMIZER&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Since this is a dummy optimizer example, the optimization job stops at the first design cycle with the final objective=
4.828427E+00 as the initial design in dsgopenmdo.f06 .
Note that if the user wants to support his own optimizer written in Fortran, the user can use this myOpenMDO
implementation example by adding the optimizer source code to the directory ~/OpenMDO/double  (for double precision
code) and ~/OpenMDO/single  (for single precision).
To include a static library, add the following line to the ~/OpenMDO/SConscript  file:
env.AddLinkLibrary(&amp;quot;$LIBPATH/lib/libMyLib.a&amp;quot;)
where $LIBPATH  is the path to the install location of the library. To include a dynamic library, add the following line to
the ~/OPenMDO/SConscript  file:
env.AddLinkSharedLibrary(&amp;quot;$LIBPATH/lib/libMyLib.so&amp;quot;)
Building a New OpenMDO Service from Scratch
The OpenMDO.idl and SConscript files that are provided with the SDK, are normally used to make all OpenMDO
services, so that only the files with root name myOpenMDO need to be recreated (or created with a different name) if a
new service is created from scratch. To make a new OpenMDO component from scratch, use the following procedure:
1.Create a new service definition file myOpenMDO.sdl&lt;/p&gt;
&lt;p&gt;256 User Defined Services User’s Guide
OpenMDO
Main Index
A different name can be used if desired (but the extension should be .sdl). The document [ Reference 3 ] provides a
tutorial on how an interface definition (.idl) file is created from scratch, along with the creation of the service
definition (.sdl) and component definition (.cdl) files. Here, the interface definition file OpenMDO.idl  is already
provided and the service and component definition files provide the interface for only one component, so the
content in those files is straightforward (see Service Definition Language file and Component Definition Language
File in the document [ Reference 3 ]). An overview of the interface definition and implementation of the OpenMDO
methods is given the Appendix of this chapter.
2.Create the skeleton code files myOpenMDO.cpp and myOpenMDO.h.
As mentioned above, the interface for the OpenMDO SCA component is defined in the OpenMDO.idl file and
provides the Application Programming Interface (API) for implementing the external optimizer code connecting to
the MSC Nastran SOL200.
The interface has the following two functions (methods)
Estimate memory (storage calculations) for working arrays
Run the external optimizer to solve the optimization problem.
T o generate the skeleton code where the service methods are implemented, enter:
genskeleton myOpenMDO.sdl
This command will create the skeleton code files myOpenMDO.cpp  and myOpenMDO.h , based on the OpenMDO.idl file
within the name space provided in myOpenMDO.sdl . The header file myOpenMDO.h  contains the declarations for the
OpenMDO service &amp;lsquo;myOpenMDO&amp;rsquo;. The service implementation file myOpenMDO.cpp  contains a constructor and a
destructor for the service object, along with prototypes for the OpenMDO service methods that need to be populated with
source code.
3.Implement the source code in the myOpenMDO.cpp  and myOpenMDO.h  skeleton files.
Major code work is required for users to link the myOpenMDO.cpp  with the external optimizer (see MD 2011.1
Release Guide or MSC Nastran Design Sensitivity and Optimization User&amp;rsquo;s Guide  for the detail).
4.Create a new component definition file myOpenMDO.cdl&lt;br&gt;
5.Build the SCA component from the source code root directory using scons.
Alternatively, it is possible to only build the OpenMDO SCA component as follows:
1.Locate the OpenMDO.idl  file and copy to the source directory.
2.Create a new myOpenMDO.sdl  file.
3.Use the executable genskeleton to create skeletons for myOpenMDO.cpp  and myOpenMDO.h .
4.Implement the source code in the myOpenMDO.cpp  and myOpenMDO.h  skeleton files.
5.Create a new myOpenMDO.cdl  file.
6.Build the SCA component from the OpenMDO source code directory by entering scons - -qb4.
See Run Time Errors and Debugging  for possible run time errors and debugging options.&lt;/p&gt;
&lt;p&gt;257 Chapter 5: OpenMDO
Appendix
Main Index
Appendix
Interface Definition Language file
The IDL file used to build a SCA service connecting to the OpenMDO interface has the following form
#ifndef SCA_MDSOLVER_UTIL_OPENMDO_IDL_INCLUDED
#define SCA_MDSOLVER_UTIL_OPENMDO_IDL_INCLUDED
#include &amp;ldquo;SCA/Service.idl&amp;rdquo;
module SCA { module MDSolver { module Util { module OpenMDO {
typedef SCAInt32                SCAInt32StaticArray[];
typedef SCAInt64                SCAInt64StaticArray[];
typedef SCAReal64               SCAReal64StaticArray[];
interface SCAIMDSolverOpenMDO : SCAIService
{
///  OpenMDO.ldl is used to define an API for mathematical programming
problems
///   in MSC Nastran SOL200.
///
///  A general formulation of structural optimization problems can be stated
as follows
///   &lt;br&gt;
///        minimize  f(X)
///         s.t.     Gj(X) &amp;lt;= 0.0                j = 1, &amp;hellip;, m
///                  xl(i) &amp;lt;= x(i) &amp;lt;= xu(i),     i = 1, ,,,, n
///
///  where f(X) is the objective function of design variables X, Gj(X) is the
constraint,
///  and m is the number of inequality constraints. The design variable X has
lower bound XL
///  and upper bound XU. n is number of design variables.
///  Equality constraints are seldom true for engineering design. MSC Nastran
SOL200 does not
///  directly deal with equality constraints. Instead, if such equality
constraints are needed,
///  it is only necessary to add additional inequality constraints of the
form
///&lt;br&gt;
///                  Gk(X) &amp;gt;= 0.0
///
///  In other words, two equal and opposite inequality constraints will force
the function to
///  become an equality. Therefore, OpenMDO will consider only inequality
constraints.
///
///  MSC Nastran first calls exteranl optimizer (EstimateMemory) to estimate
required memenory,&lt;/p&gt;
&lt;p&gt;258 User Defined Services User’s Guide
OpenMDO
Main Index
///  initialize parameter/array and allocate memory. Then, calls optimizer
(RunOptimizer) to
///  solve the problem.
///&lt;br&gt;
///   Here, OpenMDO suppors double precision
EstimateMemory_32/RunOptimizer_32,
///   and single precision (PTR64) EstimateMemory_64/RunOptimizer_64
///&lt;/p&gt;
&lt;p&gt;SCAResult RunOptimizer_32
(
inout      SCAInt32                Info,
in         SCAInt32                OptimizationMethod,
in         SCAInt32                PrintControl,
in         SCAInt32                NumberOfDesignVariable,
in         SCAInt32                NumberOfConstraints,
inout      SCAReal64StaticArray    DesignVariable,
in         SCAReal64StaticArray    LowerBoundDesignVariable,
in         SCAReal64StaticArray    UpperBoundDesignVariable,
inout      SCAReal64               Objective,
in         SCAInt32                MinimumOrMaximum,
inout      SCAReal64StaticArray    Constraint,
inout      SCAReal64StaticArray    RealOptControlPar,
inout      SCAInt32StaticArray     IntegerOptControlPar,
inout      SCAReal64StaticArray    RealWorkArrayWK,
in         SCAInt32                SizeofWK,
inout      SCAInt32StaticArray     IntegerWorkArrayIWK,
in         SCAInt32                SizeofIWK,
inout      SCAInt32StaticArray     IntegerOptionArrayIOA,
in         SCAInt32                SizeofIOA,
inout      SCAReal64StaticArray    RealOptionArrayROA,
in         SCAInt32                SizeofROA);
SCAResult RunOptimizer_64
(
inout      SCAInt64                Info,
in         SCAInt64                OptimizationMethod,
in         SCAInt64                PrintControl,
in         SCAInt64                NumberOfDesignVariable,
in         SCAInt64                NumberOfConstraints,
inout      SCAReal64StaticArray    DesignVariable,
in         SCAReal64StaticArray    LowerBoundDesignVariable,
in         SCAReal64StaticArray    UpperBoundDesignVariable,
inout      SCAReal64               Objective,
in         SCAInt64                MinimumOrMaximum,
inout      SCAReal64StaticArray    Constraint,
inout      SCAReal64StaticArray    RealOptControlPar,
inout      SCAInt64StaticArray     IntegerOptControlPar,
inout      SCAReal64StaticArray    RealWorkArrayWK,
in         SCAInt64                SizeofWK,
inout      SCAInt64StaticArray     IntegerWorkArrayIWK,&lt;/p&gt;
&lt;p&gt;259 Chapter 5: OpenMDO
Appendix
Main Index
in         SCAInt64                SizeofIWK,
inout      SCAInt64StaticArray     IntegerOptionArrayIOA,
in         SCAInt64                SizeofIOA,
inout      SCAReal64StaticArray    RealOptionArrayROA,
in         SCAInt64                SizeofROA);
///
/// Calculate Computer Memeory Requirements
///
SCAResult EstimateMemory_32
(
in         SCAInt32                  NumberofDesignVariable,
in         SCAInt32                  NumberofConstraint,
in         SCAInt32                  OptimizationMethod,
out        SCAInt32                  MinimumDimWk,
out        SCAInt32                  DesiredDimWk,
out        SCAInt32                  MaximumDimWk,
out        SCAInt32                  DesiredDimIWk,
out        SCAInt32                  ExtraSpace,
inout      SCAInt32               NumberOfCritialConstraint,
in         SCAReal64StaticArray    LowerBoundDesignVariable,
in         SCAReal64StaticArray    UpperBoundDesignVariable,
inout      SCAInt32                  SizeofIOA,
inout      SCAInt32                  SizeofROA,
in         SCAInt32                  MaximumInteger,
out        SCAInt32                  MemoryErrorFlag);
SCAResult EstimateMemory_64
(
in         SCAInt64                  NumberofDesignVariable,
in         SCAInt64                  NumberofConstraint,
in         SCAInt64                  OptimizationMethod,
out        SCAInt64                  MinimumDimWk,
out        SCAInt64                  DesiredDimWk,
out        SCAInt64                  MaximumDimWk,
out        SCAInt64                  DesiredDimIWk,
out        SCAInt64                  ExtraSpace,
inout      SCAInt64               NumberOfCritialConstraint,
in         SCAReal64StaticArray    LowerBoundDesignVariable,
in         SCAReal64StaticArray    UpperBoundDesignVariable,
inout      SCAInt64                  SizeofIOA,
inout      SCAInt64                  SizeofROA,
in         SCAInt64                  MaximumInteger,
out        SCAInt64                  MemoryErrorFlag);
};
}; }; }; };&lt;/p&gt;
&lt;p&gt;260 User Defined Services User’s Guide
OpenMDO
Main Index
#endif
Reference
1.MSC Software Development Kit 2021 -  User&amp;rsquo;s Guide.
2.MSC Nastran Design Sensitivity and Optimization User&amp;rsquo;s Guide .
3.MSC Nastran Quick Reference Guide.
4.MSC Nastran Release Guide .
5.DOT User&amp;rsquo;s Guide, Version 5.X, Vanderplaats Research &amp;amp; Development, Inc., 2001.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P14</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_014/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_014/</guid>
      <description>
        
        
        &lt;p&gt;Main Index
Appendix A: Quick Start
User Defined Services User’s Guide
A Quick Start
MSC SDK Delivery Contents      262
Services Implementation Examples      262
Supported Operating Systems and Compilers      263
Compiling User Defined Services      264
Defining the Path to User Defined Service      265
Pointing to a User Defined Services from MSC Nastran      266
Running MSC Nastran with a User Defined Service      266
SDK User Services on Other Operating Systems      267
Errors Messages and Diagnostics      268
FAQ     271&lt;/p&gt;
&lt;p&gt;262 User Defined Services User’s Guide
MSC SDK Delivery Contents
Main Index
This quick start guide describes how to compile and run the user defined services examples delivered with MSC Nastran
by utilizing the MSC Software Development Kit (SDK). The implementations examples consist of ready-to-compile source
to build the services. The examples include one or more models that utilize the user service. The services must be built and
appropriate environment variable set to locate them before attempting to run the models.
Once you are able to build and run the examples in the MSC Nastran delivery, please refer to the related documents at the
end for more information on how to create your own user defined services.
MSC SDK Delivery Contents
The MSC Software Development Kit (SDK) is a downloadable product that provides the SCA tools required to build
services.
[install_path]\SDK&amp;lt;version&amp;gt;&lt;br&gt;
| &amp;ndash; Tools
| &amp;ndash; SCAKernel
| &amp;ndash; Doc
After installing the SDK, make sure that the T ools directory is in your path:
PATH[install_ path]\SDK&amp;lt;version&amp;gt;\Tools
Services Implementation Examples
Implementation examples are delivered as part of MSC Nastran. These services need to be built using the tools in the SDK
before they can be referenced from the MSC Nastran input files. The delivery structure consists of:
[install_path]\MSC_Nastran&amp;lt;version&amp;gt;\msc&lt;!-- raw HTML omitted --&gt;\nast
| &amp;ndash; services
!    | &amp;ndash; Implementations
!         | &amp;ndash; Contact
!         | &amp;ndash; Elements
!         | &amp;ndash; Materials
!              | &amp;ndash; archives
!              | &amp;ndash; include
!              | &amp;ndash; Models
!              | &amp;ndash; src
!         | &amp;ndash; OpenFSI
!              | &amp;ndash; Model
!         | &amp;ndash; OpenMDO
!              | &amp;ndash; Model
!         | &amp;ndash; &lt;!-- raw HTML omitted --&gt;…
!    | &amp;ndash; SConstruct
!    | &amp;ndash; SConopts
!    | &amp;ndash; SConscript&lt;/p&gt;
&lt;p&gt;263 Appendix A: Quick Start
Supported Operating Systems and Compilers
Main Index
Supported Operating Systems and Compilers
User defined services must be built only on supported operating systems and compilers. Although MSC Nastran may run
on unsupported platforms, generation of services typically requires strict adherence to the supported platforms and
compilers.
Below is the list of supported operating systems and compiler versions for the MSC Nastran 2024.1  release:
Table 1-1  Supported Operating Systems and Compilers
Certified and Supported Operating Systems can be found at:
Platform Support
This release uses the Cuda 12.2. This change means K40 GPUs are no longer supported. 
The Fortran compiler may not be the current version available on the vendor download site. See the FAQ section below for
tips on how to download prior compiler versions.VendorFORTRAN
Version C Version Default MPI
Linux (64-bit) Intel oneAPI 2023.1 Intel oneAPI 2023.1 Intel MPI 2021.10
Microsoft (64-bit)  Intel oneAPI 2023.1 MSVC 14.35
Visual Studio 2022 17.5
Microsoft .NET 6Intel MPI 2021.10&lt;/p&gt;
&lt;p&gt;264 User Defined Services User’s Guide
Compiling User Defined Services
Main Index
Compiling User Defined Services
You can compile all the services in the services examples folder at one time or specify selected targets. The steps below shown
how to compile the services with ‘scons’:
1.Open a command window
Start   Run…  Open: cmd
2.Copy the files from the directory: \msc&lt;!-- raw HTML omitted --&gt;\nast\services  under the MSC Nastran installation
3.Check to make sure ‘ scons’  points to the Tools  directory
4.Issue the ‘ scons’  command to compile all the examples: &amp;gt;  scons (use full path if not found)
5.If there are existing services, you should clear them out with: &amp;gt; scons - c
6.To build only specific services, provide the targets as arguments, e.g., &amp;gt; scons [ targets]
An illustration of the steps is shown below.
The output from a successful compilation is illustrated below.
scons: Reading SConscript files &amp;hellip;
Processing Source tree option file C:\Program
Files\MSC.Software\MSC_Nastran\2024.1\msc20241\nast\services\SConopts
Processing User option file U:/SConopts.user
Using version 10.0 of Microsoft C++
Using version 12.0.4.196 of Intel Fortran
Using version v4.0.30319 of Microsoft .NET Framework
Build Type   = OPT on WIN8664
Source       = C:\Program Files\MSC.Software\MSC_Nastran\20241\msc20241\nast\services
Object       = C:\Program
Files\MSC.Software\MSC_Nastran\20241\msc20241\nast\services\WIN8664_SERVICES_OPT
Apps Local   = C:\Program Files\MSC.Software\MSC_Nastran\20241\msc20241\nast\services\Apps
Apps1 System = C:\Program Files\MSC.Software\SDK\2023\SCAKernel
Apps2 System = C:\Program Files\MSC.Software\MSC_Nastran\20241\msc20241\sdk
Tools System = C:\Program Files\MSC.Software\SDK\2023\Tools  version(168870)
Tools Binary = WINNT&lt;/p&gt;
&lt;p&gt;265 Appendix A: Quick Start
Defining the Path to User Defined Service
Main Index
40 Source directories processed
scons: done reading SConscript files.
scons: Building targets &amp;hellip;
&amp;rsquo;&amp;rsquo;&amp;rsquo;
(deleted for clarity)
&amp;rsquo;&amp;rsquo;&amp;rsquo;
scons: done building targets.
See the FAQ questions below for advance usage of the scons command to utilize, for example, alternate compilers or
nonstandard compiler installation paths.
Defining the Path to User Defined Service
A successful compilation should create an Apps folder with the following structure.
[install_path]\MSC_Nastran&amp;lt;version&amp;gt;\msc&lt;!-- raw HTML omitted --&gt;\nast
| &amp;ndash; services
|    | &amp;ndash; Apps
!         | &amp;ndash; res
!              &amp;ndash; SCAServiceCatalog.xml
!         | &amp;ndash; WINNT
!              | &amp;ndash; lib
!                &amp;ndash; MySrv1.dll
!                &amp;ndash; MySrv2.dll
!               | &amp;ndash; SCA\MDSolver\Obj\Uds
!                &amp;ndash; Materials.dll
!                &amp;ndash; Contact.dll
!               | &amp;ndash; Test
!                &amp;ndash; OpenFSI.dll
The libraries ( *.dll  or .so) that appear under lib and its subdirectories represent the service modules created from the scons
build. The SCAServiceCatalog.xml  contains a catalog of all the services created by the build session. Note that the libraries
may appear directly under / lib or under various directory levels below / lib. For purposes of pointing to them, the
environment variables should only point to / lib.
In order to use the above services, three environment variables have to be set:
SCA_LIBRARY_PATH    - points to location of the user service libraries; e.g.,
[install_path].&amp;hellip;\nast\services\Apps\WINNT\lib
SCA_SERVICE_CATALOG    - points to location of the SCA service catalog; e.g.,
[install_path].&amp;hellip;\nast\services\Apps\res\SCAServiceCatalog.xml
SCA_RESOURCE_DIR    - points to location of SCA resource directory; e.g.,
[install_path].&amp;hellip;\nast\services\Apps\res
Multiple paths can be listed for the environment variables (separated by a “;” on Windows) and will be searched in the order
they appear.&lt;/p&gt;
&lt;p&gt;266 User Defined Services User’s Guide
Pointing to a User Defined Services from MSC Nastran
Main Index
Pointing to a User Defined Services from MSC Nastran
Each example implementation in the MSC Nastran delivery contains one or more MSC Nastran models that utilize the
service. The service is referenced through the CONNECT SERVICE  entry in the MSC Nastran input file. The available
services are cataloged in the SCAServiceCatalog.xml  file.
A sample of the SCAServiceCatalog.xml  created by the above build session is illustrated below.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;267 Appendix A: Quick Start
SDK User Services on Other Operating Systems
Main Index
Information on the SCA service success or failure of the SCA service connection can be found in the MSC Nastran .f06
and.log files. See the following for various errors and diagnosis.
SDK User Services on Other Operating Systems
There are a few differences in the above procedure for Windows64 and Linux.
1.On Windows 64-bit, the libraries will appear under WIN8664 instead of WINNT. Accordingly, the environment
variable pointing to the library should be:
SCA_LIBRARY_PATH  [install_path]...\nast\services\Apps\WIN8664\lib
2.On Linux, the libraries built will appear under LINUX or Unix OS label; e.g.:
SCA_LIBRARY_PATH  [install_path]...\nast\services\Apps\LX8664\lib&lt;/p&gt;
&lt;p&gt;268 User Defined Services User’s Guide
Errors Messages and Diagnostics
Main Index
Errors Messages and Diagnostics
Table 1-2 shows some typical causes for run time errors.
Table 1-2  Run time errors
Error Message Possible Cause and Resolution
MSC Nastran F06 file error message:
*** USER FATAL MESSAGE 7831 (SCA Service Loader)
SCA ‘ServiceName’ service initialization failed.1.Check that the service name is not misspelled in the
MSC Nastran input file Connect Service entry.
a.Service name is case sensitive.
b.Make sure you only have a single space as separator
in the Connect Service entry; e.g.,
CONNECT SERVICE scafsi ’myOpenFSI’
2. Check that the SCA_LIBRARY_PATH points to the
service library /lib directory.
a.Note that if the library is specified to be located in a
subdirectory to /lib , say /lib/Test , (it will say
library=&amp;ldquo;Test/OpenFSI&amp;rdquo;  in the
SCAServiceCatalog.xml  file), the specified path
should still point to /lib.
3.Check that SCA SERVICE CATALOG points to the
applicable SCA Service Catalog.&lt;/p&gt;
&lt;p&gt;269 Appendix A: Quick Start
Errors Messages and Diagnostics
Main Index
Table 1-3 shows some typical Scons build errors.MSC Nastran F06 file error message:
*** SYSTEM FATAL MESSAGE 305 (IFPDRV)
IFP MODULE CANNOT OPEN GINO FILE 0
USER FATAL MESSAGE 9002 (IFPS)Input file entries require IFPSTAR. IFPSTAR is the default
with the current version.
1.Remove NASTRAN IFPSTAR=no in the input file.
2.Remove IFPSTAR=no on the Nastran command line
or in the rcfile
Run time crash:
Analysis.exe - Entry Point Not FoundThe service was created with a kernel that is not compatible
with this MSC Nastran version.
a.If you have the source, rebuild the service with the
MSC SDK corresponding to the MSC Nastran
release
b.Obtain a compatible version of the service from the
vendor .
MSC Nastran runs on an unsupported OS (e.g.,
Linux-XYZ) without SCA service but issues this error
when running with a service.
MSC Nastran F06 file error message:
*** USER FATAL MESSAGE 116 (QueryAccess)SCA services must be built only on the supported operating
systems listed in Table 1.
1.Although MSC Nastran may run on unsupported
platforms, generation of services typically requires strict
adherence to the supported platforms and compilers.
A service works fine on a Windows machine where the
service was built, but will not run on a different
windows machine.Remove security patch KB971090 under Add or Remove
Programs and rebuild the service.
Table 1-3  Scons Build Errors
Error Message Possible Cause and Resolution
Message during Scons compilation:
Processing Source tree option file
C:\MSC.Software\MSC_SDK\MDr4Alpha2\Examples\SC
onopts
Warning:  MSVS verions 8.0 not found - using version 9.0 instead
IndexError: list index out of range:Scons is using Version 9.0 of Microsoft compiler. The
official supported compiler version is version 8.0 that
corresponds to MSVS 2005. We do not support MSVS
2007 or beyond. Table 1-2  Run time errors  (continued)
Error Message Possible Cause and Resolution&lt;/p&gt;
&lt;p&gt;270 User Defined Services User’s Guide
Errors Messages and Diagnostics
Main Index
Situation
User set the compiler settings to:
export C=/usr/bin/gcc
export CXX=usr/bin/gcc
export CCOMPILER=gcc
The error receive is the following:
Warning: Intel C++ compiler version 10.1.017 not found -
using 0 instead
Warning: Intel Fortran compiler version 10.1.017 not found&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using 0 instead
Error: Could not locate the Intel C++ compiler installationGCC compilers are not supported. See Table 1-1 for
supported compilers.
Installed &amp;ldquo;Intel Visual Fortran Compiler Professional Edition
for Windows&amp;rdquo;.   The intel download site only has 11.x.xxx
Warning: Intel Fortran compiler version 10.1.024 not found - using 0
instead
Using version 8.0 of Microsoft C++
KeyError: &amp;lsquo;SHFORTRANCOM&amp;rsquo;:SCA services are particular about the compiler version.  It
does not support Intel 11.x.xxx.
You can download prior compiler versions. See
instructions on:
&lt;a href=&#34;http://software.intel.com/en-us/articles/older-version-product/Table&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://software.intel.com/en-us/articles/older-version-product/Table&lt;/a&gt; 1-3  Scons Build Errors  (continued)
Error Message Possible Cause and Resolution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;271 Appendix A: Quick Start
FAQ
Main Index
FAQ
1.Can I use a different version of Intel compiler, other than the default version?
You can use the following construction variables:
INTEL_CXX_VERSION
INTEL_FORTRAN_VERSION
2.Intel doesn&amp;rsquo;t sell 10.1 anymore. What should I do?
If you have a valid license for current compiler version (11.1.xxx), you can login to Intel support web site and
download the older compiler versions (10.1.017). Note that your existing license should work for the older
compiler.  Instructions on how to download prior versions can be found at:
&lt;a href=&#34;http://software.intel.com/en-us/articles/older-version-product/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://software.intel.com/en-us/articles/older-version-product/&lt;/a&gt;
3.How do I set the path to compiler locations, if they are not installed at the default locations?
You can use a pair of construction variables to point to the path that your compilers are installed. These are:
INTEL_CXX_ROOT and INTEL_FORTRAN_ROOT. Note that “PATH_TO_XXX_COMPILER” should
point to the &lt;em&gt;parent&lt;/em&gt; directory of the bin directory for that particular compiler’s architecture and version. For
example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;.
| &lt;code&gt;-- C++ | &lt;/code&gt;&amp;ndash; 10.1.022
| |&amp;ndash; Compiler
| |&amp;ndash; Docs
| |&amp;ndash; IA32 &amp;lt;- Variable INTEL_CXX_ROOT should point to here.
| | |&amp;ndash; Bin
| | | |&amp;ndash; 1033
4.Where do I find related documents on building my own services?
More details on building user services and examples of user defined applications can be found in the following
documents:
•MSC Software Development Kit (SDK) .
•MSC Nastran 2022.2  – User Defined Services .
•MSC Nastran 2022.2  – Demonstration Problems Manual .Note:   For the MSC Nastran 2010 version release, we do not support Intel compiler version 11.XX.YYY&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;272 User Defined Services User’s Guide
FAQ
Main Index&lt;/p&gt;
&lt;p&gt;Main Index
Appendix B: Compatibility Matrix
User Defined Services User’s Guide
B Compatibility Matrix
Product Compatibility Matrix     274&lt;/p&gt;
&lt;p&gt;274 User Defined Services User’s Guide
Product Compatibility Matrix
Main Index
Product Compatibility Matrix
This table shows what version of the SDK is compatible with which version of MSC Nastran or SimManager.
SDK MSC Nastran SimManager
2019 2019 No longer uses SDK
2018 2018 No longer uses SDK
2017 2017 No longer uses SDK
2016 2016 No longer uses SDK
2014 2014 No longer uses SDK
2013 2013
2012 2012 2012
2010.1.32011
2010.1.3
2010X
2010.1.2 2010 2010
2010 X 2010&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P2</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_002/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_002/</guid>
      <description>
        
        
        &lt;p&gt;21 CHAPTER 1
Main Index
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Elements/src/Nlrsfd/Nlrsfd.cpp
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Elements/src/Nlrsfd/Nlrsfda.cpp
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Elements/src/uselem/uselem.cpp
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Materials/src/Materials.cpp
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/GeneralInfo/GeneralInfo.cp p
FORTRAN implementations
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Contact/src/motion/ext_motion.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Contact/src/sepfor/ext_sepfor.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Contact/src/sepstr/ext_sepstr.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Contact/src/ubsqueal/ext_ubsqueal.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Contact/src/ufric/ext_ufric.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Elements/src/Nlrsfd/ext_nlrsfd.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Elements/src/Nlrsfda/ext_nlrsfda.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Elements/src/thpad/ext_thpad.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Elements/src/uselem/ext_uselem.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Materials/src/crplaw/ext_crplaw.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Materials/src/hypela2/ext_hypela2.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Materials/src/orient/ext_orient.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Materials/src/uelastomer/ext_uelastomer.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Materials/src/ufail/ext_ufail.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Materials/src/uprogfail/ext_uprogfail.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Materials/src/umat/ext_umat.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/Materials/src/ucohesive/ext_ucohes.F
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/MSC&amp;lt;prod_ver&amp;gt;/nast/services/Implementations/GeneralInfo/ext_notify.F
SOL 700
In order to create a simulation that includes a user defined subroutine, templates are made available in the MSC Nastran
installation. There are two options available:
MSC Nastran also has a directory with many examples of User Subroutines at:
&amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/msc&amp;lt;prod_ver&amp;gt;/nast/UDR/SOL700
You are advised to check these examples and copy the appropriate content for your purpose.
Copy one of these to the working directory and modify its contents as needed. The user subroutines will then be compiled,
and a dynamic library will be created. FORTRAN: &amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/msc&amp;lt;prod_ver&amp;gt;/dytran/&lt;!-- raw HTML omitted --&gt;/usr-subrtns/dytran_usersub.f
C: &amp;lt;msc_base&amp;gt;/&lt;!-- raw HTML omitted --&gt;/msc&amp;lt;prod_ver&amp;gt;/dytran/&lt;!-- raw HTML omitted --&gt;/usr-subrtns/dytran_usersub.c&lt;/p&gt;
&lt;p&gt;22User Defined Services User’s Guide
User Defined Subroutines
Main Index
Implementation without Templates
Without using the provided templates in the SDK, the first step in implementing a user-defined subroutine is to create a
service definition language (SDL) file and component definition language (CDL) file. These two files correspond to one or
more interface definition language (IDL) files. The IDL files for user subroutines are provided in the installation.
The next step is to generate the skeleton file for the service. The build environment provides a tool, namely “genskeleton”,
to generate the desired skeleton file from an IDL, SDL, and CDL file. Once the skeleton file is generated, you can add the
desired functionality to the appropriate methods within the service. By default, the generated skeleton files will be a C++
source and header file. For further information on how to invoke the genskeleton program, please refer to SCA Service
Guide .
For illustration purposes, let’s assume that you have decided to create a service within “T est” name space for the NLRSFD&lt;br&gt;
user subroutine, and the intention is to only implement the interface that is provided by its IDL.
The following code example illustrates the content of the sdl file:
#ifndef TEST_SDL_INCLUDED
#define TEST_SDL_INCLUDED
#include &amp;ldquo;SCA/MDSolver/Obj/Uds/Elements/Nlrsfd/nlrsfd.idl&amp;rdquo;
module Test {
service Test.Nlrsfd
{
interface
SCA::MDSolver::Obj::Uds::Elements::Nlrsfd::SCAIMDSolverNlrsfd;
};
}; // Test
#endif
Similarly, the CDL file contains the definition of service (or services), which will form the component. An example for a
CDL file is illustrated below:
#ifndef TEST_NLRSFD_CDL_INCLUDED
#define TEST_NLRSFD_CDL_INCLUDED
#include &amp;ldquo;test.sdl&amp;rdquo;
component myTest
{
service Test.Nlrsfd;
};
#endif
Upon generating the skeleton file with the above, the C++ source file will contain four methods:
1.Constructor (a method which is automatically invoked when the service is created)
2.Destructor (a method which is automatically invoked when the service is destroyed)&lt;/p&gt;
&lt;p&gt;23 CHAPTER 1
Main Index
3.runNlrsfd  (the functional method)
4.runNlrsfd_64  (the 64-bit functional method for ILP64)
The constructor method is called each time the service is initiated. Similarly the destructor method is called each time the
service is terminated. The runNlrsfd  method is the functional method in which you can add your specific
implementation, and runNlrsfd_64  for implementations for ILP64 mode.
The runNlrsfd  method implements the static signature defined by the MSC Nastran application, and will be called by
the MSC Nastran application while processing the nonlinear force (NLRSFD) entries of the input file. Using the
parameters passed to runNlrsfd  method, you will have access to all arguments that are set through the NLRSFD entry
at input. You can implement your formulation and update the following parameters, returning back to MSC Nastran:
SCAReal64 fx,
SCAReal64 fy,
SCAInt32  fuseit,
SCAInt32  bisect,
SCAReal32 parm1,
SCAReal32 parm2,
SCAReal32 parm3,
SCAReal32 parm4,
SCAReal32 parm5,
SCAReal32 parm6,
SCAReal32 parm7,
SCAReal32 parm8.
More information on these parameters is given in the following sections.
#include &amp;ldquo;Nlrsfd.h&amp;rdquo;
namespace Test {
// Constructor
Nlrsfd::Nlrsfd(SCAINlrsfdFactoryAccess* factoryAccess) : NlrsfdBase(factoryAccess)
{
}
// Destructor
Nlrsfd::~Nlrsfd()
{
}
SCAResult Nlrsfd::runNlrsfd(const SCAInt32 sid, const SCAInt32 ga, const SCAInt32 gb,
const SCAString plane, const SCAReal32 bdia, const SCAReal32 blen, const SCAReal32
bclr,
const SCAString soln, const SCAReal32 visco, const SCAReal32 pvapco,
const SCAInt32 nport, const SCAReal32 pres1, const SCAReal32 theta1,
const SCAReal32 pres2, const SCAReal32 theta2, const SCAInt32 npnt,
const SCAReal32 offset1, const SCAReal32 offset2, const SCAString evalname,
const SCAReal32 time, const SCAReal64 xx, const SCAReal64 yy, const SCAReal64 xdt,
const SCAReal64 ydt, const SCAReal64 xb, const SCAReal64 yb, const SCAReal64 xbt,
const SCAReal64 ybt, SCAReal64&amp;amp; fx, SCAReal64&amp;amp; fy, SCAInt32&amp;amp; fuseit,
SCAInt32&amp;amp; bisect, SCAReal32&amp;amp; parm1, SCAReal32&amp;amp; parm2, SCAReal32&amp;amp; parm3,
SCAReal32&amp;amp; parm4, SCAReal32&amp;amp; parm5, SCAReal32&amp;amp; parm6, SCAReal32&amp;amp; parm7,&lt;/p&gt;
&lt;p&gt;24User Defined Services User’s Guide
User Defined Subroutines
Main Index
SCAReal32&amp;amp; parm8, const SCAReal32 omega)
{
return SCASuccess;
}
SCAResult Nlrsfd::runNlrsfd_64(const SCAInt64 sid, const SCAInt64 ga, const SCAInt64
gb,
const SCAString plane, const SCAReal64 bdia, const SCAReal64 blen, const SCAReal64
bclr,
const SCAString soln, const SCAReal64 visco, const SCAReal64 pvapco,
const SCAInt64 nport, const SCAReal64 pres1, const SCAReal64 theta1,
const SCAReal64 pres2, const SCAReal64 theta2, const SCAInt64 npnt,
const SCAReal64 offset1, const SCAReal64 offset2, const SCAString evalname,
const SCAReal64 time, const SCAReal64 xx, const SCAReal64 yy, const SCAReal64 xdt,
const SCAReal64 ydt, const SCAReal64 xb, const SCAReal64 yb, const SCAReal64 xbt,
const SCAReal64 ybt, SCAReal64&amp;amp; fx, SCAReal64&amp;amp; fy, SCAInt64&amp;amp; fuseit,
SCAInt64&amp;amp; bisect, SCAReal64&amp;amp; parm1, SCAReal64&amp;amp; parm2, SCAReal64&amp;amp; parm3,
SCAReal64&amp;amp; parm4, SCAReal64&amp;amp; parm5, SCAReal64&amp;amp; parm6, SCAReal64&amp;amp; parm7,
SCAReal64&amp;amp; parm8, const SCAReal64 omega)
{
return SCASuccess;
}
}
Building the Service
T o build the service, execute the “ scons”  command at the top level of the source tree. The build environment compiles and
links all necessary files, including the modifications to any user subroutine within the source tree. A dynamically loaded
library is created and will later be used by the MSC Nastran application at runtime.
If the SConopts.user file does not exist in the home directory or if the paths are not defined in that file, the SCA_OBJECT,
APPS_LOCAL , and APPS2_SYSTEM  paths must be specified when running scons (provided by the MSC Software
Development Kit).&lt;br&gt;
SOL 400
T o build the service with SCons, enter the following command:
&amp;lt;msc_base&amp;gt;/msc_sdk&amp;lt;prod_ver&amp;gt;/Tools/ scons  S CA_OBJECT=&amp;lt;SCA_OBJECT_PATH&amp;gt;&lt;br&gt;
APPS_LOCAL=&amp;lt;APPS_LOCAL_PATH&amp;gt;&lt;/p&gt;
&lt;p&gt;25 CHAPTER 1
Main Index
Environment Variables
In order to load the generated User Defined Service, within the launch environment, three new environment variables have
to be set:
SCA_LIBRARY_PATH  – points to the location where the libraries are to be found.
SCA_SERVICE_CATALOG  – points to the location of the SCA service catalog.
SCA_RESOURCE_DIR  – points to the location of SCA resource directory.
Presence of these three environment variables ensures proper loading of user defined services. For the example provided
earlier in this document, these three environment variables should be set as following:
Windows (64 bit):
set SCA_LIBRARY_PATH=&amp;lt;APPS_LOCAL&amp;gt;\WIN8664\lib
set SCA_SERVICE_CATALOG=&amp;lt;APPS_LOCAL&amp;gt;\res\SCAServiceCatalog.xml
set SCA_RESOURCE_DIR=&amp;lt;APPS_LOCAL&amp;gt;\res
Linux (64 bit):
set SCA_LIBRARY_PATH=&amp;lt;APPS_LOCAL&amp;gt;/LX8664/lib
set SCA_SERVICE_CATALOG=&amp;lt;APPS_LOCAL&amp;gt;/res/SCAServiceCatalog.xml
set SCA_RESOURCE_DIR=&amp;lt;APPS_LOCAL&amp;gt;/res
Using the Service
In this section, we will describe the modifications to the input file required for using the user-defined service.
In order to identify the service, you will have to create a connection between the service name and a service identifier. This
is done through the connect statement in the FMS statement. The syntax for new connect entry is as follows:
connect service &amp;lt;group_name&amp;gt; ‘&amp;lt;service_name&amp;gt;’
Where group_name  is a name tag (8 characters long) which will be used to identify the service implementation to be used
for a specific bulk data entry, and service_name  is the name of service, for example:
connect service contact ‘SCA.MDSolver.Obj.Uds.Contact’
creates a group_name  service identifier “contact” , which points to the “SCA.MDSolver.Util.Ums”  service.
Available service names for the user subroutines (based on the example implementations) include
SOL 400
•SCA.MDSolver.Obj.Uds.Contact  (MOTION , SEPFOR , SEPSTR , UBSQUEAL , UFRIC )
•SCA.MDSolver.Obj.Uds.Elements.Nlrsfd
•SCA.MDSolver.Obj.Uds.Elements.Nlrsfda
•SCA.MDSolver.Obj.Uds.Elements.uselem
•SCA.MDSolver.Obj.Uds.GeneralInfo&lt;/p&gt;
&lt;p&gt;26User Defined Services User’s Guide
User Defined Subroutines
Main Index
•SCA.MDSolver.Obj.Uds.Materials  (CRPLAW , HYPELA2 , ORIENT , UCOHES , UELASTOMER ,
UFAIL , UMAT , UPROGFAIL )
T o trigger the service, an appropriate bulk data entry has to be associated with the group name while also specifying the
user subroutine in the user subroutine name field of the entry – except for NLRSFD  since its card does not have a user
subroutine field.
Currently available cards for each category of user subroutines comprise
SOL 400
•BCONUDS  – contact user subroutines
•ELEMUDS  – element user subroutines
•GENUDS  – general runtime info user subroutines
•MATUDS  – material user subroutines
•NLRSFD  – non-linear squeeze film damper user subroutine
SOL 700
•FLOWUDS  – Euler flow boundary user subroutines
•PORUDS  – Coupling boundary user subroutines
•NLOUTUD  – Grid point and element output user subroutines
•TICEUDS  – Lagrange grid point and Euler element initialization user subroutines
•FAILUDS  – Material failure model user subroutines
•YLDUDS  – Material yield model  user subroutines
•SHRUDS  – Material shear model  runtime info user subroutines
•EOSUDS  – Material equation of state model  runtime info user subroutines
•FORCUDS  – Grid point enforced velocity user subroutines
•TABLUDS  – Table input user subroutines
•COMPUDS  – Composite material user subroutine
For the UDS cards, each has a field for a referenced ID and its type, a group name, a user subroutine name, and optional
auxiliary user data (integers, real, and characters). The format for BCONUDS  can be seen below. See the MSC Nastran
Quick Reference Guide  for the format of the relevant entries.
BCONUDS &amp;lt;body_id&amp;gt; &amp;lt;body_type&amp;gt; &amp;lt;group_name&amp;gt; &amp;lt;usersub_name&amp;gt;
INT       &lt;!-- raw HTML omitted --&gt;   …
REAL      &lt;!-- raw HTML omitted --&gt;      …
CHAR      &lt;!-- raw HTML omitted --&gt;      …
The lines for the auxiliary data may be omitted as they are optional, but the other fields are required.
Input file example for motion:&lt;/p&gt;
&lt;p&gt;27 CHAPTER 1
Main Index&lt;/p&gt;
&lt;p&gt;Error Handling
The current implementation provides a limited means for error handling. Upon return from a user defined service method,
the value of the return call will be examined. SCASuccess is a constant equal to zero, and if that is returned, the MSC
Nastran application assumes that the execution of the User Defined Service has been successful. Anything other than zero
is viewed as an error. In the FORTRAN user subroutine implementations, the error code can be set through the
error_code  variable. MSC Nastran upon return to the main application evaluates this return code and terminates the
application if its value is not zero. A message including the nonzero return value is printed in the output file ( f06).connect service contact &amp;lsquo;SCA.MDSolver.Obj.Uds.Contact&amp;rsquo;
&amp;hellip;
SOL 400
&amp;hellip;
BEGIN BULK
&amp;hellip;
BCONUDS 7       BCBODY contact motion
INT     1337    2       3       4       5       6       7
REAL    3.1415  2.2     3.3     4.4
CHAR    FOO     B111B22 C111C2
2 D111D22 E11
BCBODY 7 2D RIGID 0 0 1 0
&amp;hellip;&lt;/p&gt;
&lt;p&gt;28User Defined Services User’s Guide
User Defined Subroutines
Main Index
Utility Routines
F06 Printing Routine
The printf06  function provides a mechanism to write a line to the F06 file. It takes a character string as an argument and
returns a SCAResult of integer type. The following is an example of how it can be used in a user subroutine:
integer, external :: printf06
integer           :: scareturn
scareturn = printf06(‘foo’)
scareturn = printf06(‘bar’)&lt;/p&gt;
&lt;p&gt;29 CHAPTER 1
DDOT
Main Index
Description
Returns the dot product of two vectors.
Format
Utility function DDOT  can be used in the following format:
ddot(nn, a, ia, b, ib, ans)
where:DDOT Inner Product of Two Vectors
Input:
nn is the number of items in each vector to be used .
a is the first input vector .
ia is the stride in vector A .
b is the second input vector .
ib is the stride in vector B .
Required Output:
ans is the inner product of vectors A and B .
Note: Vectors A, B, and ANS are real*8  variables.&lt;/p&gt;
&lt;p&gt;30User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
Returns element related data.
Format
Utility routine get_elem_param  can be called with the following format:
function get_elem_param (pname, arg1, arg2, arg3, ivar, rvar, cvar)
where:
The available keywords in get_elem_param  are:GET_ELEM_PARAM Element Data Utility Function
Input:
pname is the keyword indicating what kind of data to return, character.
arg1 is the element ID, integer .
arg2 is the integration point number, integer .
arg3 is the layer number, integer .
Required Output:
ivar is the returned integer type data.
rvar is the returned real type data .
cdata is the returned character type data .
Return:
0 success
≠ 0 error
Keyword Data Type Length
element_type Integer 1
direct_stress_quantities Integer 1
shear_stress_quantities Integer 1
nodes_of_the_element Integer 1
integration_points_of_the_element Integer 1
material_id_for_the_element Integer 1
element_class Integer 1&lt;/p&gt;
&lt;p&gt;31 CHAPTER 1
GET_ELEM_PARAM
Main Index
major_engineering_strain Real 1
minor_engineering_strain Real 1
current_volume Real 1
original_volume Real 1
total_temperature Real 1
incremental_temperature Real 1
equivalent_von_mises_stress Real 1
equivalent_stress_yield_stress_ratio Real 1
equivalent_elastic_strain Real 1
equivalent_creep_strain Real 1
total_strain_energy_density Real 1
elastic_strain_energy_density Real 1
plastic_strain_energy_density Real 1
gasket_pressure Real 1
gasket_closure Real 1
plastic_gasket_closure Real 1
failure_index Real 1
total_value_of_first_state_variable Real 1
total_value_of_second_state_variable Real 1
total_value_of_third_state_variable Real 1
volume_fraction_of_martensite Real 1
equivalent_phase_transformation_strain Real 1
equivalent_twin_strain Real 1
equivalent_trip_strain Real 1
components_of_cauchy_stress Real 6
components_of_total_strain Real 6
components_of_elastic_strain Real 6
components_of_plastic_strain Real 6
components_of_creep_strain Real 6
components_of_thermal_strain Real 6
components_of_stress_preferred_system Real 6
phase_transformation_strain_tensor Real 6
interlaminar_shear_thick_elements_txz Real 1Keyword Data Type Length&lt;/p&gt;
&lt;p&gt;32User Defined Services User’s Guide
User Defined Subroutines
Main Index
interlaminar_shear_thick_elements_tyz Real 1
interlaminar_normal_stress Real 3
interlaminar_shear_stress Real 3Keyword Data Type Length&lt;/p&gt;
&lt;p&gt;33 CHAPTER 1
GET_GLOBAL_PARAM
Main Index
Description
Returns model information and data.
Format
Utility routine get_global_type  can be called with the following format:
function get_global_param (pname, ivar, rvar, cvar)
where:
The available keywords in get_global_param  are:GET_GLOBAL_PARAM Model Information Utility Function
Input:
pname is the keyword indicating what kind of data to return, character .
Required Output:
ivar is the returned integer type data.
rvar is the returned real type data .
cdata is the returned character type data .
Return:
0 success
≠ 0 error
Keyword Data type Length
subcase_number Integer 1
step_number Integer 1
increment_number Integer 1
iteration_number Integer 1
current_time Real 1
incremental_time Real 1
time_of_previous_step Real 1
time_of_previous_increment Real 1
fractin_of_step_completed Real 1
large_disp_flag Integer 1&lt;/p&gt;
&lt;p&gt;34User Defined Services User’s Guide
User Defined Subroutines
Main Index
job_name String variable
job_directory String variable
working_directory String variable
scratch_directory String variable
num_procs Integer 1
num_cpus Integer 1Keyword Data type Length&lt;/p&gt;
&lt;p&gt;35 CHAPTER 1
GET_NODE_PARAM
Main Index
Description
Returns node related data.
Format
Utility routine get_node_param  can be called with the following format:
function get_node_param (pname, arg1, ivar, rvar, cvar)
where:
The available keywords in get_node_param  are:GET_NODE_PARAM Node Data Utility Function
Input:
pname is the keyword indicates what kind of data to return, character .
arg1 is the grid ID, integer .
Required Output:
ivar is the returned integer type data.
rvar is the returned real type data .
cdata is the returned character type data .
Return:
0 success
≠0 error
Keyword Data Type Length
displacement Real 3
rotation Real 3
velocity Real 3
rotational_velocity Real 3
acceleration Real 3
rotational_acceleration Real 3
coordinate Real 3&lt;/p&gt;
&lt;p&gt;36User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
The GET_TIME  routine provides a mechanism to get the current time from the simulation.
Example
C++:
double time;
GET_TIME(&amp;amp;time);
Fortran:
real(8) :: time
call GET_TIME(time)GET_TIME Routine Mechanism to get Current Time&lt;/p&gt;
&lt;p&gt;37 CHAPTER 1
GET_TIMESTEP Routine
Main Index
Description
The GET_TIMESTEP  routine provides a mechanism to get the current timestep from the simulation.&lt;br&gt;
Example
C++:
double time_step;
GET_TIMESTEP(&amp;amp;time_step);
Fortran:
real(8) :: time_step
call GET_TIMESTEP(time_step)GET_TIMESTEP Routine Mechanism to get Current Timestep&lt;/p&gt;
&lt;p&gt;38User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
The IGET_STEP  routine provides a mechanism to get the current step number from the simulation.
Example
C++:
long int ncycle;
IGET_STEP (&amp;amp;ncycle);
Fortran:
integer(8) :: ncycle
call IGET_STEP(ncycle)IGET_STEP Routine Mechanism to get Current Step Number&lt;/p&gt;
&lt;p&gt;39 CHAPTER 1
IGET_NSWRAP Routine
Main Index
Description
The IGET_NSWRAP  routine provides a mechanism to get the wrapping condition from the simulation.
Example
C++:
long int nswrap;
IGET_NSWRAP(&amp;amp;nswrap);
Fortran:
integer(8) :: nswrap
call IGET_NSWRAP(nswrap)
The following wrapping conditions are possible:IGET_NSWRAP Routine Mechanism to get Wrapping Condition
nswrap = 1 the cycle limit has been reached
nswrap = 2 the time limit has been reached
nswrap = 3 the time step has become too small
nswrap = 5 cpu time limit exceeded
nswrap = 8 an error of unknown fatality occurred
nswrap = 9 an error occurred
nswrap = 13 a catastrophic error has occurred
nswrap = 14 a fatal error has occurred
nswrap = 16 an error has occurred in another UDS service&lt;/p&gt;
&lt;p&gt;40User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
The IPUT_NSWRAP  routine provides a mechanism to put a wrapping condition to the simulation.
Example
C++:
long int nswrap;
iput_nswrap(&amp;amp;nswrap);
Fortran:
integer(8) :: nswrap
call IPUT_NSWRAP(nswrap)
The only wrapping condition that can be send by iput_nswrap  is nswrap=16 .IPUT_NSWRAP Routine Mechanism to put Wrapping Condition&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P3</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_003/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_003/</guid>
      <description>
        
        
        &lt;p&gt;41 CHAPTER 1
GMADD
Main Index
Description
Add two matrices and put sum into third matrix.
Format
Utility routine gmadd  can be called with the following format:
gmadd(w, x, y, n, m)
where:GMADD Add Matrix
Input:
w is the first input matrix .
x is the second input matrix.
n is the first dimension of W, X, and Y.
m is the second dimension of W, X, and Y.
Required Output:
y is the output matrix, Y = W + X .
Note: Matrices W, X, and Y are real*8  arrays.&lt;/p&gt;
&lt;p&gt;42User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
Multiply two matrices and put product in third matrix.
Format
Utility routine gmprd  can be called with the following format:
gmprd (w, x, y, n, m , l)
where:GMPRD Matrix Product
Input :
w is the first input matrix .
x is the second input matrix .
n is the first dimension of W and Y .
m is the second dimension of W and first dimension of X .
l is the second dimension of X and Y .
Required Output:
y is the output matrix, Y = W * X .
Note: Matrices W, X, and Y are real*8  arrays.&lt;/p&gt;
&lt;p&gt;43 CHAPTER 1
GMSUB
Main Index
Description
Subtract two matrices and put remainder in third matrix.
Format
Utility routine gmsub  can be called with the following format:
gmsub (w, x, y, n, m)
where:GMSUB Subtract Matrix
Input:
w is the first input matrix .
x is the second input matrix .
n is the first dimension of W, X, and Y .
m is the second dimension of W, X, and Y .
Required Output:
y is the output matrix, Y = W – X .
Note: Matrices W, X, and Y are real*8  arrays.&lt;/p&gt;
&lt;p&gt;44User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
T ranspose a matrix.
Format
Utility routine gmtra  can be called with the following format:
gmtra (w, x, n, m)
where:GMTRA Transpose Matrix
Input:
w is the input matrix .
n is the first dimension of W and second dimension of X .
m is the second dimension of W and first dimension of X .
Required Output:
x is the output matrix X = WT.
Note: Matrices W and X are real*8  matrices.&lt;/p&gt;
&lt;p&gt;45 CHAPTER 1
GTPRD
Main Index
Description
Transpose product of two matrices.
Format
Utility routine gtprd  can be called with the following format:
gtprd (w, x, y, n, m, l)
where:GTPRD Transpose Matrix Product
Input:
w is the first input matrix .
x is the second input matrix .
n is the first dimension of w and x.
m is the second dimension of w and first dimension of y.
l is the second dimension of x and y.
Required Output:
y is the output matrix Y = WT&lt;em&gt;X.
Note: Matrices W, X, and Y are real&lt;/em&gt;8  matrices.&lt;/p&gt;
&lt;p&gt;46User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
Invert 3 x 3 matrices.
Format
Utility routine inv3x3  can be called with the following format:
inv3x3(a, ainv, det, iflag)
where:INV3X3 Invert 3 X 3 Matrix
Input:
a is the input matrix .
iflag  is the flag for output .
Required Output:
a is the inverse of input matrix a if IFLAG = 1.
ainv  is the inverse of input matrix a if IFLAG is not = 1.
det is the determinant of a.
Note: Matrices A, AINV, and scalar DET are real*8 variables
•If DET = 0, the matrix is singular and the inverse is not calculated.&lt;/p&gt;
&lt;p&gt;47 CHAPTER 1
MCPY
Main Index
Description
Copy a matrix.
Format
Utility routine mcpy  can be called with the following format:
mcpy(w, x, n, m, ms)
where:MCPY Copy Matrix
Input:
w is the input matrix .
n is the first dimension of w and x.
m is the second dimension of w and x.
ms is the not used .
Required Output:
x is the output matrix, X = W .
Note: Matrices W and X are real*8  arrays.&lt;/p&gt;
&lt;p&gt;48User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
Solves 3 x 3 Eigen problem with Jacobi transformations to find principle values of stresses and strains.
Format
Utility routine princv  can be called with the following format:
princv(pv, r, v, ndi, nshear, iss, jcr1, jcr2, jcr3)
where:PRINCV Find Principle Values
Input:
v(6) is the vector of strains or stresses.
ndi is the number of direct stress or strain components.
nshear is the number of shear stress or strain components.
iss is the flag to indicate whether v is stress or strain.
if iss = 0, V is stress
if iss = 1, V is strain
jcr1 is set to 0 .
jcr2 is set to 0 .
jcr3 is set to 0 .
Required Output:
pv(3) is the vector of principal values .
r(3,3) is the matrix of principal directions .
Note: Vectors and matrices PV, R, and V are real*8  arrays.&lt;/p&gt;
&lt;p&gt;49 CHAPTER 1
SCLA
Main Index
Description
Assign a scalar value to a matrix.
Format
Utility routine scla  can be called with the following format:
scla (w, c, n, m, ms)
where:SCLA Set Matrix to Value
Input:
w is the input matrix .
c is the scalar .
n is the first dimension of w.
m is the second dimension of W.
ms is not used .
Required Output:
w is the output matrix.
Note: Matrix W and scalar C are real*8  variables.&lt;/p&gt;
&lt;p&gt;50User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
This user subroutine allows the user to calculate his own finite element stiffness or mass matrix. This can also be used as
interface with other numerical techniques. In general, in the finite element calculation, several matrices are required; hence,
for a particular element, this user subroutine is called a multiple number of times. The calls and the user’s requirements are
defined as follows:
Using this option, the user can only define an element similar to an existing MSC Nastran element types, such that all user
element properties including dimensions, connectivity and integration points will be the same as this MSC Nastran element
type.
A virtual material type must be defined and assigned to the property definition option associated with user elements.
Otherwise, the program will exit with input errors.
The subroutine is activated by ELEMUDS  bulk data option. ELEMUDS  defines the service name associated with the user
subroutine, and the data (integer, real and characters) to be used in the user subroutine. It should look like the following
for EXT_USELEM  application:
ELEMUDS,pid,ptype,sname,uselem,
,INT,…
,REAL,…
,CHAR,…
Where  ptype  is the property type associated with the user-defined elements, pid is the property identification number of
ptype , and sname  is the name of this service. Integers (real numbers, characters) can be defined and passed into
EXT_USELEM  with the key word INT (REAL, CHAR) .
Format
IDLEXT_USELEM User-defined Element
IFLAG=2 Return the element tangent stiffness matrix ( K). For an elastic analysis, this is the usual
stiffness. For a heat transfer matrix analysis, this is the conductivity matrix. Also calculate
the total internal forces ( R). This is not necessary in a linear elastic analysis.
IFLAG=3 Return the mass matrix ( M) for a dynamic analysis or specific heat matrix for a heat transfer
problem.
IFLAG=4 Calculate the incremental strains ( DE), generalized stresses ( GSIGS ) and the internal force
(R). For a linear elastic solution, if only displacements are required, the user does not need
to return any values. In a heat transfer analysis, the thermal gradient and the heat fluxes
(both stored via SIGXX ) and the internal flux vector ( R) need to be calculated.&lt;/p&gt;
&lt;p&gt;51 CHAPTER 1
EXT_USELEM
Main Index
module SCA {
module MDSolver {
module Obj {
module Uds {
module Elements {
module uselem {
typedef SCAInt32 DynInt32[];
typedef SCAInt64 DynInt64[];
typedef SCAReal64 DynReal64[];
typedef SCAReal64 DynReal64_2[][];
interface SCAIMDSolverUselem : SCAIService
{
SCAResult usrUselem_32( in    SCAInt32    m,
out   DynReal64_2 xk,
out   DynReal64_2 xm,
in    SCAInt32    nnode,
in    SCAInt32    ndeg,
out   DynReal64_2 f,
out   DynReal64_2 r,
in    SCAInt32    jtype,
in    DynReal64_2 dispt,
in    DynReal64_2 disp,
in    SCAInt32    ndi,
in    SCAInt32    nshear,
in    SCAInt32    ipass,
in    SCAInt32    nstats,
in    SCAInt32    ngenel,
in    SCAInt32    intel,
in    DynReal64_2 coord,
in    SCAInt32    ncrd,
in    SCAInt32    iflag,
in    SCAInt32    idss,
in    DynReal64_2 t,
in    DynReal64_2 dt,
out   DynReal64_2 etota,
out   DynReal64_2 gsigs,
out   DynReal64_2 de,
in    DynReal64   geom,
in    DynInt32    jgeom,
out   DynReal64_2 sigxx,
in    SCAInt32    nstrmu,
in    DynInt32    idata,
in    DynReal64   rdata,
in    DynInt32    cidata );
SCAResult usrUselem_64( in    SCAInt64    m,
out   DynReal64_2 xk,
out   DynReal64_2 xm,
in    SCAInt64    nnode,&lt;/p&gt;
&lt;p&gt;52User Defined Services User’s Guide
User Defined Subroutines
Main Index
in    SCAInt64    ndeg,
out   DynReal64_2 f,
out   DynReal64_2 r,
in    SCAInt64    jtype,
in    DynReal64_2 dispt,
in    DynReal64_2 disp,
in    SCAInt64    ndi,
in    SCAInt64    nshear,
in    SCAInt64    ipass,
in    SCAInt64    nstats,
in    SCAInt64    ngenel,
in    SCAInt64    intel,
in    DynReal64_2 coord,
in    SCAInt64    ncrd,
in    SCAInt64    iflag,
in    SCAInt64    idss,
in    DynReal64_2 t,
in    DynReal64_2 dt,
out   DynReal64_2 etota,
out   DynReal64_2 gsigs,
out   DynReal64_2 de,
in    DynReal64   geom,
in    DynInt64    jgeom,
out   DynReal64_2 sigxx,
in    SCAInt64    nstrmu,
in    DynInt64    idata,
in    DynReal64   rdata,
in    DynInt64    cidata );
};
}; // uselem
}; // Elements
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult uselem::usrUselem_32(const SCAInt32 m, DynReal64_2&amp;amp; xk, DynReal64_2&amp;amp; xm, const SCAInt32 nnode, const SCAInt32 ndeg,
DynReal64_2&amp;amp; f, DynReal64_2&amp;amp; r, const SCAInt32 jtype, const DynReal64_2&amp;amp; dispt,
const DynReal64_2&amp;amp; disp, const SCAInt32 ndi, const SCAInt32 nshear, const SCAInt32 ipass,
const SCAInt32 nstats, const SCAInt32 ngenel, const SCAInt32 intel, const DynReal64_2&amp;amp; coord,
const SCAInt32 ncrd, const SCAInt32 iflag, const SCAInt32 idss, const DynReal64_2&amp;amp; t,
const DynReal64_2&amp;amp; dt, DynReal64_2&amp;amp; etota, DynReal64_2&amp;amp; gsigs, DynReal64_2&amp;amp; de,
const DynReal64&amp;amp; geom, const DynInt32&amp;amp; jgeom, DynReal64_2&amp;amp; sigxx, const SCAInt32 nstrmu,
const DynInt32&amp;amp; idata, const DynReal64&amp;amp; rdata, const DynInt32&amp;amp; cidata)
{
return SCASuccess;
}
SCAResult uselem::usrUselem_64(const SCAInt64 m, DynReal64_2&amp;amp; xk, DynReal64_2&amp;amp; xm, const SCAInt64 nnode, const SCAInt64 ndeg,
DynReal64_2&amp;amp; f, DynReal64_2&amp;amp; r, const SCAInt64 jtype, const DynReal64_2&amp;amp; dispt,
const DynReal64_2&amp;amp; disp, const SCAInt64 ndi, const SCAInt64 nshear, const SCAInt64 ipass,
const SCAInt64 nstats, const SCAInt64 ngenel, const SCAInt64 intel, const DynReal64_2&amp;amp; coord,
const SCAInt64 ncrd, const SCAInt64 iflag, const SCAInt64 idss, const DynReal64_2&amp;amp; t,
const DynReal64_2&amp;amp; dt, DynReal64_2&amp;amp; etota, DynReal64_2&amp;amp; gsigs, DynReal64_2&amp;amp; de,&lt;/p&gt;
&lt;p&gt;53 CHAPTER 1
EXT_USELEM
Main Index
const DynReal64&amp;amp; geom, const DynInt64&amp;amp; jgeom, DynReal64_2&amp;amp; sigxx, const SCAInt64 nstrmu,
const DynInt64&amp;amp; idata, const DynReal64&amp;amp; rdata, const DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_uselem(m, ipid, iptyp, xk, xm, nnode, ndeg, f, r,
&amp;amp;             jtype, dispt, disp, ndi, nshear, ipass, nstats,
&amp;amp;             ngenel, intel, coord, ncrd, iflag, idss, t, dt,
&amp;amp;             etota, gsigs, de, geom, jgeom, sigxx, nstrmu, idata,
&amp;amp;             rdata, cdata, len_idata, len_rdata, len_cdata,
&amp;amp;             error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: m, ipid, iptyp, nnode, ndeg, jtype, ndi
integer, intent(in)  :: nshear, ipass, nstats, ngenel, intel, ncrd
integer, intent(in)  :: iflag, idss, nstrmu
integer, intent(out) :: error_code
integer, intent(in),  dimension(8)             :: jgeom
real(8), intent(out), dimension(idss, idss)    :: xk, xm
real(8), intent(out), dimension(ndeg, nnode)   :: f, r
real(8), intent(in),  dimension(ndeg, nnode)   :: dispt, disp
real(8), intent(in),  dimension(ncrd, nnode)   :: coord
real(8), intent(in),  dimension(nstats, intel) :: t, dt
real(8), intent(out), dimension(ngenel, intel) :: etota, gsigs, de
real(8), intent(in),  dimension(8)             :: geom
real(8), intent(out), dimension(nstrmu, intel) :: sigxx
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
end subroutine ext_uselem
Input:
m is the user element number.
nnode is the number of nodes per element.
ndeg is the maximum number of degrees of freedom per node.
jtype is the user element type (negative).
dispt is the total nodal displacements array of this element.
In heat transfer, DISPT  is the temperature array at which material properties were last calculated.
disp is the incremental nodal displacements of this element.
In heat transfer, DISP  is the total current nodal temperatures of this element.&lt;/p&gt;
&lt;p&gt;54User Defined Services User’s Guide
User Defined Subroutines
Main Index
ndi is the number of direct components of stress/internal heat flux.
nshear is the number of shear components of stress.
In heat transfer, NSHEAR  is zero.
ipass Flag to indicate which pass for coupled analysis.
= 1 during a stress analysis pass.
= 2 during a heat transfer pass.
nstats is the number of state variables. 1 for MSC Nastran
ngenel is the number of generalized strains.
intel is the number of integration points.
coord is the original nodal coordinates array.
ncrd is the number of coordinates per node.
iflag indicates what is to be returned by the user.
= 2 Called by OASEMB  during formation of stiffness matrix.
You return XK,R .
= 3 Called by OASMAS  during formation of mass matrix.
The user returns XM.
= 4 Called by OGETST  during stress recovery.
The user returns R,GSIGS,DE,ETOTA,SIGXX  for stress analysis pass.
The user returns R, SIGXX  for heat transfer pass.
idss is the size of element stiffness matrix.
t(1) is the temperature.
dt(1) is the increment of temperature.
geom is the array of the geometric parameters. (not used for MSC Nastran).
jgeom is the array of table ids for the geometric parameters. (not used for MSC Nastran).
ipid is property ID for the element.
iptyp is property type:
= 1 PROD
= 2 PBAR
= 3 PBARL
= 4 PBEAM
= 5 PBEAML&lt;/p&gt;
&lt;p&gt;55 CHAPTER 1
EXT_USELEM
Main Index
= 6 PSHELL
= 7 PCOMP
= 8 PSHEAR
= 9 PLPLANE
= 10 PLCOMP
= 11 PSOLID
= 12 PCOMPLS
= 13 PLSOLID
= 14 PCOHE
= 15 PCOMPF
= 16 PAXISYM
idata is user-supplied integer data in MATUDS .
rdata is user-supplied real data in MATUDS .
cdata is user-supplied character data in MATUDS .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
xk is the stiffness matrix or conductivity matrix.
xm is the mass matrix or specific heat matrix.
f is the externally applied equivalent nodal loads/nodal fluxes array.
r is the internal forces/fluxes array.
etota is the total strain array.
Not used in heat transfer.
gsigs is the generalized stress array.
Not used in heat transfer.
de is the increment of strain array.
Not used in heat transfer.
sigxx is the layer stresses for shell elements and is equal to GSIGS  for continuum element.&lt;/p&gt;
&lt;p&gt;56User Defined Services User’s Guide
User Defined Subroutines
Main Index
In the heat transfer pass, SIGXX  contains the thermal gradients and the heat fluxes.
error_code is the returned error code; 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;57 CHAPTER 1
EXT_CBUSH2D
Main Index
This user subroutine allows the user to specify apriori determined variation of spring stiffness and damping coefficients with
rotor speed in frequency response analysis. The independent parameter for this UDS is rotor speed or the frequency and
the outputs are 2x2 stiffness matrix and 2x2 damping matrix. These matrices are added to the system matrices for each
frequency step.
The subroutine is activated by PBUSH2D and ELEMUDS bulk data option. ELEMUDS defines the service name
associated with the user subroutine, and the data (integer, real and characters) to be used in the user subroutine. It should
look like the following for EXT_CBUSH2D application:
Where “pid” is the property ID specified in the CBUSH2D entry.
Format
IDL Format
#ifndef SCA_MDSOLVER_OBJ_UDS_ELEMENTS_CBUSH2D_CBUSH2D_IDL_
#define SCA_MDSOLVER_OBJ_UDS_ELEMENTS_CBUSH2D_CBUSH2D_IDL_
#include &amp;ldquo;SCA/Service.idl&amp;rdquo;
module SCA {
module MDSolver {
module Obj {
module Uds {
module Elements {
module cbush2d {
typedef SCAInt32  DynInt32[];
typedef SCAInt64  DynInt64[];
typedef SCAReal32 DynReal32[];
typedef SCAReal64 DynReal64[];
typedef SCAReal64 DynReal64_2[][];
interface SCAIMDSolverCbush2d : SCAIService
{
SCAResult cbush2d_32(in  SCAReal32 freqva,
in  DynInt32  iarray,
in  DynReal32 rarray,
in  DynInt32  carray,
out SCAReal64 kxx,
out SCAReal64 kyx,
out SCAReal64 kxy,EXT_CBUSH2D User defined CBUSH2D element
PBUSH2D pid 0.0  0.0
ELEMUDS pid PBUSH2D sname uselem
INT,… REAL,… CHAR,…&lt;/p&gt;
&lt;p&gt;58User Defined Services User’s Guide
User Defined Subroutines
Main Index
out SCAReal64 kyy,
out SCAReal64 cxx,
out SCAReal64 cyx,
out SCAReal64 cxy,
out SCAReal64 cyy,
in  SCAInt32  elid);
SCAResult cbush2d_64(in  SCAReal64 freqva,
in  DynInt64  iarray,
in  DynReal64 rarray,
in  DynInt64  carray,
out SCAReal64 kxx,
out SCAReal64 kyx,
out SCAReal64 kxy,
out SCAReal64 kyy,
out SCAReal64 cxx,
out SCAReal64 cyx,
out SCAReal64 cxy,
out SCAReal64 cyy,
in  SCAInt64  elid);
};
}; // cbush2d
}; // Elements
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
#endif
C++ Format
#ifndef SCA_MDSOLVER_OBJ_UDS_ELEMENTS_CBUSH2D_CBUSH2D_H_INCLUDED
#define SCA_MDSOLVER_OBJ_UDS_ELEMENTS_CBUSH2D_CBUSH2D_H_INCLUDED
#include &amp;ldquo;cbush2dBase.h&amp;rdquo;
namespace SCA { namespace MDSolver { namespace Obj { namespace Uds { namespace Elements
{ namespace cbush2d {
class cbush2d : public cbush2dBase
{
public:
// Constructor and Destructor
cbush2d(SCAIcbush2dFactoryAccess* factoryAccess);
virtual ~cbush2d();
// Methods for interface SCA.MDSolver.Obj.Uds.Elements.cbush2d.SCAIMDSolverCbush2d
virtual SCAResult cbush2d_32(const SCAReal32 freqva, const DynInt32&amp;amp; iarray, const
DynReal32&amp;amp; rarray, const DynInt32&amp;amp; carray, SCAReal64&amp;amp; kxx, SCAReal64&amp;amp; kyx, SCAReal64&amp;amp;&lt;/p&gt;
&lt;p&gt;59 CHAPTER 1
EXT_CBUSH2D
Main Index
kxy, SCAReal64&amp;amp; kyy, SCAReal64&amp;amp; cxx, SCAReal64&amp;amp; cyx, SCAReal64&amp;amp; cxy, SCAReal64&amp;amp; cyy,
const SCAInt32 elid);
virtual SCAResult cbush2d_64(const SCAReal64 freqva, const DynInt64&amp;amp; iarray, const
DynReal64&amp;amp; rarray, const DynInt64&amp;amp; carray, SCAReal64&amp;amp; kxx, SCAReal64&amp;amp; kyx, SCAReal64&amp;amp;
kxy, SCAReal64&amp;amp; kyy, SCAReal64&amp;amp; cxx, SCAReal64&amp;amp; cyx, SCAReal64&amp;amp; cxy, SCAReal64&amp;amp; cyy,
const SCAInt64 elid);
};
} } } } } }
#endif
Fortran Format
subroutine ext_cbush2d(freqva, iarray, rarray, ciarray, kxx, kyx,
&amp;amp;             kxy, kyy, cxx, cyx, cxy, cyy, len_iarray, len_rarray,
&amp;amp;             len_carray, elid, error_code)
implicit none
integer, intent(in)  :: len_iarray, len_rarray, len_carray, elid
integer, intent(out) :: error_code
real,    intent(in)  :: freqva
real(8), intent(out) :: kxx, kyx, kxy, kyy, cxx, cyx, cxy, cyy
integer, intent(in), dimension(len_iarray) :: iarray
real,    intent(in), dimension(len_rarray) :: rarray
integer, intent(in), dimension(len_carray) :: ciarray
#if defined(_PTR64) &amp;amp;&amp;amp; defined(_SINGLE)
character(len=8), dimension(len_carray) :: carray
#else
character(len=4), dimension(len_carray) :: carray
#endif
integer, external :: printf06
if (len_carray &amp;gt; 0) carray = transfer(ciarray, carray)
…..
end subroutine ext_cbush2d&lt;/p&gt;
&lt;p&gt;60User Defined Services User’s Guide
User Defined Subroutines
Main Index
Variable Description
This user subroutine allows the user to specify apriori determined variation of spring inertia, stiffness and damping
coefficients with rotor speed in complex eigenvalue and transient analysis &amp;amp; excitation frequency in frequency response
analysis. The independent parameter for this UDS is rotor speed or the excitation frequency and the outputs are 2x2
stiffness matrix, 2x2 damping matrix and 2x2 inertia matrix. These matrices are added to the system matrices for each step.
The subroutine is activated by PBUSH2D and ELEMUDS bulk data option. ELEMUDS defines the service name
associated with the user subroutine, and the data (integer, real and characters) to be used in the user subroutine. It should
look like the following for EXT_CBUSH2DA application:
CONNECT SERVICE TESTF &amp;lsquo;SCA.MDSolver.Obj.Uds.Elements.cbush2da&amp;rsquo;Inputs Description
freqva Fundamental frequency/ rotor speed
iarray Array of integers defined in ELEMUDS
rarray Array of real numbers defined in ELEMUDS
ciarray Array of characters defined in ELEMUDS
len_iarray Length of integer array
len_rarray Length of real number array
len_carray Length of character array
elid CBUSH2D element ID
Output Description
kxx 2x2 Stiffness matrix
kyx
kxy
kyy
cxx 2x2 Damping matrix
cyx
cxy
cyy
error_code Error code
EXT_CBUSH2DA User defined CBUSH2D element&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P4</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_004/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_004/</guid>
      <description>
        
        
        &lt;p&gt;61 CHAPTER 1
EXT_CBUSH2DA
Main Index
…
BEGIN BULK
CBUSH2D 202     211     1111    1112    0       XY
PBUSH2D 211     0.0     0.0
ELEMUDS 211     PBUSH2D TESTF   cbush2daFREQ    10.0
real    10.0    3.389+8 2.000+6 3.000+6 5.788+8
0.12    0.06    0.09    0.12
30.0    10.0    15.0    60.0
60.     4.455+8 5.000+6 6.000+6 5.238+8
0.08    0.13    0.15    0.07
30.0    10.0    15.0    60.0
85.0    6.455+9 7.250+7 8.850+7 7.348+9
0.1     0.17    0.19    0.22
30.0    10.0    15.0    60.0
Format
IDL Format
#ifndef SCA_MDSOLVER_OBJ_UDS_ELEMENTS_CBUSH2DA_CBUSH2DA_IDL_INCLUDED
#define SCA_MDSOLVER_OBJ_UDS_ELEMENTS_CBUSH2DA_CBUSH2DA_IDL_INCLUDED
#include &amp;ldquo;SCA/Service.idl&amp;rdquo;
module SCA {
module MDSolver {
module Obj {
module Uds {
module Elements {
module cbush2da {
typedef SCAInt32  DynInt32[];
typedef SCAInt64  DynInt64[];
typedef SCAReal32 DynReal32[];&lt;/p&gt;
&lt;p&gt;62User Defined Services User’s Guide
User Defined Subroutines
Main Index
typedef SCAReal64 DynReal64[];
interface SCAIMDSolverCbush2da : SCAIService
{
SCAResult cbush2da_32(
in SCAInt32 option,
in SCAInt32 nomlkbm,
in SCAInt32 len_CSI1, in SCAString CSI1,
in SCAInt32 len_CSI2, in SCAString CSI2,
in SCAInt32 len_CSI3, in SCAString CSI3,
in SCAInt32 len_IIarray1, in DynInt32  IIarray1,
in SCAInt32 len_IIarray2, in DynInt32  IIarray2,
in SCAInt32 len_IIarray3, in DynInt32  IIarray3,
in SCAInt32 len_RIarray0, in DynReal32 RIarray0,
in SCAInt32 len_RIarray1, in DynReal32 RIarray1,
in SCAInt32 len_RIarray2, in DynReal32 RIarray2,
in SCAInt32 len_RIarray3, in DynReal32 RIarray3,
in SCAInt32 len_CSO1, out SCAString CSO1,
in SCAInt32 len_CSO2, out SCAString CSO2,
in SCAInt32 len_CSO3, out SCAString CSO3,
in SCAInt32 len_IOarray1, out DynInt32  IOarray1,
in SCAInt32 len_IOarray2, out DynInt32  IOarray2,
in SCAInt32 len_IOarray3, out DynInt32  IOarray3,
in SCAInt32 len_ROarray1, out DynReal32 ROarray1,
in SCAInt32 len_ROarray2, out DynReal32 ROarray2,
in SCAInt32 len_ROarray3, out DynReal32 ROarray3,
out SCAInt32 iRETURN);
SCAResult cbush2da_64(
in SCAInt64 option,
in SCAInt64 nomlkbm,
in SCAInt64 len_CSI1, in SCAString CSI1,
in SCAInt64 len_CSI2, in SCAString CSI2,
in SCAInt64 len_CSI3, in SCAString CSI3,&lt;/p&gt;
&lt;p&gt;63 CHAPTER 1
EXT_CBUSH2DA
Main Index
in SCAInt64 len_IIarray1, in DynInt64  IIarray1,
in SCAInt64 len_IIarray2, in DynInt64  IIarray2,
in SCAInt64 len_IIarray3, in DynInt64  IIarray3,
in SCAInt64 len_RIarray0, in DynReal64 RIarray0,
in SCAInt64 len_RIarray1, in DynReal64 RIarray1,
in SCAInt64 len_RIarray2, in DynReal64 RIarray2,
in SCAInt64 len_RIarray3, in DynReal64 RIarray3,
in SCAInt64 len_CSO1, out SCAString CSO1,
in SCAInt64 len_CSO2, out SCAString CSO2,
in SCAInt64 len_CSO3, out SCAString CSO3,
in SCAInt64 len_IOarray1, out DynInt64  IOarray1,
in SCAInt64 len_IOarray2, out DynInt64  IOarray2,
in SCAInt64 len_IOarray3, out DynInt64  IOarray3,
in SCAInt64 len_ROarray1, out DynReal64 ROarray1,
in SCAInt64 len_ROarray2, out DynReal64 ROarray2,
in SCAInt64 len_ROarray3, out DynReal64 ROarray3,
out SCAInt64 iRETURN);
};
}; // cbush2da
}; // Elements
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
#endif
C++ Format
#ifndef SCA_MDSOLVER_OBJ_UDS_ELEMENTS_CBUSH2DA_CBUSH2DA_H_INCLUDED
#define SCA_MDSOLVER_OBJ_UDS_ELEMENTS_CBUSH2DA_CBUSH2DA_H_INCLUDED
#include &amp;ldquo;cbush2daBase.h&amp;rdquo;
#include &amp;ldquo;SCA/LoggingMacros.h&amp;rdquo;
namespace SCA { namespace MDSolver { namespace Obj { namespace Uds { namespace Elements
{ namespace cbush2da {&lt;/p&gt;
&lt;p&gt;64User Defined Services User’s Guide
User Defined Subroutines
Main Index
class cbush2da : public cbush2daBase
{
public:
// Constructor and Destructor
explicit cbush2da(SCAIcbush2daFactoryAccess* factoryAccess);
virtual ~cbush2da();
// Methods for interface SCA.MDSolver.Obj.Uds.Elements.cbush2da.SCAIMDSolverCbush2da
virtual SCAResult cbush2da_32(
const SCAInt32 option,
const SCAInt32 nomlkbm,
const SCAInt32 len_CSI1, const SCAString CSI1,
const SCAInt32 len_CSI2, const SCAString CSI2,
const SCAInt32 len_CSI3, const SCAString CSI3,
const SCAInt32 len_IIarray1, const DynInt32&amp;amp; IIarray1,
const SCAInt32 len_IIarray2, const DynInt32&amp;amp; IIarray2,
const SCAInt32 len_IIarray3, const DynInt32&amp;amp; IIarray3,
const SCAInt32 len_RIarray0, const DynReal32&amp;amp; RIarray0,
const SCAInt32 len_RIarray1, const DynReal32&amp;amp; RIarray1,
const SCAInt32 len_RIarray2, const DynReal32&amp;amp; RIarray2,
const SCAInt32 len_RIarray3, const DynReal32&amp;amp; RIarray3,
const SCAInt32 len_CSO1, SCAString&amp;amp; CSO1,
const SCAInt32 len_CSO2, SCAString&amp;amp; CSO2,
const SCAInt32 len_CSO3, SCAString&amp;amp; CSO3,
const SCAInt32 len_IOarray1, DynInt32&amp;amp; IOarray1,
const SCAInt32 len_IOarray2, DynInt32&amp;amp; IOarray2,
const SCAInt32 len_IOarray3, DynInt32&amp;amp; IOarray3,
const SCAInt32 len_ROarray1, DynReal32&amp;amp; ROarray1,
const SCAInt32 len_ROarray2, DynReal32&amp;amp; ROarray2,
const SCAInt32 len_ROarray3, DynReal32&amp;amp; ROarray3,
SCAInt32&amp;amp; iRETURN);&lt;/p&gt;
&lt;p&gt;65 CHAPTER 1
EXT_CBUSH2DA
Main Index
virtual SCAResult cbush2da_64(
const SCAInt64 option,
const SCAInt64 nomlkbm,
const SCAInt64 len_CSI1, const SCAString CSI1,
const SCAInt64 len_CSI2, const SCAString CSI2,
const SCAInt64 len_CSI3, const SCAString CSI3,
const SCAInt64 len_IIarray1, const DynInt64&amp;amp; IIarray1,
const SCAInt64 len_IIarray2, const DynInt64&amp;amp; IIarray2,
const SCAInt64 len_IIarray3, const DynInt64&amp;amp; IIarray3,
const SCAInt64 len_RIarray0, const DynReal64&amp;amp; RIarray0,
const SCAInt64 len_RIarray1, const DynReal64&amp;amp; RIarray1,
const SCAInt64 len_RIarray2, const DynReal64&amp;amp; RIarray2,
const SCAInt64 len_RIarray3, const DynReal64&amp;amp; RIarray3,
const SCAInt64 len_CSO1, SCAString&amp;amp; CSO1,
const SCAInt64 len_CSO2, SCAString&amp;amp; CSO2,
const SCAInt64 len_CSO3, SCAString&amp;amp; CSO3,
const SCAInt64 len_IOarray1, DynInt64&amp;amp; IOarray1,
const SCAInt64 len_IOarray2, DynInt64&amp;amp; IOarray2,
const SCAInt64 len_IOarray3, DynInt64&amp;amp; IOarray3,
const SCAInt64 len_ROarray1, DynReal64&amp;amp; ROarray1,
const SCAInt64 len_ROarray2, DynReal64&amp;amp; ROarray2,
const SCAInt64 len_ROarray3, DynReal64&amp;amp; ROarray3,
SCAInt64&amp;amp; iRETURN);
};
} } } } } }
#endif
Fortran Format
SUBROUTINE EXT_CBUSH2DA (option, nomlkbm,
+    len_CSI1, CSI1, len_CSI2, CSI2, len_CSI3, CSI3,
+    len_II1 , II1 , len_II2 , II2 , len_II3 , II3 ,
+    len_RI0 , RI0 ,
+    len_RI1 , RI1 , len_RI2 , RI2 , len_RI3 , RI3 ,
+    len_CSO1, CSO1, len_CSO2, CSO2, len_CSO3, CSO3,
+    len_IO1 , IO1 , len_IO2 , IO2 , len_IO3 , IO3 ,&lt;/p&gt;
&lt;p&gt;66User Defined Services User’s Guide
User Defined Subroutines
Main Index
+    len_RO1 , RO1 , len_RO2 , RO2 , len_RO3 , RO3 ,
+    error_code)
!
IF (option .eq. 11) THEN
S22=&amp;lsquo;EXT_CBUSH2DA&amp;rsquo;
CALL ext_CBUSH2Dadv (
+        II1(1), ! flag
+        nomlkbm,          ! nomlkbm
+        RI0(1),           ! nmlspd
+        RI1(1), ! freqva
+        RI2(1), ! ref_speed
+        II3, ! iarray
+        RI3, ! rarray
+        CSx1, ! carray
+        len_II3, ! len_iarray
+        len_RI3, ! len_rarray
+        NW1, ! len_carray
+        II2(1), ! elid
+        RO1(1),RO1(2),RO1(3),RO1(4), ! kxx,kyx,kxy,kyy
+        RO1(5),RO1(6),RO1(7),RO1(8), ! cxx,cyx,cxy,cyy
+        RO1(9),RO1(10),RO1(11),RO1(12), ! mxx,myx,mxy,myy
+        error_code) ! Error/Return code
GO TO 700   ! DBG &amp;amp; RETURN
ELSE
GO TO 600   ! Error &amp;amp; Return
ENDIF
!
subroutine ext_CBUSH2Dadv (flag, nomlkbm, nmlspd,freqva,ref_speed,
+             iarray, rarray, carray,
+             len_iarray, len_rarray, len_carray,
+             elid,
+             kxx, kyx, kxy, kyy,
+             cxx, cyx, cxy, cyy,
+             mxx, myx, mxy, myy,&lt;/p&gt;
&lt;p&gt;67 CHAPTER 1
EXT_CBUSH2DA
Main Index
+             error_code)
C PURPOSE:
C   THIS ROUTINE RETURNS 2x2 STIFFNESS, DAMPING &amp;amp; INERTIA
C   MATRICES                                            &lt;br&gt;
C
C INPUT ARGUMENT LIST:
C
C    FLAG      : Flag to identify type of analysis.
C                SOL107/110     -&amp;gt; APP4=CEIG -&amp;gt; FLAG=1
C                SOL108/111/128 -&amp;gt; APP4=FREQ -&amp;gt; FLAG=2
C                SOL400         -&amp;gt; APP4=TRAN -&amp;gt; FLAG=3
C    NOMLKBM   : Flag to identify Nominal or Freq dependent cond.
C                = 0 (Nominal condition)
C                = 1 (Freq dependent condition)
C
C    NMLSPD    : Nominal Speed set in ELEMUDS card (7th field)
C    (always     Each ELEMUDS card has separate NMLSPD entry
C     in CPS)    &amp;amp; it is used only for that ELEMUDS/PBUSH2D combination
C
C    FREQVA    : Frequency of Excitation in SOL 108 &amp;amp; SOL 111
C    (always     Same for Rotor SPEED for FREQ analysis with SYNC option
C     in CPS)    Not used in Complex Eigenvalue &amp;amp; Transient analysis
C
C    REF_SPPED : Reference Rotor Speed in RGYRO card
C    (always     Used in FREQ analysis with ASYNC, Complex Eigenvalue
C     in CPS)    &amp;amp; Transient analysis
C
C&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
C    BELOW TABLE SHOWS SPEED/FREQUENCY USED UNDER DIFFERENT ROTOR RGYRO SETTINGS
C&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
C    ANALYSIS         | RGYRO SYNFLAG  |  WHICH FREQUENCY
C    TYPE             | SETTING        |  /SPEED USED
C    &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;
&lt;p&gt;68User Defined Services User’s Guide
User Defined Subroutines
Main Index
C    FREQ RESP        | SYNC           |  FREQ   : Units in CPS
C    (SOL108,111,128) | ASYNC          |  SPEED  : Units in CPS
C    1. For Frequency response analysis with synchronous excitation,
C       excitation frequency is equal to spin rate of reference rotor
C    2. For Frequency response analysis with asynchronous excitation,
C       spin rate is constant and equal to rotation speed of the reference rotor
C    &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
C    CEIG             | SYNC           |  SPEED  : Units in CPS
C    (SOL107,110)     | ASYNC          |  SPEED  : Units in CPS
C    1. For Complex modes analysis with synchronous excitation,
C       calculated Critical speed is equal to spin rate of reference rotor
C    2. For Complex Eigenvalue analysis with asynchronous excitation,
C       spin rate is constant and equal to rotation speed of the reference rotor
C    3. If CAMPBELL call is used, SPEED is set from DDVAL table.
C    &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
C    TRANSIENT        | SYNC           |  NOT ALLOWED
C    (SOL400)         | ASYNC          |  SPEED  : Units in CPS
C    1. For Transient analysis with asynchronous excitation,
C       spin rate is constant and equal to rotation speed of the reference rotor
C    &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
C
C    IARRAY          : Integer Input Array
C    LEN_IARRAY      : Length of Integer Input Array
C    RARRAY          : Real Input Array
C    LEN_RARRAY      : Length of Real Input Array
C    CARRAY          : Character Input Array
C    LEN_CARRAY      : Length of Character Input Array
C
C    ELID            : ELEMENT ID
C
C OUTPUT ARGUMENT LIST:
C
C    KXX,KXY,KYX,KYY : 2x2 ELEMUDS OUTPUT STIFFNESS MATRIX
C    KXX,KXY,KYX,KYY : 2x2 ELEMUDS OUTPUT STIFFNESS MATRIX&lt;/p&gt;
&lt;p&gt;69 CHAPTER 1
EXT_HYPELA2
Main Index
C    KXX,KXY,KYX,KYY : 2x2 ELEMUDS OUTPUT STIFFNESS MATRIX
C
Description
This user subroutine gives the user the ability to implement arbitrary material models in conjunction with the MATUSR&lt;br&gt;
bulk data option. The program supplies the user with the total displacement, incremental displacement, total mechanical
strain (mechanical strain = total strain – thermal strain), the increment of mechanical strain, and other information. Stress,
total strain, and state variable arrays at the beginning of the increment  are passed to EXT_HYPELA2 . The user is
expected to calculate stresses S, tangent stiffness D, and state variables (if present) that correspond to the current strain at
the end of the increment .
The subroutine is activated by MATUSR  along with MATUDS  bulk data options. MATUDS  defines the service name
corresponding to the material, and the data (integer, real and characters) used to define the material properties in the user
subroutine. It should look like the following for EXT_HYPELA2  application:
MATUDS,mid,MATUSR,sname,HYPELA2,
,INT,…
,REAL,…
,CHAR,…
Where  mid is the material identification number consistent with MATUSR  and sname  is the name of this service. Integers
(real numbers, characters) can be defined and passed into EXT_HYPELA2  with the key word INT (REAL, CHAR) .
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Materials {
module hypela2 {
typedef SCAInt32 DynInt32[];
typedef SCAInt64 DynInt64[];
typedef SCAReal64 DynReal64[];
typedef SCAReal64 DynReal64_2[][];
interface SCAIMDSolverHypela2 : SCAIService
{
SCAResult usrHypela2_32( out   DynReal64_2 d,
out   DynReal64   g,
in    DynReal64   e,
in    DynReal64   de,EXT_HYPELA2 User-defined Material Behavior
ttn=
ttn1+ = &lt;/p&gt;
&lt;p&gt;70User Defined Services User’s Guide
User Defined Subroutines
Main Index
out   DynReal64   s,
in    DynReal64   t,
in    DynReal64   dt,
in    SCAInt32    ngens,
in    DynInt32    n,
in    SCAInt32    nn,
in    DynInt32    kcus,
in    DynInt32    matus,
in    SCAInt32    ndi,
in    SCAInt32    nshear,
in    DynReal64_2 disp,
in    DynReal64_2 dispt,
in    DynReal64_2 coord,
in    DynReal64_2 ffn,
in    DynReal64_2 frotn,
in    DynReal64   strechn,
in    DynReal64_2 eigvn,
in    DynReal64_2 ffn1,
in    DynReal64_2 frotn1,
in    DynReal64   strechn1,
in    DynReal64_2 eigvn1,
in    SCAInt32    ncrd,
in    SCAInt32    itel,
in    SCAInt32    ndeg,
in    SCAInt32    ndm,
in    SCAInt32    nnode,
in    SCAInt32    jtype,
in    DynInt32    lclass,
in    SCAInt32    ifr,
in    SCAInt32    ifu,
in    SCAInt32    nstats,
in    SCAInt32    isunit,
in    DynInt32    idata,
in    DynReal64   rdata,
in    DynInt32    cidata );
SCAResult usrHypela2_64( out   DynReal64_2 d,
out   DynReal64   g,
in    DynReal64   e,
in    DynReal64   de,
out   DynReal64   s,
in    DynReal64   t,
in    DynReal64   dt,
in    SCAInt64    ngens,
in    DynInt64    n,
in    SCAInt64    nn,
in    DynInt64    kcus,
in    DynInt64    matus,
in    SCAInt64    ndi,
in    SCAInt64    nshear,
in    DynReal64_2 disp,&lt;/p&gt;
&lt;p&gt;71 CHAPTER 1
EXT_HYPELA2
Main Index
in    DynReal64_2 dispt,
in    DynReal64_2 coord,
in    DynReal64_2 ffn,
in    DynReal64_2 frotn,
in    DynReal64   strechn,
in    DynReal64_2 eigvn,
in    DynReal64_2 ffn1,
in    DynReal64_2 frotn1,
in    DynReal64   strechn1,
in    DynReal64_2 eigvn1,
in    SCAInt64    ncrd,
in    SCAInt64    itel,
in    SCAInt64    ndeg,
in    SCAInt64    ndm,
in    SCAInt64    nnode,
in    SCAInt64    jtype,
in    DynInt64    lclass,
in    SCAInt64    ifr,
in    SCAInt64    ifu,
in    SCAInt64    nstats,
in    SCAInt64    isunit,
in    DynInt64    idata,
in    DynReal64   rdata,
in    DynInt64    cidata );
};
}; // hypela2
}; // Materials
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Materials::usrHypela2_32(hypela2::DynReal64_2&amp;amp; d, hypela2::DynReal64&amp;amp; g, const hypela2::DynReal64&amp;amp; e,
const hypela2::DynReal64&amp;amp; de, hypela2::DynReal64&amp;amp; s, const hypela2::DynReal64&amp;amp; t,
const hypela2::DynReal64&amp;amp; dt, const SCAInt32 ngens, const hypela2::DynInt32&amp;amp; n,
const SCAInt32 nn, const hypela2::DynInt32&amp;amp; kcus, const hypela2::DynInt32&amp;amp; matus,
const SCAInt32 ndi, const SCAInt32 nshear, const hypela2::DynReal64_2&amp;amp; disp,
const hypela2::DynReal64_2&amp;amp; dispt, const hypela2::DynReal64_2&amp;amp; coord,
const hypela2::DynReal64_2&amp;amp; ffn, const hypela2::DynReal64_2&amp;amp; frotn,
const hypela2::DynReal64&amp;amp; strechn, const hypela2::DynReal64_2&amp;amp; eigvn,
const hypela2::DynReal64_2&amp;amp; ffn1, const hypela2::DynReal64_2&amp;amp; frotn1,
const hypela2::DynReal64&amp;amp; strechn1, const hypela2::DynReal64_2&amp;amp; eigvn1, const SCAInt32 ncrd,
const SCAInt32 itel, const SCAInt32 ndeg, const SCAInt32 ndm, const SCAInt32 nnode,
const SCAInt32 jtype, const hypela2::DynInt32&amp;amp; lclass, const SCAInt32 ifr,
const SCAInt32 ifu, const SCAInt32 nstats, const SCAInt32 isunit,
const hypela2::DynInt32&amp;amp; idata, const hypela2::DynReal64&amp;amp; rdata,
const hypela2::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}&lt;/p&gt;
&lt;p&gt;SCAResult Materials::usrHypela2_64(hypela2::DynReal64_2&amp;amp; d, hypela2::DynReal64&amp;amp; g, const hypela2::DynReal64&amp;amp; e,
const hypela2::DynReal64&amp;amp; de, hypela2::DynReal64&amp;amp; s, const hypela2::DynReal64&amp;amp; t,
const hypela2::DynReal64&amp;amp; dt, const SCAInt64 ngens, const hypela2::DynInt64&amp;amp; n,
const SCAInt64 nn, const hypela2::DynInt64&amp;amp; kcus, const hypela2::DynInt64&amp;amp; matus,
const SCAInt64 ndi, const SCAInt64 nshear, const hypela2::DynReal64_2&amp;amp; disp,
const hypela2::DynReal64_2&amp;amp; dispt, const hypela2::DynReal64_2&amp;amp; coord,&lt;/p&gt;
&lt;p&gt;72User Defined Services User’s Guide
User Defined Subroutines
Main Index
const hypela2::DynReal64_2&amp;amp; ffn, const hypela2::DynReal64_2&amp;amp; frotn,
const hypela2::DynReal64&amp;amp; strechn, const hypela2::DynReal64_2&amp;amp; eigvn,
const hypela2::DynReal64_2&amp;amp; ffn1, const hypela2::DynReal64_2&amp;amp; frotn1,
const hypela2::DynReal64&amp;amp; strechn1, const hypela2::DynReal64_2&amp;amp; eigvn1, const SCAInt64 ncrd,
const SCAInt64 itel, const SCAInt64 ndeg, const SCAInt64 ndm, const SCAInt64 nnode,
const SCAInt64 jtype, const hypela2::DynInt64&amp;amp; lclass, const SCAInt64 ifr,
const SCAInt64 ifu, const SCAInt64 nstats, const SCAInt64 isunit,
const hypela2::DynInt64&amp;amp; idata, const hypela2::DynReal64&amp;amp; rdata,
const hypela2::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_hypela2(d, g, e, de, s, t, dt, ngens, n, nn, kcus,
&amp;amp;             matus, ndi, nshear, disp, dispt, coord, ffn, frotn,
&amp;amp;             strechn, eigvn, ffn1, frotn1, strechn1, eigvn1, ncrd,
&amp;amp;             itel, ndeg, ndm, nnode, jtype, lclass, ifr, ifu,
&amp;amp;             nstats, isunit, idata, rdata, cdata,
&amp;amp;             len_idata, len_rdata, len_cdata, error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: ngens, nn, ndi, nshear, ncrd, itel, ndeg
integer, intent(in)  :: ndm, nnode, jtype, ifr, ifu, nstats
integer, intent(in)  :: isunit
integer, intent(out) :: error_code
integer, intent(in),  dimension(2)            :: n, kcus, matus
integer, intent(in),  dimension(2)            :: lclass
real(8), intent(out), dimension(ngens, ngens) :: d
real(8), intent(out), dimension(ngens)        :: g, s
real(8), intent(in),  dimension(ngens)        :: e, de
real(8), intent(in),  dimension(nstats)       :: t, dt
real(8), intent(in),  dimension(ndeg, nnode)  :: disp, dispt
real(8), intent(in),  dimension(ndeg, nnode)  :: coord
real(8), intent(in),  dimension(itel, itel)   :: ffn, ffn1
real(8), intent(in),  dimension(itel, itel)   :: frotn, frotn1
real(8), intent(in),  dimension(itel)         :: strechn, strechn1
real(8), intent(in),  dimension(itel, itel)   :: eigvn, eigvn1
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
end subroutine ext_hypela2
Input:
e is the total elastic mechanical strain.
de is the increment of mechanical strain.
t(1) is the temperature at beginning of increment.
dt(1) is the increment of temperature.&lt;/p&gt;
&lt;p&gt;73 CHAPTER 1
EXT_HYPELA2
Main Index
ngens is the size of the stress-strain law.
n is the element number.
nn is the integration point number.
kcus(1) is your layer number (always 1 for continuum elements).
kcus(2) is the internal layer number (always 1 for continuum element).
matus(1) is the user material identifier.
matus(2) is the internal material identifier.
ndi is the number of direct components.
nshear is the number of shear components.
disp is the incremental displacements.
dispt is the displacements at t = tn (at assembly) and the displacements at t = tn+1(at stress recovery).
coord is the coordinates.
ncrd is the number of coordinates.
ndeg is the number of degrees of freedom.
itel is the dimension of F and R; 2 for plane-stress and 3 for the rest of the cases.
nnode is the number of nodes per element.
jtype is the element type.
lclass(1) is the element class.
lclass(2) is 0 for displacement element.
is 1 for lower-order Herrmann element.
is 2 for higher-order Herrmann element.
ifr is set to 1 if R has been calculated.
ifu is set to 1 if STRECH  has been calculated.
At t = tn (or the beginning of the increment):
ffn is the deformation gradient.
frotn is the rotation tensor.
strechn is the square of principal stretch ratios,  (i).
eigvn (i,j) is the I principal direction components for J eigenvalues.
At t = tn+1 (or the current time step):
ffn1 is the deformation gradient.
frotn1 is the rotation tensor.&lt;/p&gt;
&lt;p&gt;74User Defined Services User’s Guide
User Defined Subroutines
Main Index
Parameter
Without a specific parameter, engineering strain and stress are passed.
With the NLMOPTS,LRGDISP  parameter, Green-Lagrange strains and second Piola-Kirchhott stresses are passed.
With NLMOPTS,LRGSTRN  parameter, logarithmic strains and Cauchy stresses are passed.
For large strain rubber elasticity, the EXT_UELASTOMER  user subroutine is recommended.
For large strain inelasticity, the NLMOPTS ,LRGSTRN  parameter must be used. With the parameter, strain and stress
components are rotated by the program to account for rigid-body motion before EXT_CBUSH2D  is called; so, the
stress integration for the co-rotational part is performed in EXT_CBUSH2D  based on rotation neutralized values. The
user is required to pass back the updated rotation neutralized stress based on the co -rotational system. The shell
thickness is only updated with the NLMOPTS ,LRGSTRN  parameter.strechn1 is the square of principal stretch ratios, lambda (i).
eigvn1(i,j) is the I principal direction components for J eigenvalues.
nstats is the number of state variables.
isunit is the system units.
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
idata is the user-supplied integer data in MATUDS.
rdata is the user-supplied real data in MATUDS.
cdata is the user-supplied character data in MATUDS.
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
d is the stress strain law to be formed.
g is the change in stress due to temperature effects.
s is the stress to be updated by you.
error_code is returned error code; 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;75 CHAPTER 1
EXT_HYPELA2
Main Index
Strains
E() and DE(), which are passed to EXT_CBUSH2D , are the elastic mechanical strain and the increment of mechanical
strain, respectively. Here, mechanical strain is defined by “total strain – thermal strain”. Note that for the first iteration
during assembly, DE is an estimate of the strain change.
Coordinate System
Continuum (3-D-Solid, plane strain, axisymmetric and 2-D plane stress) elements use the global Cartesian coordinate
system for the base vectors of stress and strain components. Also, membranes, shells and beams usually use the local, element
Cartesian systems. However, if the NLMOPTS ,LRGSTRN  parameter is used, strain and stress components are rotated to
account of rigid-body motion before EXT_CBUSH2D  is called. So, local Cartesian coordinate system is used based on rotation-
neutralized values
If a user-defined orientation is used, the stress and strain components are stored in the local orientation axis. The basis
vectors rotate with the material by rotation tensor ( R) and, so the stress and strain are already stored in the rotated
orientation axis before EXT_CBUSH2D  is called.
Stress and Strain Components Order of Storage
The number of strain and stress components is composed of “number of direct components” ( NDI) and “number of shear
components” ( NSHEAR ). For example, 3-D solid elements: ndi=3  and nshear=3, thick shells: ndi=2  and nshear=3 ,
thin shells and membranes: ndi=2  and nshear=1 , plane strain and axisymmetric elements: ndi=3  and nshear=1,
beams: ndi=1 and shear=0 to 2 . The stress and strain are first stored direct components followed by shear
components. For full components, ( ndi=3, nshear=3), S(11), S(22), S(33), S(12), S(23), S(31)  is the
right order to store. For Herrmann formulation of elements, the last strain component is the volumetric strain and the last
stress component is the mean pressure constant. Thus, in the Herrmann formulation, NGENS = NDI + NSHEAR + 1 .
Tangent Stiffness
The user also needs to provide the tangent stiffness D based on the updated stress.
The rate of convergence or a nonlinear problem depends critically on the user supplied tangent stiffness D. Before using
this user subroutine for large problems, it is recommended that the user check the user subroutine with one-element
problems under displacement and load control boundary conditions. The displacement controlled boundary condition
problem checks the accuracy of the stress update procedure while the load controlled problem checks the accuracy of the
tangent stiffness. A fully consistent exact tangent stiffness provides quadratic convergence of the displacement or residual
norm.
Thermal Stress Problems
For thermal stress problems, the user needs to calculate and return the change in stress Gi due to temperature dependent
material properties.Dij¶Dsi()
¶Dej()&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;=&lt;/p&gt;
&lt;p&gt;76User Defined Services User’s Guide
User Defined Subroutines
Main Index
where  and n+1 are the temperatures at time t = n  and t = n + 1 , respectively and j is strain increment which is
passed to EXT_HYPELA2 .
Deformation Gradient ( F), Rotation Tensor ( R) and Stretch Tensor ( U)
For continuum (3-D solid, plane strain, axisymmetric and 2-D plane stress) elements and membranes, the deformation
gradient and rotation tensor are passed. For those elements, principal stretch ratio and eigenvectors are also passed to
EXT_HYPELA2 . Based on the information, the user can calculate stretch tensor ( U) as follows:
DO I=1,3
DO J=1,3
UN1 (I,J) = 0.D0
DO K=1,3
UN1 (I,J) = UN1 (I,J)+DSQRT (STRETCH1(K)*EIGVN1(I,K)*EIGVN1(J,K))
ENDDO
ENDDO
ENDDO
In this case, STRECHN1  stores the value of the squares of the stretches, and EIGVN1(I,J)  stores the Ith eigenvector
component corresponding to the Jth eigenvalue of C, where C is the right Cauchy-Green T ensor at .
For shells and beams, kinematic variables are not available.Gi Dqn1+Dqn–() ijDe()j =
tn1+ =&lt;/p&gt;
&lt;p&gt;77 CHAPTER 1
EXT_UMAT
Main Index
Description
This user subroutine implements arbitrary materials models. In addition to supply user with total displacement,
incremental displacement, total mechanical strain (mechanical strain = total strain – thermal strain), the increment of
mechanical strain and other information, the program also passes user defined state variables and internal data like the
analyzing phase and convergence flag. The stress, total strain and state variables at the beginning of the increment (t =tn)
are passed to EXT_UMAT . The user is expected to calculate stress s, tangent stiffness D, and increments of user state variables
dt that correspond to the current strain at the end of the increment ( t = tn+1). The increments of user state variables will
be added to state variables when the current increment converges. The user defined state variables are defined in UDSESV&lt;br&gt;
entry. The subroutine is activated by MATUSR  along with MATUDS  bulk data options.
The analyzing phase, converge flag and integration point volume are passed by internal data arguments. The phase number
4 indicates the analyzing is in assembly stage, both stress and tangent stiffness are required to return. The phase number 6
indicates it is in stress recovery stage, only stress is required. The converge flag -1 means the current increment is not
converged yet, and converge flag 1 means the increment is converged. The integration point volume is the integration point
Jacobian value.
MATUDS,mid,MATUSR,sname,UMAT
,INT,…
,REAL,…
,CHAR,…
Where mid is the material identification number consistent with MATUSR  and sname  is the name of this service. Integers
(real numbers, characters) can be defined and passed into EXT_UMAT  with the key word INT (REAL, CHAR) .
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Materials {
module umat {
typedef SCAInt32 DynInt32[];
typedef SCAInt64 DynInt64[];
typedef SCAReal64 DynReal64[];
typedef SCAReal64 DynReal64_2[][];
interface SCAIMDSolverUmat : SCAIService
{
SCAResult usrUmat_32( out   DynReal64_2 d,
out   DynReal64   g,EXT_UMAT User-defined Material Behavior&lt;/p&gt;
&lt;p&gt;78User Defined Services User’s Guide
User Defined Subroutines
Main Index
in    DynReal64   e,
in    DynReal64   de,
out   DynReal64   s,
in    DynReal64   t,
in    DynReal64   dt,
in    SCAInt32    ngens,
in    DynInt32    n,
in    SCAInt32    nn,
in    DynInt32    kcus,
in    DynInt32    matus,
in    SCAInt32    ndi,
in    SCAInt32    nshear,
in    DynReal64_2 disp,
in    DynReal64_2 dispt,
in    DynReal64_2 coord,
in    DynReal64_2 ffn,
in    DynReal64_2 frotn,
in    DynReal64   strechn,
in    DynReal64_2 eigvn,
in    DynReal64_2 ffn1,
in    DynReal64_2 frotn1,
in    DynReal64   strechn1,
in    DynReal64_2 eigvn1,
in    SCAInt32    ncrd,
in    SCAInt32    itel,
in    SCAInt32    ndeg,
in    SCAInt32    ndm,
in    SCAInt32    nnode,
in    SCAInt32    jtype,
in    DynInt32    lclass,
in    SCAInt32    ifr,
in    SCAInt32    ifu,
in    SCAInt32    nstats,
in    SCAInt32    isunit,
in    DynInt32    idata,
in    DynReal64   rdata,
in    DynInt32    cidata,
in    DynInt32    idataint,
in    DynReal64   rdataint,
in    DynInt32    cdataint);
SCAResult usrUmat_64( out   DynReal64_2 d,
out   DynReal64   g,
in    DynReal64   e,
in    DynReal64   de,
out   DynReal64   s,
in    DynReal64   t,
in    DynReal64   dt,
in    SCAInt64    ngens,
in    DynInt64    n,
in    SCAInt64    nn,&lt;/p&gt;
&lt;p&gt;79 CHAPTER 1
EXT_UMAT
Main Index
in    DynInt64    kcus,
in    DynInt64    matus,
in    SCAInt64    ndi,
in    SCAInt64    nshear,
in    DynReal64_2 disp,
in    DynReal64_2 dispt,
in    DynReal64_2 coord,
in    DynReal64_2 ffn,
in    DynReal64_2 frotn,
in    DynReal64   strechn,
in    DynReal64_2 eigvn,
in    DynReal64_2 ffn1,
in    DynReal64_2 frotn1,
in    DynReal64   strechn1,
in    DynReal64_2 eigvn1,
in    SCAInt64    ncrd,
in    SCAInt64    itel,
in    SCAInt64    ndeg,
in    SCAInt64    ndm,
in    SCAInt64    nnode,
in    SCAInt64    jtype,
in    DynInt64    lclass,
in    SCAInt64    ifr,
in    SCAInt64    ifu,
in    SCAInt64    nstats,
in    SCAInt64    isunit,
in    DynInt64    idata,
in    DynReal64   rdata,
in    DynInt64    cidata,
in    DynInt64    idataint,
in    DynReal64   rdataint,
in    DynInt64    cdataint);
};
}; // umat
}; // Materials
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Materials::usrUmat_32(umat::DynReal64_2&amp;amp; d, umat::DynReal64&amp;amp; g,
const umat::DynReal64&amp;amp; e, const umat::DynReal64&amp;amp; de,
umat::DynReal64&amp;amp; s, const umat::DynReal64&amp;amp; t,
const umat::DynReal64&amp;amp; dt, const SCAInt32 ngens,
const umat::DynInt32&amp;amp; n, const SCAInt32 nn,
const umat::DynInt32&amp;amp; kcus, const umat::DynInt32&amp;amp; matus,
const SCAInt32 ndi, const SCAInt32 nshear,&lt;/p&gt;
&lt;p&gt;80User Defined Services User’s Guide
User Defined Subroutines
Main Index
const umat::DynReal64_2&amp;amp; disp, const umat::DynReal64_2&amp;amp; dispt,
const umat::DynReal64_2&amp;amp; coord, const umat::DynReal64_2&amp;amp; ffn,
const umat::DynReal64_2&amp;amp; frotn, const umat::DynReal64&amp;amp; strechn,
const umat::DynReal64_2&amp;amp; eigvn, const umat::DynReal64_2&amp;amp; ffn1, const
umat::DynReal64_2&amp;amp; frotn1,
const umat::DynReal64&amp;amp; strechn1,
const umat::DynReal64_2&amp;amp; eigvn1, const SCAInt32 ncrd,
const SCAInt32 itel, const SCAInt32 ndeg, const SCAInt32 ndm,
const SCAInt32 nnode, const SCAInt32 jtype,
const umat::DynInt32&amp;amp; lclass, const SCAInt32 ifr,
const SCAInt32 ifu, const SCAInt32 nstats,
const SCAInt32 isunit, const umat::DynInt32&amp;amp; idata,
const umat::DynReal64&amp;amp; rdata, const umat::DynInt32&amp;amp; cidata,
const umat::DynInt32&amp;amp; idataint,
const umat::DynReal64&amp;amp; rdataint,
const umat::DynInt32&amp;amp; cdataint)
{
return SCASuccess;
}
SCAResult Materials::usrUmat_64(umat::DynReal64_2&amp;amp; d, umat::DynReal64&amp;amp; g,
const umat::DynReal64&amp;amp; e, const umat::DynReal64&amp;amp; de,
umat::DynReal64&amp;amp; s, const umat::DynReal64&amp;amp; t,
const umat::DynReal64&amp;amp; dt, const SCAInt64 ngens,
const umat::DynInt64&amp;amp; n, const SCAInt64 nn,
const umat::DynInt64&amp;amp; kcus, const umat::DynInt64&amp;amp; matus,
const SCAInt64 ndi, const SCAInt64 nshear,
const umat::DynReal64_2&amp;amp; disp, const umat::DynReal64_2&amp;amp; dispt,
const umat::DynReal64_2&amp;amp; coord, const umat::DynReal64_2&amp;amp; ffn,
const umat::DynReal64_2&amp;amp; frotn, const umat::DynReal64&amp;amp; strechn,
const umat::DynReal64_2&amp;amp; eigvn, const umat::DynReal64_2&amp;amp; ffn1,
const umat::DynReal64_2&amp;amp; frotn1,
const umat::DynReal64&amp;amp; strechn1,
const umat::DynReal64_2&amp;amp; eigvn1, const SCAInt64 ncrd,
const SCAInt64 itel, const SCAInt64 ndeg, const SCAInt64 ndm,
const SCAInt64 nnode, const SCAInt64 jtype,
const umat::DynInt64&amp;amp; lclass, const SCAInt64 ifr,
const SCAInt64 ifu, const SCAInt64 nstats,
const SCAInt64 isunit, const umat::DynInt64&amp;amp; idata,
const umat::DynReal64&amp;amp; rdata, const umat::DynInt64&amp;amp; cidata,
const umat::DynInt64&amp;amp; idataint,
const umat::DynReal64&amp;amp; rdataint,
const umat::DynInt64&amp;amp; cdataint)
{
return SCASuccess;
}
FORTRAN
subroutine ext_umat(d, g, e, de, s, t, dt, ngens, n, nn, kcus,&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P5</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_005/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_005/</guid>
      <description>
        
        
        &lt;p&gt;81 CHAPTER 1
EXT_UMAT
Main Index
&amp;amp;             matus, ndi, nshear, disp, dispt, coord, ffn, frotn,
&amp;amp;             strechn, eigvn, ffn1, frotn1, strechn1, eigvn1, ncrd,
&amp;amp;             itel, ndeg, ndm, nnode, jtype, lclass, ifr, ifu,
&amp;amp;             nstats, isunit, idata, rdata, cdata,
&amp;amp;             len_idata, len_rdata, len_cdata, idataint, rdataint,
&amp;amp;             cdataint, len_idataint, len_rdataint, len_cdataint,
&amp;amp;             error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: len_idataint, len_rdataint, len_cdataint
integer, intent(in)  :: ngens, nn, ndi, nshear, ncrd, itel, ndeg
integer, intent(in)  :: ndm, nnode, jtype, ifr, ifu, nstats
integer, intent(in)  :: isunit
integer, intent(out) :: error_code
integer, intent(in),  dimension(2)            :: n, kcus, matus
integer, intent(in),  dimension(2)            :: lclass
real(8), intent(out), dimension(ngens, ngens) :: d
real(8), intent(out), dimension(ngens)        :: g, s
real(8), intent(in),  dimension(ngens)        :: e, de
real(8), dimension(nstats)                    :: t, dt
real(8), intent(in),  dimension(ndeg, nnode)  :: disp, dispt
real(8), intent(in),  dimension(ndeg, nnode)  :: coord
real(8), intent(in),  dimension(itel, itel)   :: ffn, ffn1
real(8), intent(in),  dimension(itel, itel)   :: frotn, frotn1
real(8), intent(in),  dimension(itel)         :: strechn, strechn1
real(8), intent(in),  dimension(itel, itel)   :: eigvn, eigvn1
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer,          intent(in), dimension(len_idataint) :: idataint
real(8),          intent(in), dimension(len_rdataint) :: rdataint
character(len=8), intent(in), dimension(len_cdataint) :: cdataint
integer, external :: printf06
end subroutine ext_umat
Input:
e is the total elastic mechanical strain .
de is the increment of mechanical strain .
t(1) is the temperature at beginning of increment.
t(2,…) are the user defined state variables .
dt(1) is the increment of temperature .&lt;/p&gt;
&lt;p&gt;82User Defined Services User’s Guide
User Defined Subroutines
Main Index
dt(2,…) are the increments of user defined state variables .
ngens is the size of the stress-strain law .
n(1) is the element number .
nn is the integration point number .
kcus(1) is your layer number (always 1 for continuum elements).
kcus(2) is the internal layer number (always 1 for continuum element) .
matus(1) is the user material identifier .
matus(2) is the internal material identifier .
ndi is the number of direct components .
nshear is the number of shear components .
disp is the incremental displacements .
dispt is the displacements at t = tn (at assembly) and displacements at t = t n+1 (at stress recovery) .
coord is the coordinates .
ncrd is the number of coordinates .
ndeg is the number of degrees of freedom .
itel is the dimension of F and R, 2 for plane=stress and 3 for the rest of cases.
nnode is the number of node per element .
jtype is the element type .
lclass(1) is the element class .
lclass(2) is 0 for displacement element .
is 1 for lower-order Herrmann element .
ifr is set to 1 if R has been calculated .
ifu is set to 1 if STRECH  has been calculated .
nstats is the number of state variables .
isunit is the system unit .
idata is the user-supplied integer data in MATUDS .
rdata is the user-supplied real date in MATUDS .
cdata is the user-supplied character data .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata.
idataint is internal integer data :&lt;/p&gt;
&lt;p&gt;83 CHAPTER 1
EXT_UMAT
Main Index
For descriptions of stress, strain, tangent stiffness and other arguments, please refer to EXT_HYPELA2  user subroutine.idataint[1] is phase number, 4 = assembly phase, 6 = stress recovery phase
idataint[2] is converge flag, -1 = not converged , 1 = converged
rdataint is internal real data :
rdataint[1] is integration point volume
cdataint is internal character data, not used.
len_idataint is the length of idataint .
len_rdataint is the length of rdataint .
len_cdataint is the length of cdataint .
At t = tn (or the beginning of the increment):
ffn is the deformation gradient .
frotn is the rotation tensor .
strechn is the square of principal stretch ratios, ?(i)..
eigvn (i,j) is the I principal direction components for H eigenvalues.
At t = tn+1 (or the current time step)
ffn1 is the deformation gradient .
frotn1 is the rotation tensor .
strechn1 si the square of principal stretch ratios, ?(i).
eigvn1(i,j) is the I principal direction components for J eigenvalues .
Required Output:
d is the stress strain law to be formed .
g is the change in stress due to temperature effects .
s is the stress to be updated by you .
dt(2,…) is incremental state variables .
error_code is returned error code, 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;84User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
The UCOHES  user subroutine is provided to allow the user to enter a material model used by the interface elements. The
call to this user subroutine is triggered by the UCOHES  option in MATUDS  entry.
Unlike conventional stress elements, the material behavior of the interface elements is defined in terms  of stresses and
relative displacements instead of stresses and strains. The element stresses are the so called tractions and consist of one
normal and one shear stress component for 2-D elements and one normal and two shear components for 3-D elements.
The stress and relative displacement components are given in the local element coordinate system.
In order to cope with multi-axial stress states, the equivalent relative opening displacement can be used.
MATUDS,mid,MATUSR,sname,UCOHES
,INT,…
,REAL,…
,CHAR,…
Where mid is the material identification number consistent with MCOHE  and sname  is the name of this service. Integers
(real numbers, characters) can be defined and passed into EXT_UCOHES  with the key word INT (REAL, CHAR) .
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Materials {
module ucohesive {
typedef SCAInt32  DynInt32[];
typedef SCAInt64  DynInt64[];
typedef SCAReal32 DynReal32[];
typedef SCAReal64 DynReal64[];
typedef SCAInt32  DynInt32_2[][];
typedef SCAInt64  DynInt64_2[][];
typedef SCAReal32 DynReal32_2[][];
typedef SCAReal64 DynReal64_2[][];
interface SCAIMDSolverUcohesive : SCAIService
{
SCAResult usrUcohes_32( out   DynReal64_2 d,
in    DynReal64   etot,
in    DynReal64   e,
in    DynReal64   s,EXT_UCOHES User-defined Cohesive Material Behavior&lt;/p&gt;
&lt;p&gt;85 CHAPTER 1
EXT_UCOHES
Main Index
out   DynReal64   send,
in    SCAInt32    ngens,
out   DynReal64   relop,
in    DynReal64   dt,
in    DynReal64   dtdl,
in    SCAInt32    ncycle,
in    DynInt32    mdum,
in    SCAInt32    nn,
in    DynInt32    kcus,
in    DynInt32    matus,
in    DynReal64   cohprop,
in    SCAInt32    nstats,
in    SCAInt32    isunit,
in    DynInt32    idata,
in    DynReal64   rdata,
in    DynInt32    cidata,
in    DynInt32    idataint,
in    DynReal64   rdataint,
in    DynInt32    cdataint);
SCAResult usrUcohes_64( out   DynReal64_2 d,
in    DynReal64   etot,
in    DynReal64   e,
in    DynReal64   s,
out   DynReal64   send,
in    SCAInt64    ngens,
out   DynReal64   relop,
in    DynReal64   dt,
in    DynReal64   dtdl,
in    SCAInt64    ncycle,
in    DynInt64    mdum,
in    SCAInt64    nn,
in    DynInt64    kcus,
in    DynInt64    matus,
in    DynReal64   cohprop,
in    SCAInt64    nstats,
in    SCAInt64    isunit,
in    DynInt64    idata,
in    DynReal64   rdata,
in    DynInt64    cidata,
in    DynInt64    idataint,
in    DynReal64   rdataint,
in    DynInt64    cdataint);
};
}; // ucohesive
}; // Materials
}; // Uds
}; // Obj
}; // MDSolver&lt;/p&gt;
&lt;p&gt;86User Defined Services User’s Guide
User Defined Subroutines
Main Index
}; // SCA
C++
SCAResult Materials::usrUcohes_32(ucohesive::DynReal64_2&amp;amp; d,
const ucohesive::DynReal64&amp;amp; etot,
const ucohesive::DynReal64&amp;amp; e, const ucohesive::DynReal64&amp;amp; s,
ucohesive::DynReal64&amp;amp; send, const SCAInt32 ngens,
ucohesive::DynReal64&amp;amp; relop, const ucohesive::DynReal64&amp;amp; dt,
const ucohesive::DynReal64&amp;amp; dtdl, const SCAInt32 ncycle,
const ucohesive::DynInt32&amp;amp; mdum, const SCAInt32 nn,
const ucohesive::DynInt32&amp;amp; kcus,
const ucohesive::DynInt32&amp;amp; matus,
const ucohesive::DynReal64&amp;amp; cohprop, const SCAInt32 nstats,
const SCAInt32 isunit, const ucohesive::DynInt32&amp;amp; idata,
const ucohesive::DynReal64&amp;amp; rdata,
const ucohesive::DynInt32&amp;amp; cidata,
const ucohesive::DynInt32&amp;amp; idataint,
const ucohesive::DynReal64&amp;amp; rdataint,
const ucohesive::DynInt32&amp;amp; cdataint)
{
return SCASuccess;
}
SCAResult Materials::usrUcohes_64(ucohesive::DynReal64_2&amp;amp; d,
const ucohesive::DynReal64&amp;amp; etot,
const ucohesive::DynReal64&amp;amp; e,
const ucohesive::DynReal64&amp;amp; s, ucohesive::DynReal64&amp;amp; send,
const SCAInt64 ngens, ucohesive::DynReal64&amp;amp; relop,
const ucohesive::DynReal64&amp;amp; dt,
const ucohesive::DynReal64&amp;amp; dtdl, const SCAInt64 ncycle,
const ucohesive::DynInt64&amp;amp; mdum, const SCAInt64 nn,
const ucohesive::DynInt64&amp;amp; kcus,
const ucohesive::DynInt64&amp;amp; matus,
const ucohesive::DynReal64&amp;amp; cohprop, const SCAInt64 nstats,
const SCAInt64 isunit, const ucohesive::DynInt64&amp;amp; idata,
const ucohesive::DynReal64&amp;amp; rdata,
const ucohesive::DynInt64&amp;amp; cidata,
const ucohesive::DynInt64&amp;amp; idataint,
const ucohesive::DynReal64&amp;amp; rdataint,
const ucohesive::DynInt64&amp;amp; cdataint)
{
return SCASuccess;
}
FORTRAN
subroutine ext_ucohes(d, etot, e, s, send, ngens, relop, dt,
&amp;amp;             dtdl, ncycle, mdum, nn, kcus, matus, cohprop, nstats,
&amp;amp;             isunit, idata, rdata, cdata,&lt;/p&gt;
&lt;p&gt;87 CHAPTER 1
EXT_UCOHES
Main Index
&amp;amp;             len_d_i, len_d_j, len_etot, len_e, len_s, len_send,
&amp;amp;             len_relop, len_dt, len_dtdl, len_mdum, len_kcus,
&amp;amp;             len_matus, len_cohprop, len_idata, len_rdata,
&amp;amp;             len_cdata, idataint, rdataint, cdataint,
&amp;amp;             len_idataint, len_rdataint, len_cdataint, error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: len_idataint, len_rdataint, len_cdataint
integer, intent(in)  :: ngens, ncycle, nn, nstats, isunit
integer, intent(in)  :: len_d_i, len_d_j, len_etot, len_e, len_s
integer, intent(in)  :: len_send, len_relop, len_dt, len_dtdl
integer, intent(in)  :: len_mdum, len_kcus, len_matus, len_cohprop
integer, intent(out) :: error_code
integer, intent(in),  dimension(len_kcus)         :: kcus
integer, intent(in),  dimension(len_matus)        :: matus
integer, intent(in),  dimension(len_mdum)         :: mdum
real(8), intent(out), dimension(len_d_i, len_d_j) :: d
real(8), intent(in),  dimension(len_etot)         :: etot
real(8), intent(in),  dimension(len_e)            :: e
real(8), intent(in),  dimension(len_s)            :: s
real(8), intent(out), dimension(len_send)         :: send
real(8), intent(out), dimension(len_relop)        :: relop
real(8),  dimension(len_dt)           :: dt
real(8), intent(in),  dimension(len_dtdl)         :: dtdl
real(8), intent(in),  dimension(len_cohprop)      :: cohprop
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer,          intent(in), dimension(len_idataint) :: idataint
real(8),          intent(in), dimension(len_rdataint) :: rdataint
character(len=8), intent(in), dimension(len_cdataint) :: cdataint
integer, external :: printf06
end subroutine ext_ucohes
Input:
etot is the accumulated total relative displacements at beginning of increment .
e is the current incremental relative displacements .
s is the accumulated stress at beginning of increment .
ngens is the number of stress components .
dt is the state variables; temperature is the first state variable .&lt;/p&gt;
&lt;p&gt;88User Defined Services User’s Guide
User Defined Subroutines
Main Index
dtdl is the incremental state variables .
ncycle is the current cycle number.
mdum(1) is the user element number .
mdum(2) is the internal element number .
nn is the integration point number .
kcus(1) is the user layer number .
kcus(2) is the internal layer number .
matus(1) is the user material identifier .
matus(2) is the internal material identifier .
cohprop is the cohesive material properties .
nstats is the number of state variables .
isunit is the system unit .
idata is user-supplied integer data in MATUDS .
rdata is user-supplied real date in MATUDS .
cdata is user-supplied character data in MATUDS .
len_d_i is the first dimension length of D.
len_d_j is the second dimension length of D.
len_etot is the length of ETOT .
len_e is the length of E.
len_s is the length of S.
len_send is the length of SEND .
len_relop is the length of RELOP .
len_dt is the length of DT.
len_dtdl is the length of DTDL .
len_mdum is the length of MDUM .
len_kcus is the length of KCUS .
len_matus is the length of MATUS .
len_cohprop is the length of COHPROP .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
idataint is internal integer data&lt;/p&gt;
&lt;p&gt;89 CHAPTER 1
EXT_UCOHES
Main Index
idataint[1] is phase number, 4 = assembly phase, 6 = stress recovery phase.
idataint[2] is convergence flag, -1 = not converged , 1 = converged.
rdataint is internal real data
rdataint[1] is integration point volume
cdataint is internal character data, not used.
len_idataint is the length of idataint
len_rdataint is the length of rdataint
len_cdataint is the length of cdataint
Required Output:
d is the matrix defining the relation between the stresses and the relative displacements .
send is the total stress at end of increment .
dtdl(2,…) is incremental state variables .
error_code is returned error code; 0 = success, otherwise fail.
Optional Output:
relop(1) is the equivalent relative opening displacement .
relop(2) is the damage parameter .&lt;/p&gt;
&lt;p&gt;90User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
This notification user subroutine will be called at some specific analyzing points, including the beginning of load case, the
beginning of increment, the end of increment and the end of load case. The calling point, current subcase number, step
number, increment number, current time, incremental time and a RESTART  flag are passed in the call. The GENUDS  entry
is used to define service that has implemented the notification subroutine. In addition, user can define integer, real and
character type data in GENUDS , and these user supplied data will be passed as arguments to the subroutine.
GENUDS, srv_id
,INT,…
,REAL,…
,CHAR,…
where srv_id  is the service identifier defined in a CONNECT SERVICE  statement, and the service has implemented the
notification subroutine in the runtime info interface. Integers (real numbers, characters) can be defined with the key word
INT (REAL, CHAR)  and these supplied data will be passed to EXT_NOTIFY  when it gets called.
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
typedef SCAChar   DynChar[];
typedef SCAInt32  DynInt32[];
typedef SCAInt64  DynInt64[];
typedef SCAReal32 DynReal32[];
typedef SCAReal64 DynReal64[];
interface SCAIMDSolverRuntimeInfo : SCAIService
{
SCAResult notify_32(in SCAInt32 stage,
in SCAInt32 subcase,
in SCAInt32 step,
in SCAInt32 increment,
in SCAReal32 curr_time,
in SCAReal32 incr_time,
in SCABool restart,
in DynInt32 idata,
in DynReal32 rdata,
in DynInt32 cdata);
SCAResult notify_64(in SCAInt64 stage,
in SCAInt64 subcase,EXT_NOTIFY User-defined Runtime Info Subroutine&lt;/p&gt;
&lt;p&gt;91 CHAPTER 1
EXT_NOTIFY
Main Index
in SCAInt64 step,
in SCAInt64 increment,
in SCAReal64 curr_time,
in SCAReal64 incr_time,
in SCABool restart,
in DynInt64 idata,
in DynReal64 rdata,
in DynInt64 cdata);
};
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult GeneralInfo::notify_32(const SCAInt32 stage, const SCAInt32 subcase,
const SCAInt32 step, const SCAInt32 increment,
const SCAReal32 curr_time, const SCAReal32 incr_time,
const SCABool restart, const DynInt32&amp;amp; idata,
const DynReal32&amp;amp; rdata, const DynInt32&amp;amp; cdata)
{
return SCASuccess;
}
SCAResult GeneralInfo::notify_64(const SCAInt64 stage, const SCAInt64 subcase,
const SCAInt64 step, const SCAInt64 increment,
const SCAReal64 curr_time, const SCAReal64 incr_time,
const SCABool restart, const DynInt64&amp;amp; idata,
const DynReal64&amp;amp; rdata, const DynInt64&amp;amp; cdata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_notify(stage, subcase, step, increment, curr_time,
&amp;amp;             incr_time, restart, idata, rdata, cdata, nid, nrd,
&amp;amp;             ncd, err_code)
implicit none
integer, intent(in)  :: stage, subcase, step, increment, restart
real, intent(in) :: curr_time, incr_time
integer, intent(in)  :: nid, nrd, ncd
integer, intent(in), dimension(nid) :: idata
real, intent(in), dimension(nrd) :: rdata
character(len=8), intent(in), dimension(ncd) :: cdata&lt;/p&gt;
&lt;p&gt;92User Defined Services User’s Guide
User Defined Subroutines
Main Index
integer, intent(out) :: err_code
integer, external :: printf06
end subroutine ext_notify
Input:
stage is the analyzing point at which this subroutine is called :
1 = start of step case
2 = end of step case
4 = start of increment
8 = end of increment
subcase is the subcase number .
step is the step number .
increment is the increment number .
curr_time is the current time .
incr_time is the incremental time .
restart is the restart flag .
idata is user supplied integer data in GENUDS .
rdata is user supplied real date in GENUDS .
cdata is user supplied character data in GENUDS .
nid is the length of idata .
nrd is the length of rdata .
ncd is the length of cdata .
Required Output:
error_code is returned error code, 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;93 CHAPTER 1
EXT_UELASTOMER
Main Index
Description
This user subroutine allows definition of the user’s own hyperelastic models. The subroutine is activated by MATHE  along
with MATUDS  bulk data options and must be used with NLMOPTS,LRGSTRN,2  within the framework of updated
Lagrange formulation.
In MATHE , user needs to set Model=GHEMi , where i=1,6 defining different types of hyperelastic models.&lt;br&gt;
Foam Models
For compressible foam materials, four types of strain energy functions can be defined using the EXT_UELASTOMER  user
subroutine, depending on the Model field entered in MATHE :
1.Model=GHEM1: Invariant-based model
2.Model=GHEM2: Principal-stretch-based model
3.Model=GHEM3: Invariant-based model with volumetric and deviatoric split
4.Model=GHEM4: Principal-stretch-based model with volumetric and deviatoric split
I1 , I2, and I3 (1, 2, and 3) are strain invariants (principal stretches), and I1 and I2 (1, 2, and 3) are their deviatoric
parts, defined by  and  ; J is the determinant of the deformation gradient.
MSC Nastran uses conventional displacement elements for user-defined compressible foam models ( GHEMi, i=1,4 ). No
volumetric constraints are taken into account. For incompressible or nearly incompressible rubber-like materials, rubber
model with MODEL=GHEM5 or GHEM6 should be used.
Rubber Models
Because rubber-like materials are nearly incompressible, it is numerically more efficient to split the energy function into a
volumetric part and a deviatoric part. A mixed formulation, which treats hydrostatic pressure as an independent variable,
is used in MSC Nastran to overcome the numerical difficulties coming from the volumetric constraints. A linear
relationship between pressure and volumetric strain is a presupposition in the mixed formulation. Therefore, requiring only
the deviatoric part of energy function needs to be defined in the user subroutine for rubber-like materials.
Invariant-based rubber models can be defined using the EXT_UELASTOMER  user subroutine if the Model field in MATHE&lt;br&gt;
is set to GHEM5  (Mooney type model) or GHEM6  (Ogden type model):
5.Model=GHEM5 : Invariant-based model, deviatoric part onlyEXT_UELASTOMER Generalized Strain Energy Function
W WI1I2I3,,() =
W Wl1l2l3,,( ) =
WWdevI1I2,() UJ()+ =
WWdevl1l2l3,,() UJ()+ =
I1 J23/–I1 = I2 J43/–I2 = i J13/–i = i 123,,=&lt;/p&gt;
&lt;p&gt;94User Defined Services User’s Guide
User Defined Subroutines
Main Index
6.Model=GHEM6 : Principal-stretch-based model, deviatoric part only
MATUDS  defines the service name corresponding to the material, and the data (integer, real and characters) used to define
the material in the user subroutine. It should look like the following for EXT_UELASTOMER  application:
MATUDS,mid,MATHE,sname,UELASTOM,
,INT,…
,REAL,…
,CHAR,…
where mid is the material ID of MATHE , and sname  is the service name. Integers (real numbers, characters) can be defined
and passed into EXT_UELASTOMER  with the key word INT (REAL, CHAR) .
FORMAT
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Materials {
module uelastomer {
typedef SCAInt32 DynInt32[];
typedef SCAInt64 DynInt64[];
typedef SCAReal64 DynReal64[];
interface SCAIMDSolverUelastomer : SCAIService
{
SCAResult usrUelastomer_32( in    SCAInt32   iflag,
in    DynInt32   m,
in    SCAInt32   nn,
in    DynInt32   matus,
in    DynReal64  be,
in    SCAReal64  x1,
in    SCAReal64  x2,
in    SCAReal64  x3,
in    SCAReal64  detft,
out   SCAReal64  enerd,
out   SCAReal64  w1,Note:   If MODEL=GHEM5  or GHEM6 , only the deviatoric part of the energy function is defined via the
EXT_UELASTOMER  user subroutine. The volumetric part is calculated internally by MSC Nastran. For this
purpose, the bulk modulus MUST be defined with MATHE  bulk data option.WWdevI1I2,() =
WWdevl1l2l3,,() =&lt;/p&gt;
&lt;p&gt;95 CHAPTER 1
EXT_UELASTOMER
Main Index
out   SCAReal64  w2,
out   SCAReal64  w3,
out   SCAReal64  w11,
out   SCAReal64  w22,
out   SCAReal64  w33,
out   SCAReal64  w12,
out   SCAReal64  w23,
out   SCAReal64  w31,
out   SCAReal64  dudj,
out   SCAReal64  du2dj,
in    DynReal64  dt,
in    DynReal64  dtdl,
in    SCAInt32   nstats,
in    SCAInt32   isunit,
in    DynInt32   idata,
in    DynReal64  rdata,
in    DynInt32   cidata );
SCAResult usrUelastomer_64( in    SCAInt64   iflag,
in    DynInt64   m,
in    SCAInt64   nn,
in    DynInt64   matus,
in    DynReal64  be,
in    SCAReal64  x1,
in    SCAReal64  x2,
in    SCAReal64  x3,
in    SCAReal64  detft,
out   SCAReal64  enerd,
out   SCAReal64  w1,
out   SCAReal64  w2,
out   SCAReal64  w3,
out   SCAReal64  w11,
out   SCAReal64  w22,
out   SCAReal64  w33,
out   SCAReal64  w12,
out   SCAReal64  w23,
out   SCAReal64  w31,
out   SCAReal64  dudj,
out   SCAReal64  du2dj,
in    DynReal64  dt,
in    DynReal64  dtdl,
in    SCAInt64   nstats,
in    SCAInt64   isunit,
in    DynInt64   idata,
in    DynReal64  rdata,
in    DynInt64   cidata );
};
}; // uelastomer
}; // Materials
}; // Uds&lt;/p&gt;
&lt;p&gt;96User Defined Services User’s Guide
User Defined Subroutines
Main Index
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Materials::usrUelastomer_32(const SCAInt32 iflag, const uelastomer::DynInt32&amp;amp; m, const SCAInt32 nn,
const uelastomer::DynInt32&amp;amp; matus, const uelastomer::DynReal64&amp;amp; be, const SCAReal64 x1,
const SCAReal64 x2, const SCAReal64 x3, const SCAReal64 detft, SCAReal64&amp;amp; enerd,
SCAReal64&amp;amp; w1, SCAReal64&amp;amp; w2, SCAReal64&amp;amp; w3, SCAReal64&amp;amp; w11, SCAReal64&amp;amp; w22,
SCAReal64&amp;amp; w33, SCAReal64&amp;amp; w12, SCAReal64&amp;amp; w23, SCAReal64&amp;amp; w31, SCAReal64&amp;amp; dudj,
SCAReal64&amp;amp; du2dj, const uelastomer::DynReal64&amp;amp; dt, const uelastomer::DynReal64&amp;amp; dtdl,
const SCAInt32 nstats, const SCAInt32 isunit, const uelastomer::DynInt32&amp;amp; idata,
const uelastomer::DynReal64&amp;amp; rdata, const uelastomer::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}&lt;/p&gt;
&lt;p&gt;SCAResult Materials::usrUelastomer_64(const SCAInt64 iflag, const uelastomer::DynInt64&amp;amp; m, const SCAInt64 nn,
const uelastomer::DynInt64&amp;amp; matus, const uelastomer::DynReal64&amp;amp; be, const SCAReal64 x1,
const SCAReal64 x2, const SCAReal64 x3, const SCAReal64 detft, SCAReal64&amp;amp; enerd,
SCAReal64&amp;amp; w1, SCAReal64&amp;amp; w2, SCAReal64&amp;amp; w3, SCAReal64&amp;amp; w11, SCAReal64&amp;amp; w22,
SCAReal64&amp;amp; w33, SCAReal64&amp;amp; w12, SCAReal64&amp;amp; w23, SCAReal64&amp;amp; w31, SCAReal64&amp;amp; dudj,
SCAReal64&amp;amp; du2dj, const uelastomer::DynReal64&amp;amp; dt, const uelastomer::DynReal64&amp;amp; dtdl,
const SCAInt64 nstats, const SCAInt64 isunit, const uelastomer::DynInt64&amp;amp; idata,
const uelastomer::DynReal64&amp;amp; rdata, const uelastomer::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_uelastomer(iflag, m, nn, matus, be, x1, x2, x3,
&amp;amp;             detft, enerd, w1, w2, w3, w11, w22, w33, w12, w23,
&amp;amp;             w31, dudj, du2dj, dt, dtdl, nstats, isunit,
&amp;amp;             idata, rdata, cdata, len_idata, len_rdata,
&amp;amp;             len_cdata, error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: iflag, nn, nstats, isunit
integer, intent(out) :: error_code
real(8), intent(in)  :: x1, x2, x3, detft
real(8), intent(out) :: enerd, w1, w2, w3, w11, w22, w33, w12, w23
real(8), intent(out) :: w31, dudj, du2dj
integer, intent(in), dimension(2)      :: m, matus
real(8), intent(in), dimension(6)      :: be
real(8), intent(in), dimension(nstats) :: dt, dtdl
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
end subroutine ext_uelastomer
Input:
iflag Hyperelastic mode to be defined:&lt;/p&gt;
&lt;p&gt;97 CHAPTER 1
EXT_UELASTOMER
Main Index
= 1 Foam model with energy function in terms of invariants ( GHEM1 )
= 2 Foam model with energy function in terms of principal stretches ( GHEM2 )
= 3 Foam model with energy function in terms of invariants with deviatoric split ( GHEM3 )
= 4 Foam model with energy function in terms of principal stretches with deviatoric split ( GHEM4 )
= 5 Rubber model with energy function in terms of invariants deviatoric part only ( GHEM5 ). The
bulk modulus MUST be defined with MATHE .
= 6 Rubber model with energy function in terms of principal stretches deviatoric part only
(GHEM6 ). The bulk modulus MUST be defined with MATHE .
m(1) is the user element number.
m(2) is the internal element number.
nn is the integration point number.
mats(1) is the user material identification number.
mats(2) is the internal material identification number.
be is the left Cauchy-Green deformation tensor.
x1,x2,x3 if iflag=1 : invariants of be
if iflag=2 : principal stretches
if iflag=3 : deviatoric part of invariants of be
if iflag=4 : deviatoric principal stretches
if iflag=5 : deviatoric part of invariants of be
if iflag=6 : deviatoric principal stretches
detft is the determinate of deformation gradient.
dt is the array of state variables (temperature at first) at .
dtdl is the incremental state variables.
nstats is the number of state variables.
isunit is the system units:
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
idata is the user supplied integer data in MATUDS .
rdata is the user supplied real data in MATUDS .
cdata is user supplied character data in MATUDS .tn&lt;/p&gt;
&lt;p&gt;98User Defined Services User’s Guide
User Defined Subroutines
Main Index
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
enerd energy density at
error_code is returned error code; 0 = success, otherwise fail.
Foam Rubber
iflag = 1 iflag = 2 iflag = 3 iflag = 4 iflag =5 iflag =6
W1
W2
W3 N/A N/A
W11
W22
W33 N/A N/A
W12
W23 N/A N/Atn1+
¶W
¶I1&amp;mdash;&amp;mdash;&amp;ndash;¶W
¶l1&amp;mdash;&amp;mdash;&amp;mdash;¶W
¶I1&amp;mdash;&amp;mdash;&amp;ndash;¶W
¶l1&amp;mdash;&amp;mdash;&amp;mdash;¶W
¶I1&amp;mdash;&amp;mdash;&amp;ndash;¶W
¶l1&amp;mdash;&amp;mdash;&amp;mdash;
¶W
¶I2&amp;mdash;&amp;mdash;&amp;ndash;¶W
¶l2&amp;mdash;&amp;mdash;&amp;mdash;¶W
¶I2&amp;mdash;&amp;mdash;&amp;ndash;¶W
¶l2&amp;mdash;&amp;mdash;&amp;mdash;¶W
¶I2&amp;mdash;&amp;mdash;&amp;ndash;¶W
¶l2&amp;mdash;&amp;mdash;&amp;mdash;
¶W
¶I3&amp;mdash;&amp;mdash;&amp;ndash;¶W
¶l3&amp;mdash;&amp;mdash;&amp;mdash;¶W
¶l3&amp;mdash;&amp;mdash;&amp;mdash;¶W
¶l3&amp;mdash;&amp;mdash;&amp;mdash;
¶2W
¶I12&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶l12&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶I12&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶l12&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶I12&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶l12&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
¶2W
¶I22&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶l22&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶I22&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶l22&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶I22&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶l22&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
¶2W
¶I32&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶l32&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶l32&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;¶2W
¶l32&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
¶2W
¶I1¶I2&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶l1¶l2&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶I1¶I2&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶l1¶l2&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶I1¶I2&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶l1¶l2&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
¶2W
¶I2¶I3&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶l2¶l3&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶l2¶l3&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶l2¶l3&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/p&gt;
&lt;p&gt;99 CHAPTER 1
EXT_UELASTOMER
Main Index
Example:
To define a rubber material based on strain energy function (Mooney model):
W = C1 (I1-3) + C2(I2-3)
with a bulk modulus K, the input file should have MATHE  and MATUDS  look like the following:
MATHE,2,GHEM5,,K,&lt;br&gt;
MATUDS,2,MATHE,Sname,UELASTOM,&lt;br&gt;
,REAL, C1 ,C2&lt;br&gt;
where:&lt;br&gt;
Sname  is the material service name .
The code inserted in EXT_UELASTOMER  should be the following:
W1=RDATA(1)
W2=RDATA(2)
ENERD=RDARA(1) *(X1-3.d0) + RDATA(2) *(X2-3.d0)W31 N/A N/A
dudj N/A N/A N/A N/A
du2dj N/A N/A N/A N/AFoam Rubber
iflag = 1 iflag = 2 iflag = 3 iflag = 4 iflag =5 iflag =6
¶2W
¶I3¶I1&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶l3¶l1&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶l3¶l1&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-¶2W
¶l3¶l1&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
¶U
¶J&amp;mdash;&amp;mdash;-¶U
¶J&amp;mdash;&amp;mdash;-
¶2U
¶J2&amp;mdash;&amp;mdash;&amp;mdash;-¶2U
¶J2&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/p&gt;
&lt;p&gt;100 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
The EXT_ORIENT  user subroutine is used to supply a preferred orientation so that anisotropic material constants can be
defined in this orientation. This user subroutine can be activated by anisotropic material definition options, and/or the
MATORT  option, along with MATUDS  option.
MATUDS  defines the service name corresponding to the material, and the data (integer, real and characters) used to define
the material properties in the user subroutine. It should look like the following for EXT_ORIENT  application:
MATUDS,mid,matopt,sname,ORIENT,
,INT,…
,REAL,…
,CHAR,…
where  matopt  is the material bulk data option such as MAT2  , MAT8 , or MATORT ; mid is the material identification number
consistent with the corresponding matopts ; and sname  is the name of this service. Integers (real numbers, characters) can
be defined and passed into EXT_ORIENT  with the key word INT (REAL, CHAR) .
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Materials {
module orient {
typedef SCAInt32  DynInt32[];
typedef SCAInt64  DynInt64[];
typedef SCAReal32 DynReal32[];
typedef SCAReal64 DynReal64[];
typedef SCAInt32  DynInt32_2[][];
typedef SCAInt64  DynInt64_2[][];
typedef SCAReal32 DynReal32_2[][];
typedef SCAReal64 DynReal64_2[][];
interface SCAIMDSolverOrient : SCAIService
{
SCAResult usrOrient_32( in    DynInt32    n,
in    SCAInt32    nn,
in    DynInt32    kcus,
out   DynReal64_2 g,
in    DynInt32    matus,
in    SCAInt32    isunit,EXT_ORIENT Specification of Preferred Orientation&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P6</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_006/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_006/</guid>
      <description>
        
        
        &lt;p&gt;101 CHAPTER 1
EXT_ORIENT
Main Index
in    DynReal64   xipt,
in    SCAInt32    ncrd,
in    DynInt32    idata,
in    DynReal64   rdata,
in    DynInt32    cidata);
SCAResult usrOrient_64( in    DynInt64    n,
in    SCAInt64    nn,
in    DynInt64    kcus,
out   DynReal64_2 g,
in    DynInt64    matus,
in    SCAInt64    isunit,
in    DynReal64   xipt,
in    SCAInt64    ncrd,
in    DynInt64    idata,
in    DynReal64   rdata,
in    DynInt64    cidata);
};
}; // orient
}; // Materials
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Materials::usrOrient_32(const orient::DynInt32&amp;amp; n, const SCAInt32 nn, const orient::DynInt32&amp;amp; kcus,
orient::DynReal64_2&amp;amp; g, const orient::DynInt32&amp;amp; matus, const SCAInt32 isunit,
const orient::DynReal64&amp;amp; xipt, const SCAInt32 ncrd, const orient::DynInt32&amp;amp; idata,
const orient::DynReal64&amp;amp; rdata, const orient::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}
SCAResult Materials::usrOrient_64(const orient::DynInt64&amp;amp; n, const SCAInt64 nn, const orient::DynInt64&amp;amp; kcus,
orient::DynReal64_2&amp;amp; g, const orient::DynInt64&amp;amp; matus, const SCAInt64 isunit,
const orient::DynReal64&amp;amp; xipt, const SCAInt64 ncrd, const orient::DynInt64&amp;amp; idata,
const orient::DynReal64&amp;amp; rdata, const orient::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_orient(n, nn, kcus, g, matus, isunit, xipt, ncrd,
&amp;amp;             idata, rdata, cdata, len_idata, len_rdata,
&amp;amp;             len_cdata, error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: nn, isunit, ncrd
integer, intent(out) :: error_code
integer, intent(in),  dimension(2)    :: n, kcus, matus
real(8), intent(out), dimension(3, 3) :: g
real(8), intent(in),  dimension(ncrd) :: xipt&lt;/p&gt;
&lt;p&gt;102 User Defined Services User’s Guide
User Defined Subroutines
Main Index
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
end subroutine ext_orient&lt;/p&gt;
&lt;p&gt;All parameters except G are passed in by the program – the user must supply the G matrix. G is the transformation to the
preferred orientation from the usual program orientation:Input:
n(1) is the user element number.
n(2) is the internal element number.
nn is the integration point number.
kcus(1) is your layer number (always 1 for continuum elements).
kcus(2) is the internal layer number (always 1 for continuum element).
matus(1) is user material ID.
matus(2) is internal material ID.
isunit is system units:
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
xipt is integration point coordinate (does not include layer offset).
ncrd is number of coordinates.
idata is user supplied integer data in MATUDS .
rdata is user supplied real data in MATUDS .
cdata is user supplied character data in MATUDS .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
g is the transformation matrix to be defined here.
error_code is returned error code, 0 = success, otherwise fail.&lt;/p&gt;
&lt;h1&gt;103 CHAPTER 1
EXT_ORIENT
Main Index
where:
For curvilinear systems, G is defined by . For planar transformations, ; ;
must be given.v is the vector in the program system.
v&amp;rsquo; is the vector in the preferred system.
Note:   This user subroutine should not be used if the user desires that the material orientation be a design variable.
Use PCOMP  option instead.v&#39;1
v&#39;2
v&#39;3
G11G12G13
G21G22G23
G31G32G33v1
v2
v3&lt;/h1&gt;&lt;p&gt;GIJ, gji= G3I, GI3, 0 = = G33, 1.0=
I 12,=&lt;/p&gt;
&lt;p&gt;104 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
The EXT_CRPLAW  user subroutine allows the user to specify the increment of creep strain.
The use of such a user subroutine is flagged through bulk data option MATUDS . This user subroutine is called as required
during the analysis because of possible re-cycling due to non-convergence. The number of times the user subroutine is called
in each increment is not fixed.
MATUDS  defines the service name corresponding to the material, and the data (integer, real and characters) used to define
the material properties in the user subroutine. It should look like the following for EXT_CRPLAW  application:
MATUDS,mid,matopt,sname,CRPLAW,
,INT,…
,REAL,…
,CHAR,…
where  matopt  is the material bulk data option such as MAT1  or MATVP , mid is the material identification number
consistent with the corresponding matopts , and sname  is the name of this service. Integers (real numbers, characters) can
be defined and passed into EXT_CRPLAW  with the key word INT (REAL, CHAR) .
MSC Nastran allows the user to input his own creep law through the EXT_CRPLAW  user subroutine. The assumed form
of the law is:
where:
Format
IDL
module SCA {
module MDSolver {
module Obj {EXT_CRPLAW Input of Special Creep Law
is the equivalent creep strain rate, in uniaxial tension.
is the current equivalent (J) stress, normalized for uniaxial tension.
T is the current total temperature.
t is the current total time.
is the current total equivalent creep strain, normalized for uniaxial tension.
p is the hydrostatic stress.
are the state variables. MSC Nastran requires the user to program his creep law so that an equivalent creep
strain increment is defined.e·cfsTtecpa1a2etc ,,,,, , ,()=
e·c
s
ec
a1a2etc.,,&lt;/p&gt;
&lt;p&gt;105 CHAPTER 1
EXT_CRPLAW
Main Index
module Uds {
module Materials {
module crplaw {
typedef SCAInt32  DynInt32[];
typedef SCAInt64  DynInt64[];
typedef SCAReal32 DynReal32[];
typedef SCAReal64 DynReal64[];
typedef SCAInt32  DynInt32_2[][];
typedef SCAInt64  DynInt64_2[][];
typedef SCAReal32 DynReal32_2[][];
typedef SCAReal64 DynReal64_2[][];
interface SCAIMDSolverCrplaw : SCAIService
{
SCAResult usrCrplaw_32( in    SCAReal64 eqcp,
out   SCAReal64 eqcpnc,
in    DynReal64 s,
in    DynReal64 crpe,
in    DynReal64 t,
in    DynReal64 dt,
in    SCAReal64 timinc,
in    SCAReal64 cptim,
in    SCAInt32  m,
in    SCAInt32  nn,
in    DynInt32  kcus,
in    DynInt32  matus,
in    SCAInt32  ndi,
in    SCAInt32  nshear,
in    SCAInt32  nstats,
in    SCAInt32  isunit,
in    DynInt32  idata,
in    DynReal64 rdata,
in    DynInt32  cidata);
SCAResult usrCrplaw_64( in    SCAReal64 eqcp,
out   SCAReal64 eqcpnc,
in    DynReal64 s,
in    DynReal64 crpe,
in    DynReal64 t,
in    DynReal64 dt,
in    SCAReal64 timinc,
in    SCAReal64 cptim,
in    SCAInt64  m,
in    SCAInt64  nn,
in    DynInt64  kcus,
in    DynInt64  matus,
in    SCAInt64  ndi,
in    SCAInt64  nshear,
in    SCAInt64  nstats,&lt;/p&gt;
&lt;p&gt;106 User Defined Services User’s Guide
User Defined Subroutines
Main Index
in    SCAInt64  isunit,
in    DynInt64  idata,
in    DynReal64 rdata,
in    DynInt64  cidata);
};
}; // crplaw
}; // Materials
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Materials::usrCrplaw_32(const SCAReal64 eqcp, SCAReal64&amp;amp; eqcpnc, const crplaw::DynReal64&amp;amp; s,
const crplaw::DynReal64&amp;amp; crpe, const crplaw::DynReal64&amp;amp; t, const crplaw::DynReal64&amp;amp; dt,
const SCAReal64 timinc, const SCAReal64 cptim, const SCAInt32 m, const SCAInt32 nn,
const crplaw::DynInt32&amp;amp; kcus, const crplaw::DynInt32&amp;amp; matus, const SCAInt32 ndi,
const SCAInt32 nshear, const SCAInt32 nstats, const SCAInt32 isunit,
const crplaw::DynInt32&amp;amp; idata, const crplaw::DynReal64&amp;amp; rdata, const crplaw::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}&lt;/p&gt;
&lt;p&gt;SCAResult Materials::usrCrplaw_64(const SCAReal64 eqcp, SCAReal64&amp;amp; eqcpnc, const crplaw::DynReal64&amp;amp; s,
const crplaw::DynReal64&amp;amp; crpe, const crplaw::DynReal64&amp;amp; t, const crplaw::DynReal64&amp;amp; dt,
const SCAReal64 timinc, const SCAReal64 cptim, const SCAInt64 m, const SCAInt64 nn,
const crplaw::DynInt64&amp;amp; kcus, const crplaw::DynInt64&amp;amp; matus, const SCAInt64 ndi,
const SCAInt64 nshear, const SCAInt64 nstats, const SCAInt64 isunit,
const crplaw::DynInt64&amp;amp; idata, const crplaw::DynReal64&amp;amp; rdata, const crplaw::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_crplaw(eqcp, eqcpnc, s, crpe, t, dt, dtdl, timinc,
&amp;amp;             cptim, m, nn, kcus, matus, ndi, nshear, nstats,
&amp;amp;             ncomp, isunit, idata, rdata, cdata, len_idata,
&amp;amp;             len_rdata, len_cdata, error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: m, nn, ndi, nshear, nstats, ncomp, isunit
integer, intent(out) :: error_code
real(8), intent(in)  :: eqcp, timinc, cptim
real(8), intent(out) :: eqcpnc
integer, intent(in), dimension(2)      :: kcus, matus
real(8), intent(in), dimension(ncomp)  :: s, crpe
real(8), intent(in), dimension(3)      :: t
real(8), intent(in), dimension(nstats) :: dt, dtdl
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
end subroutine ext_crplaw&lt;/p&gt;
&lt;h1&gt;107 CHAPTER 1
EXT_CRPLAW
Main Index
Input:
eqcp is passed in as total equivalent creep strain.
str is the stress array.
crpe is the incremental creep strain array. If you want to define a creep strain law not following the normality
condition, the creep strain increment can be defined here.
t(1) is the current total equivalent (J2) stress.
t(2) is the current total hydrostatic stress.
dt(1) is the current total temperature.
timinc is the current time increment.
cptim is the current total time.
m is the current element number.
nn is the integration point number.
kcus(1) is your layer number (always 1 for continuum elements).
kcus(2) is the internal layer number (always 1 for continuum element).
matus(1) is the user material ID.
matus(2) is the internal material identifier.
ndi is the number of direct components of strain.
nshear is the number of shear components of strain.
dtdl(1) is increment of temperature.
nstats is number of state variables.
ncomp is number of components.
isunit is system units:
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
idata is user supplied integer data in MATUDS.
rdata is user supplied real data in MATUDS.
cdata is user supplied character data in MATUDS.
len_idata is the length of idata .ecS2
3&amp;mdash;DecijDecij 12⁄&lt;/h1&gt;&lt;p&gt;108 User Defined Services User’s Guide
User Defined Subroutines
Main Index
The simplest way to define a creep strain increment from a given rate law  is to multiply by t, the time
increment:
Example:
We wish to use the creep law (where A=1.23e-10 and B=4.5) for material 2 defined by MAT1 and MATVP:
The input would like:
MATVP,2,0
MATUDS,2,MAT1,sname,CRPLAW,
,REAL,1.23e-10,4.5,
where  sname  is the name of this service.
The user code would be programmed as follows:len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
eqcpnc is the equivalent creep strain increment; to be defined by the user in this user  subroutine.
Must be redefined by the user as equivalent creep strain increment.
error_code is returned error code, 0 = success, otherwise fail.
C OBTAIN SINH (T/B)
S = T(1)
IF (S.EQ.0.) GO TO 1
SINHT = .5*(EXP(S/rdata(2))-EXP(-S/rdata(2)))
GO TO 2
1SINHT = 0.
2CONTINUE
C DEFINE EQCPNC
EQCPNC = TIMINC*rdata(1)*SINHTe·cfsetc,()=
DecDtfsetc,() =
e·cAs
B&amp;mdash;sinh =&lt;/p&gt;
&lt;p&gt;109 CHAPTER 1
EXT_UFAIL
Main Index
Description
The EXT_UFAIL  user subroutine is provided to allow the user to calculate his own scalar failure criterion. To call the
EXT_UFAIL  user subroutine, the user must specify user failure criterion type in MATF option, and define proper service
and user subroutine name in MATUDS  option. EXT_UFAIL  is then called for every integration point associated with the
material ID specified in both MATF  and MATUDS .
MATUDS  defines the service name corresponding to the material, and the data (integer, real and characters) used to define
the failure criterion in the user subroutine. It should look like the following for EXT_UFAIL  application:
MATUDS,mid,MATF,sname,UFAIL,
,INT,…
,REAL,…
,CHAR,…
where  mid is the material identification number consistent with the corresponding MATF ; sname  is the name of this
service. Integers (real numbers, characters) can be defined and passed into EXT_UFAIL  with the key word INT (REAL,
CHAR) .
This routine may be used with all elastic-plastic materials. Progressive cracking is only available with the additive elastic-
plastic model.
Format
IDL
C++
SCAResult Materials::usrUfail_32(const SCAInt32 nelem, const SCAInt32 nint, const ufail::DynInt32&amp;amp; kcus,
const ufail::DynInt32&amp;amp; matus, const ufail::DynReal64&amp;amp; stress, const ufail::DynReal64&amp;amp; strain,
const SCAInt32 ndi, const SCAInt32 nshear, ufail::DynReal64&amp;amp; failc, const ufail::DynReal64&amp;amp; dt,
const ufail::DynReal64&amp;amp; dtdl, const SCAInt32 nstats, const SCAInt32 isunit,
const ufail::DynInt32&amp;amp; idata, const ufail::DynReal64&amp;amp; rdata, const ufail::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}&lt;/p&gt;
&lt;p&gt;SCAResult Materials::usrUfail_64(const SCAInt64 nelem, const SCAInt64 nint, const ufail::DynInt64&amp;amp; kcus,
const ufail::DynInt64&amp;amp; matus, const ufail::DynReal64&amp;amp; stress, const ufail::DynReal64&amp;amp; strain,
const SCAInt64 ndi, const SCAInt64 nshear, ufail::DynReal64&amp;amp; failc, const ufail::DynReal64&amp;amp; dt,
const ufail::DynReal64&amp;amp; dtdl, const SCAInt64 nstats, const SCAInt64 isunit,
const ufail::DynInt64&amp;amp; idata, const ufail::DynReal64&amp;amp; rdata, const ufail::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
User subroutine EXT_UFAIL  is written with the following headers:
subroutine ext_ufail(nelem, nint, kcus, matus, stress, strain,
&amp;amp;             ndi, nshear, failc, dt, dtdl, nstats, ncomp, isunit,
&amp;amp;             idata, rdata, cdata, len_idata, len_rdata,
&amp;amp;             len_cdata, error_code)
implicit noneEXT_UFAIL User-defined Failure Criterion&lt;/p&gt;
&lt;p&gt;110 User Defined Services User’s Guide
User Defined Subroutines
Main Index
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: nelem, nint, ndi, nshear, nstats, isunit
integer, intent(in)  :: ncomp
integer, intent(out) :: error_code
integer, intent(in),  dimension(2)      :: kcus, matus
real(8), intent(in),  dimension(ncomp)  :: stress, strain
real(8), intent(out), dimension(2)      :: failc
real(8), intent(in),  dimension(nstats) :: dt, dtdl
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
end subroutine ext_ufail
Input:
nelem is the user element number.
nelem is the internal element number.
nint is the integration point number.
kcus(1) is your layer number (always 1 for continuum elements).
kcus(2) is the internal layer number (always 1 for continuum element).
matus(1) is the user material identifier.
matus(2) is the internal material identifier.
stress is the current total stress state.
strain is the current total strain.
ndi is the number of direct stresses.
nshear is the number of shear stresses.
dt is state variables.
dtdl is incremental state variables.
nstats is number of state variables.
ncomp is number of strain/stress components.
isunit is system units:
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)&lt;/p&gt;
&lt;p&gt;111 CHAPTER 1
EXT_UFAIL
Main Index
idata is user supplied integer data in MATUDS .
rdata is user supplied real data in MATUDS .
cdata is user supplied character data in MATUDS .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
failc (1) is user-defined failure criteria.
failc (2) is user-defined strength ratio (allowable stress/actual stress).
error_code is returned error code, 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;112 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
This user subroutine allows users to define the stiffness reduction factors for a progressive failure analysis.
The routine is called for an element integration point whenever failure occurs. The failure criteria can be defined on the
MATF  option, or via the EXT_UFAIL  user subroutine.
For this routine to be invoked, the progressive failure type (the field ITYPE  in MATF  bulk data option) must be either
gradual selective or immediate selective stiffness degradation.
MATUDS  should be used together with MATF  to activate EXT_UPROGFAIL . MATUDS  defines the service name
corresponding to the material, and the data (integer, real and characters) used to define the stiffness reduction factors in the
user subroutine. It should look like the following for EXT_UPROGFAIL  application:
MATUDS,mid,MATF,sname,UPROGFAIL,
,INT,…
,REAL,…
,CHAR,…
where  mid is the material identification number consistent with the corresponding MATF ; sname  is the name of this
service. Integers (real numbers, characters) can be defined and passed into EXT_UPROGFAIL  with the key word INT
(REAL, CHAR) .
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Materials {
module uprogfail {
typedef SCAInt32  DynInt32[];
typedef SCAInt64  DynInt64[];
typedef SCAReal32 DynReal32[];
typedef SCAReal64 DynReal64[];
typedef SCAInt32  DynInt32_2[][];
typedef SCAInt64  DynInt64_2[][];
typedef SCAReal32 DynReal32_2[][];
typedef SCAReal64 DynReal64_2[][];
interface SCAIMDSolverUprogfail : SCAIService
{
SCAResult usrUprogfail_32( in    SCAInt32  nelem,
in    SCAInt32  nint,EXT_UPROGFAIL Definition of Material Stiffness Reduction Factors for Progressive Failure Analysis&lt;/p&gt;
&lt;p&gt;113 CHAPTER 1
EXT_UPROGFAIL
Main Index
in    DynInt32  kcus,
in    DynInt32  matus,
in    DynReal64 stress,
in    DynReal64 strain,
in    SCAInt32  icrit,
in    DynReal64 fi,
in    DynReal64 redfac0,
out   DynReal64 redfac,
out   SCAInt32  ideact,
in    DynReal64 dt,
in    DynReal64 dtdl,
in    SCAReal64 time,
in    SCAReal64 timeinc,
in    SCAInt32  nstats,
in    SCAInt32  isunit,
in    DynInt32  idata,
in    DynReal64 rdata,
in    DynInt32  cidata);
SCAResult usrUprogfail_64( in    SCAInt64  nelem,
in    SCAInt64  nint,
in    DynInt64  kcus,
in    DynInt64  matus,
in    DynReal64 stress,
in    DynReal64 strain,
in    SCAInt64  icrit,
in    DynReal64 fi,
in    DynReal64 redfac0,
out   DynReal64 redfac,
out   SCAInt64  ideact,
in    DynReal64 dt,
in    DynReal64 dtdl,
in    SCAReal64 time,
in    SCAReal64 timeinc,
in    SCAInt64  nstats,
in    SCAInt64  isunit,
in    DynInt64  idata,
in    DynReal64 rdata,
in    DynInt64  cidata);
};
}; // uprogfail
}; // Materials
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Materials::usrUprogfail_32(const SCAInt32 nelem, const SCAInt32 nint, const uprogfail::DynInt32&amp;amp; kcus,
const uprogfail::DynInt32&amp;amp; matus, const uprogfail::DynReal64&amp;amp; stress,
const uprogfail::DynReal64&amp;amp; strain, const SCAInt32 icrit, const uprogfail::DynReal64&amp;amp; fi,&lt;/p&gt;
&lt;p&gt;114 User Defined Services User’s Guide
User Defined Subroutines
Main Index
const uprogfail::DynReal64&amp;amp; redfac0, uprogfail::DynReal64&amp;amp; redfac, SCAInt32&amp;amp; ideact,
const uprogfail::DynReal64&amp;amp; dt, const uprogfail::DynReal64&amp;amp; dtdl, const SCAReal64 time,
const SCAReal64 timeinc, const SCAInt32 nstats, const SCAInt32 isunit,
const uprogfail::DynInt32&amp;amp; idata, const uprogfail::DynReal64&amp;amp; rdata,
const uprogfail::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}&lt;/p&gt;
&lt;p&gt;SCAResult Materials::usrUprogfail_64(const SCAInt64 nelem, const SCAInt64 nint, const uprogfail::DynInt64&amp;amp; kcus,
const uprogfail::DynInt64&amp;amp; matus, const uprogfail::DynReal64&amp;amp; stress,
const uprogfail::DynReal64&amp;amp; strain, const SCAInt64 icrit, const uprogfail::DynReal64&amp;amp; fi,
const uprogfail::DynReal64&amp;amp; redfac0, uprogfail::DynReal64&amp;amp; redfac, SCAInt64&amp;amp; ideact,
const uprogfail::DynReal64&amp;amp; dt, const uprogfail::DynReal64&amp;amp; dtdl, const SCAReal64 time,
const SCAReal64 timeinc, const SCAInt64 nstats, const SCAInt64 isunit,
const uprogfail::DynInt64&amp;amp; idata, const uprogfail::DynReal64&amp;amp; rdata,
const uprogfail::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_uprogfail(nelem, nint, kcus, matus, stress, strain,
&amp;amp;             icrit, fi, redfac0, redfac, ideact, dt, dtdl, time,
&amp;amp;             timeinc, nstats, ncomp, isunit, idata, rdata, cdata,
&amp;amp;             len_idata, len_rdata, len_cdata, error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: nelem, nint, icrit, nstats, isunit, ncomp
integer, intent(out) :: ideact, error_code
real(8), intent(in)  :: time, timeinc
integer, intent(in),  dimension(2)      :: kcus, matus
real(8), intent(in),  dimension(ncomp)  :: stress, strain
real(8), intent(in),  dimension(6)      :: fi, redfac0
real(8), intent(out), dimension(6)      :: redfac
real(8), intent(in),  dimension(nstats) :: dt, dtdl
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
end subroutine ext_uprogfail
Input:
nelem is the user element number.
nint is the integration point number.
kcus is the layer number:
kcus(1)  – user layer number
kcus(2)  – internal layer number
matus is the material ID:
matus(1)  – user material ID
matus(2)  – internal material ID&lt;/p&gt;
&lt;p&gt;115 CHAPTER 1
EXT_UPROGFAIL
Main Index
stress is the current total stresses in preferred system:
in full tensor format ( 11, 22, 33, 12, 23, 13)
strain is the current total strains in preferred system:
in full tensor format ( 11, 22, 33, 12, 23, 13)
icrit is the current failure criterion:
1– maximum stress
2– maximum strain
3– Tsai-Wu
4– Hoffman
5– Hill
6– not used
7– user
8– Hashin
9– Hashin Fabric
10– not used
11– not used
12– Hashin Tape
13– puck
fi is the array of current failure indices.
ideact is the deactivation flag. Set to 1 to flag that the element should be deactivated. If all integration points
of the element have this flag set, it is deactivated at the end of the current increment. Upon entry, it
contains the value calculated by the program.
dt is the array of state variables at the beginning of the current increment:
dt(1)  is the temperature
dtdl is the array of increment of state variables:
dtdl(1)  is the incremental temperature.
time is the time at the beginning of the current increment.
timeinc is the time increment.
nstats is number of state variables.
ncomp is number of strain/stress components.
isunit is system units:
= 0 not entered&lt;/p&gt;
&lt;p&gt;116 User Defined Services User’s Guide
User Defined Subroutines
Main Index
The six components of redfac  will be used for scaling the material moduli of an orthotropic material according to
The Poisson’s ratios are scaled the same way as the corresponding shear modulus.
For an isotropic material, the Young’s modulus is scaled with the smallest of the components of redfac and the shear
modulus is calculated using the updated Young’s modulus and the Poisson’s ratio.
The case of general anisotropy is not supported.= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
idata is user supplied integer data in MATUDS .
rdata is user supplied real data in MATUDS .
cdata is user supplied character data in MATUDS .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
redfac0 is the array of current reduction factors.
redfac is the array of reduction factors to be updated.
upon entry it contains the values calculated by the program.
error_code is returned error code, 0 = success, otherwise fail.
E11newredfac1() E11orig· =
E22newredfac2() E22orig· =
E33newredfac3() E33orig· =
G12newredfac4() G12orig· =
G23newredfac5() G23orig· =
G31newredfac6() G31orig· =&lt;/p&gt;
&lt;p&gt;117 CHAPTER 1
EXT_MOTION
Main Index
Description
This user subroutine allows the definition of non-uniform rigid surface motions in conjunction with contact analysis. Its
call is triggered by the BCONUDS  bulk data option. This user subroutine should only be used with velocity controlled rigid
surfaces.
The EXT_MOTION  user subroutine is called during the calculations at the beginning of each time increment and the user’s
return surface velocities for that increment. Imposed displacement increments at nodal points in contact with rigid surfaces
are obtained from the velocity multiplied by the time increment. The surface path becomes an explicit forward integration
of velocities. Therefore, caution should be taken when there are abrupt changes in surface path direction or abrupt changes
in velocity by making time increments as small as necessary.
If, at the start of the analysis, a rigid surface is placed apart from the deformable body, the EXT_MOTION  user subroutine
is also used in the approaching phase.
BCONUDS  activates the call to contact related user subroutines such as EXT_MOTION , and defines the data (integer, real
and characters) required in the user subroutine. It should look like the following for EXT_MOTION  application:
BCONUDS,bid,BCBODY,sname,MOTION,
,INT,…
,REAL,…
,CHAR,…
where  bid is the contact body identification number consistent with the corresponding BCBODY ; and sname  is the name
of this service. Integers (real numbers, characters) can be defined and passed into EXT_MOTION  with the key word INT
(REAL, CHAR) .
Format
IDL
module SCA { EXT_MOTION Definition of Rigid Surface Motion for 3 -D Contact
Caution:   Please note that if the coordinates of the center of rotation are defined unconditionally in this
routine, they will be set to that same value for all increments of the analysis, causing the rigid
surface to rotate around a fixed point in space. On the other hand, if the position of the center
of rotation is defined only once in increment 0, as in
if(inc.eq.0) then
x(1)=&amp;hellip;
etc.
endif
the center of the rotation is updated internally as motion and deformation take place.
Obviously, the results will be different for the two cases.&lt;/p&gt;
&lt;p&gt;118 User Defined Services User’s Guide
User Defined Subroutines
Main Index
module MDSolver {
module Obj {
module Uds {
module Contact {
module motion {
typedef SCAInt32  DynInt32[];
typedef SCAInt64  DynInt64[];
typedef SCAReal64 DynReal64[];
interface SCAIMDSolverMotion : SCAIService
{
SCAResult usrMotion_32( in    DynReal64  x,
in    DynReal64  f,
out   DynReal64  v,
in    SCAReal64  time,
in    SCAReal64  dtime,
in    SCAInt32   nsurf,
in    SCAInt32   inc,
in    SCAInt32   isunit,
in    DynInt32   idata,
in    DynReal64  rdata,
in    DynInt32   cidata );
SCAResult usrMotion_64( in    DynReal64  x,
in    DynReal64  f,
out   DynReal64  v,
in    SCAReal64  time,
in    SCAReal64  dtime,
in    SCAInt64   nsurf,
in    SCAInt64   inc,
in    SCAInt64   isunit,
in    DynInt64   idata,
in    DynReal64  rdata,
in    DynInt64   cidata );
};
}; // motion
}; // Contact
}; // UDS
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Contact::usrMotion_32(const motion::DynReal64&amp;amp; x, const motion::DynReal64&amp;amp; f, motion::DynReal64&amp;amp; v,
const SCAReal64 time, const SCAReal64 dtime, const SCAInt32 nsurf, const SCAInt32 inc,
const SCAInt32 isunit, const motion::DynInt32&amp;amp; idata, const motion::DynReal64&amp;amp; rdata,
const motion::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}&lt;/p&gt;
&lt;p&gt;SCAResult Contact::usrMotion_64(const motion::DynReal64&amp;amp; x, const motion::DynReal64&amp;amp; f, motion::DynReal64&amp;amp; v,
const SCAReal64 time, const SCAReal64 dtime, const SCAInt64 nsurf, const SCAInt64 inc,&lt;/p&gt;
&lt;p&gt;119 CHAPTER 1
EXT_MOTION
Main Index
const SCAInt64 isunit, const motion::DynInt64&amp;amp; idata, const motion::DynReal64&amp;amp; rdata,
const motion::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_motion(x, f, v, time, dtime, nsurf, inc, isunit,
&amp;amp;             nsize, nsize_v, idata, rdata, cdata, len_idata,
&amp;amp;             len_rdata, len_cdata, error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: nsurf, inc, isunit, nsize, nsize_v
integer, intent(out) :: error_code
real(8), intent(in)  :: time, dtime
real(8), intent(in),  dimension(nsize)   :: x, f
real(8), intent(out), dimension(nsize_v) :: v
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06&lt;/p&gt;
&lt;p&gt;!     uncomment to call existing implementation
!     call motion(x, f, v, time, dtime, nsurf, inc)
end subroutine ext_motion
Input:
x(6) is the array of current die defining coordinates:
x(1) =first coordinate of center of rotation.
x(2) =second coordinate of center of rotation.
x(3) = third coordinate of center of rotation.
Axis for specifying angular velocity:
x(4) =first component of direction cosine.
x(5) =second component of direction cosine.
x(6) =third component of direction cosine.
f(6) is the array of current surface loads:
f(1) =first component of load.
f(2) =second component of load.
f(3) =third component of load.
f(4) =first component of moment.&lt;/p&gt;
&lt;p&gt;120 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Example
Assume that a rigid surface is identified as surface number 2 and is moving in the negative x -direction with a velocity of 1.0.
The input for BCONUDS  should be
BCONUDS,2,BCBODY,sname,MOTION,
,REAL,-1.0,f(5) =second component of moment.
f(6) =third component of moment.
time is the time at which data is requested.
dtime is the current time increment.
nsurf is the surface number for which data is requested.
inc is the increment number.
isunit is system units:
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
nsize is the size of X and F.
nsize_v is the size of V.
idata is user supplied integer data in MATUDS .
rdata is user supplied real data in MATUDS .
cdata is user supplied character data in MATUDS .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
v(4) is the array of current surface velocities:
v(1) =first component of the velocity at the center of rotation.
v(2) =second component of the velocity at the center of rotation.
v(3) =third component of the velocity at the center of radiation.
v(4) =angular velocity around axis defined above with X(4) , X(5) , and X(6) .
error_code is the returned error code; 0 = success, otherwise fail.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P7</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_007/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_007/</guid>
      <description>
        
        
        &lt;p&gt;121 CHAPTER 1
EXT_MOTION
Main Index
where  sname  is the name of this service.
The user code for EXT_MOTION  user subroutine can be written as follows:
IF(NSURF.eq.2) THEN
V(1)=rdata(1)
V(2)=0.
V(3)=0.
V(4)=0.0
ENDIF&lt;/p&gt;
&lt;p&gt;122 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
With this user subroutine, the user can define the variable friction coefficients or friction factors in conjunction with contact
analysis. Its call is triggered by BCONUDS  option.
For distributed based friction, the EXT_UFRIC  user subroutine is called for every element containing nodes that are in
contact with surfaces at the nodes. These calls are made every iteration both during the assembly phase and during the stress
recovery phase.
BCONUDS  activates the call to contact related user subroutines such as EXT_UFRIC , and defines the data (integer, real and
characters) required in the user subroutine. It should look like the following for EXT_UFRIC  application:
BCONUDS,bid,BCBODY,sname,UFRIC,
,INT,…
,REAL,…
,CHAR,…
where  bid is the contact body identification number consistent with the corresponding BCBODY ; and sname  is the name
of this service. Integers (real numbers, characters) can be defined and passed into EXT_UFRIC  with the key word INT
(REAL, CHAR) .
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Contact {
module ufric {
typedef SCAInt32 DynInt32[];
typedef SCAInt64 DynInt64[];
typedef SCAReal64 DynReal64[];
interface SCAIMDSolverUfric : SCAIService
{
SCAResult usrUfric_32( in    DynInt32   mibody,
in    DynReal64  x,
in    SCAReal64  fn,
in    DynReal64  vrel,
in    SCAReal64  temp,
in    SCAReal64  yiel,
out   SCAReal64  fric,
in    SCAReal64  time,
in    SCAInt32   inc,EXT_UFRIC Definition of Friction Coefficients&lt;/p&gt;
&lt;p&gt;123 CHAPTER 1
EXT_UFRIC
Main Index
in    SCAInt32   i2or3,
in    SCAInt32   nsurf,
in    SCAInt32   isunit,
in    DynInt32   idata,
in    DynReal64  rdata,
in    DynInt32   cidata );
SCAResult usrUfric_64( in    DynInt64   mibody,
in    DynReal64  x,
in    SCAReal64  fn,
in    DynReal64  vrel,
in    SCAReal64  temp,
in    SCAReal64  yiel,
out   SCAReal64  fric,
in    SCAReal64  time,
in    SCAInt64   inc,
in    SCAInt64   i2or3,
in    SCAInt64   nsurf,
in    SCAInt64   isunit,
in    DynInt64   idata,
in    DynReal64  rdata,
in    DynInt64   cidata );
};
}; // ufric
}; // Contact
}; // UDS
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Contact::usrUfric_32(const ufric::DynInt32&amp;amp; mibody, const ufric::DynReal64&amp;amp; x, const SCAReal64 fn,
const ufric::DynReal64&amp;amp; vrel, const SCAReal64 temp, const SCAReal64 yiel, SCAReal64&amp;amp; fric,
const SCAReal64 time, const SCAInt32 inc, const SCAInt32 nsurf, const SCAInt32 i2or3,
const SCAInt32 isunit, const ufric::DynInt32&amp;amp; idata, const ufric::DynReal64&amp;amp; rdata,
const ufric::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}&lt;/p&gt;
&lt;p&gt;SCAResult Contact::usrUfric_64(const ufric::DynInt64&amp;amp; mibody, const ufric::DynReal64&amp;amp; x, const SCAReal64 fn,
const ufric::DynReal64&amp;amp; vrel, const SCAReal64 temp, const SCAReal64 yiel, SCAReal64&amp;amp; fric,
const SCAReal64 time, const SCAInt64 inc, const SCAInt64 nsurf, const SCAInt64 i2or3,
const SCAInt64 isunit, const ufric::DynInt64&amp;amp; idata, const ufric::DynReal64&amp;amp; rdata,
const ufric::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_ufric(mibody, x, fn, vrel, temp, yiel, fric, time,
&amp;amp;             inc, nsurf, i2or3, isunit, idata, rdata, cdata,
&amp;amp;             len_vrel, len_idata, len_rdata, len_cdata,
&amp;amp;             error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata&lt;/p&gt;
&lt;p&gt;124 User Defined Services User’s Guide
User Defined Subroutines
Main Index
integer, intent(in)  :: inc, nsurf, i2or3, isunit, len_vrel
integer, intent(out) :: error_code
real(8), intent(in)  :: fn, temp, yiel, time
real(8), intent(out) :: fric
integer, intent(in),  dimension(4)        :: mibody
real(8), intent(in),  dimension(i2or3)    :: x
real(8), intent(out), dimension(len_vrel) :: vrel
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
!     uncomment to call existing implementation
!     call ufric(mibody,x,fn,vrel,temp,yiel,fric,time,inc,nsurf)
end subroutine ext_ufric
Input:
For distributed friction based on nodal stresses:
mibody(1) is the user element number.
mibody(2) is the side number.
mibody(3) is the surface integration point number.
mibody(4) is the internal element number.
For nodal friction based on nodal forces:
mibody(1) is the user node number.
mibody(2) is not used; enter 0.
mibody(3) is not used; enter 0.
mibody(4) is the internal node number.
x is the updated coordinates of contact point where friction is being calculated. The third coordinate is
zero for 2-D models.
fn is the normal stress/force being applied at that point.
vrel(1) is the relative sliding velocity at contact point for 2-D models.
vrel(1) is the sliding velocity in the first tangential direction for 3-D models.
vrel(2) is the sliding velocity in the second tangential direction for 3-D models.
temp(1) is the temperature of contact point.
temp(2) is the voltage of contact point (Joule heating).
yiel is the flow stress of workpiece material at contact point.&lt;/p&gt;
&lt;p&gt;125 CHAPTER 1
EXT_UFRIC
Main Index
time is the current time.
inc is the increment number.
nsurf is the surface being contacted by the side for which friction calculations are being made.
i2or3 2 for 2-D; 3 for 3-D.
isunit is system units:
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
idata is user supplied integer data in MATUDS .
rdata is user supplied real data in MATUDS .
cdata is user supplied character data in MATUDS .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
fric is the friction coefficient or friction factor to be provided by the user.
error_code is returned error code; 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;126 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
This user subroutine allows the definition of the separation force in contact analysis. The separation forces, FNORM  and
FTANG , are either calculated by the program or entered through the BCTABLE  or BCPARA  option, and then passed into
this user subroutine. The user decides whether these values at the current increment are appropriate to determine whether
separation occurs.
FNORM  is the normal reaction force above which a node in contact separates from a surface. Any compressive or negative
value indicates real contact while a positive reaction force indicates a tendency to separate. The default is taken as the
maximum value of the residual force in the structure for the current increment. This value can be reset by the user through
the input format. Defining too small a value can result in an increased number of iterations. Defining a very large value
eliminates the possibility of separation. FTANG  is the tangential force used to determine whether a nodal point positioned
at a convex corner of surface should be sliding from patch to patch or remaining on its current patch. The default value is
half of FNORM . These two default reaction forces vary from increment to increment.
BCONUDS  activates the call to contact related user subroutines such as EXT_SEPFOR , and defines the data (integer, real
and characters) required in the user subroutine. It should look like the following for EXT_SEPFOR  application:
BCONUDS,bid,BCBODY,sname,SEPFOR,
,INT,…
,REAL,…
,CHAR,…
where  bid is the contact body identification number consistent with the corresponding BCBODY ; and sname  is the name
of this service. Integers (real numbers, characters) can be defined and passed into EXT_SEPFOR  with the key word INT
(REAL, CHAR) .
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Contact {
module sepfor {
typedef SCAInt32 DynInt32[];
typedef SCAInt64 DynInt64[];
typedef SCAReal64 DynReal64[];EXT_SEPFOR Definition of Separation Force
Note:   The EXT_ SEPFOR  user subroutines are not available with segment -to-segment contact.&lt;/p&gt;
&lt;p&gt;127 CHAPTER 1
EXT_SEPFOR
Main Index
interface SCAIMDSolverSepfor : SCAIService
{
SCAResult usrSepfor_32( out   SCAReal64 fnorm,
out   SCAReal64 ftang,
in    SCAInt32  ibody,
in    SCAInt32  nnode,
in    SCAInt32  inc,
in    SCAReal64 time,
in    SCAReal64 dtime,
in    SCAInt32  isunit,
in    DynInt32  idata,
in    DynReal64 rdata,
in    DynInt32  cidata );
SCAResult usrSepfor_64( out   SCAReal64 fnorm,
out   SCAReal64 ftang,
in    SCAInt64  ibody,
in    SCAInt64  nnode,
in    SCAInt64  inc,
in    SCAReal64 time,
in    SCAReal64 dtime,
in    SCAInt64  isunit,
in    DynInt64  idata,
in    DynReal64 rdata,
in    DynInt64  cidata );
};
}; // sepfor
}; // Contact
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Contact::usrSepfor_32(SCAReal64&amp;amp; fnorm, SCAReal64&amp;amp; ftang, const SCAInt32 ibody, const SCAInt32 nnode,
const SCAInt32 inc, const SCAReal64 time, const SCAReal64 dtime, const SCAInt32 isunit,
const sepfor::DynInt32&amp;amp; idata, const sepfor::DynReal64&amp;amp; rdata, const sepfor::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}
SCAResult Contact::usrSepfor_64(SCAReal64&amp;amp; fnorm, SCAReal64&amp;amp; ftang, const SCAInt64 ibody, const SCAInt64 nnode,
const SCAInt64 inc, const SCAReal64 time, const SCAReal64 dtime, const SCAInt64 isunit,
const sepfor::DynInt64&amp;amp; idata, const sepfor::DynReal64&amp;amp; rdata, const sepfor::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_sepfor(fnorm, ftang, ibody, nnode, inc, time,
&amp;amp;             dtime, isunit, idata, rdata, cdata, len_idata,
&amp;amp;             len_rdata, len_cdata, error_code)
implicit none&lt;/p&gt;
&lt;p&gt;128 User Defined Services User’s Guide
User Defined Subroutines
Main Index
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: ibody, inc, nnode, isunit
integer, intent(out) :: error_code
real(8), intent(in)  :: time, dtime
real(8), intent(out) :: fnorm, ftang
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
!     uncomment to call existing implementation
!     call sepfor(fnorm, ftang, ibody, nnode, inc)
end subroutine ext_sepfor
Input:
ibody is the current body number the node touched.
nnode is the current touched external node number.
inc is the current increment number.
time is the time.
dtime is the time increment.
isunit is system units:
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
idata is user supplied integer data in MATUDS .
rdata is user supplied real data in MATUDS .
cdata is user supplied character data in MATUDS .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
fnorm is the normal separation force to be supplied by the user.&lt;/p&gt;
&lt;p&gt;129 CHAPTER 1
EXT_SEPFOR
Main Index
Example
If the user does not want any separation of nodes from surface 3, but wants to leave the default separation force unchanged
for all other contact bodies, the BCONUDS  input can be written as
BCONUDS,3,BCBODY,sname,SEPFOR
,REAL,1.e20,
where sname  is the service name for this user subroutine; and the user code is written as
FNORM=radta(1)ftang is the tangential separation force to be supplied by the user.
error_code is returned error code; 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;130 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description
This user subroutine allows the definition of the separation stress in contact analysis. The separation stresses, SNORM  and
STANG , are either calculated by the program or entered through the BCTABLE  or BCPARA  option, and then passed into
this user subroutine. The user decides whether these values at the current increment are appropriate to determine whether
separation occurs.
SNORM  is the normal stress above which a node in contact separates from a surface. Any compressive or negative value
indicates real contact while a positive reaction force indicates a tendency to separate. The default is taken as the maximum
value of the residual force in the structure for the current increment divided by an effective area. This value can be reset by
the user through the input format. Defining too small a value can result in an increased number of iterations. Defining a
very large value eliminates the possibility of separation. STANG  is the tangential stress used to determine whether a nodal
point positioned at a convex corner of surface should be sliding from patch to patch or remaining on its current patch. The
default value is half of SNORM . These two default values vary from increment to increment.
BCONUDS  activates the call to contact related user subroutines such as EXT_SEPSTR , and defines the data (integer, real
and characters) required in the user subroutine. It should look like the following for EXT_SEPSTR  application:
BCONUDS,bid,BCBODY,sname,SEPSTR,
,INT,…
,REAL,…
,CHAR,…
where  bid is the contact body identification number consistent with the corresponding BCBODY ; and sname  is the name
of this service. Integers (real numbers, characters) can be defined and passed into EXT_SEPSTR  with the key word INT
(REAL, CHAR) .
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Contact {
module sepstr {
typedef SCAInt32 DynInt32[];
typedef SCAInt64 DynInt64[];
typedef SCAReal64 DynReal64[];EXT_SEPSTR Definition of Separation Stress
Note:   The EXT_SEPSTR  user subroutines are not available with segment -to-segment contact.&lt;/p&gt;
&lt;p&gt;131 CHAPTER 1
EXT_SEPSTR
Main Index
interface SCAIMDSolverSepstr : SCAIService
{
SCAResult usrSepstr_32( out   SCAReal64  snorm,
out   SCAReal64  stang,
in    SCAInt32   ibody,
in    SCAInt32   nnode,
in    SCAInt32   inc,
in    SCAReal64  time,
in    SCAReal64  dtime,
in    SCAInt32   isunit,
in    DynInt32   idata,
in    DynReal64  rdata,
in    DynInt32   cidata );
SCAResult usrSepstr_64( out   SCAReal64  snorm,
out   SCAReal64  stang,
in    SCAInt64   ibody,
in    SCAInt64   nnode,
in    SCAInt64   inc,
in    SCAReal64  time,
in    SCAReal64  dtime,
in    SCAInt64   isunit,
in    DynInt64   idata,
in    DynReal64  rdata,
in    DynInt64   cidata );
};
}; // sepstr
}; // Contact
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Contact::usrSepstr_32(SCAReal64&amp;amp; snorm, SCAReal64&amp;amp; stang, const SCAInt32 ibody, const SCAInt32 nnode,
const SCAInt32 inc, const SCAReal64 time, const SCAReal64 dtime, const SCAInt32 isunit,
const sepstr::DynInt32&amp;amp; idata, const sepstr::DynReal64&amp;amp; rdata, const sepstr::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}&lt;/p&gt;
&lt;p&gt;SCAResult Contact::usrSepstr_64(SCAReal64&amp;amp; snorm, SCAReal64&amp;amp; stang, const SCAInt64 ibody, const SCAInt64 nnode,
const SCAInt64 inc, const SCAReal64 time, const SCAReal64 dtime, const SCAInt64 isunit,
const sepstr::DynInt64&amp;amp; idata, const sepstr::DynReal64&amp;amp; rdata, const sepstr::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_sepstr(snorm, stang, ibody, nnode, inc, time,
&amp;amp;             dtime, isunit, idata, rdata, cdata, len_idata,
&amp;amp;             len_rdata, len_cdata, error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata&lt;/p&gt;
&lt;p&gt;132 User Defined Services User’s Guide
User Defined Subroutines
Main Index
integer, intent(in)  :: ibody, inc, nnode, isunit
integer, intent(out) :: error_code
real(8), intent(in)  :: time, dtime
real(8), intent(out) :: snorm, stang
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
!     uncomment to call existing implementation
!     call sepstr(snorm, stang, ibody, nnode, inc)
end subroutine ext_sepstr
Input:
ibody is the current body number the node touched.
nnode is the current touched external node number.
inc is the current increment number.
time is the time.
dtime is the time increment.
isunit is system units:
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
idata is user supplied integer data in MATUDS .
rdata is user supplied real data in MATUDS .
cdata is user supplied character data in MATUDS .
len_idata is the length of idata .
len_rdata is the length of rdata .
len_cdata is the length of cdata .
Required Output:
snorm is the normal separation stress to be supplied by the user.
stang is no longer used - dummy variable.
error_code is returned error code; 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;133 CHAPTER 1
EXT_UBSQUEAL
Main Index
Description
User subroutine EXT_UBSQUEAL  is used to define the friction coefficient and the effective stiffness in the brake squeal
analysis in MSC Nastran. This routine is called for those nodes that are in contact with rotor. The parameters used for brake
squeal analysis are defined in bulk data option BSQUEAL . Among these parameters, the friction coefficient and the effective
stiffness can be re-set during the process of analysis by means of user subroutine EXT_UBSQUEAL .
BCONUDS  activates the call to contact related user subroutines such as EXT_UBSQUEAL , and defines the data (integer,
real and characters) required in the user subroutine. It should look like the following for EXT_UBSQUEAL  application:
BCONUDS,bid,BCBODY,sname,UBSQUEAL,
,INT,…
,REAL,…
,CHAR,…
where  bid is the contact body identification number consistent with the corresponding BCBODY ; and sname  is the name
of this service. Integers (real numbers, characters) can be defined and passed into EXT_UBSQUEAL  with the key word INT
(REAL, CHAR) .
Format
IDL
module SCA {
module MDSolver {
module Obj {
module Uds {
module Contact {
module ubsqueal {
typedef SCAInt32  DynInt32[];
typedef SCAInt64  DynInt64[];
typedef SCAReal32 DynReal32[];
typedef SCAReal64 DynReal64[];
typedef SCAInt32  DynInt32_2[][];
typedef SCAInt64  DynInt64_2[][];
typedef SCAReal32 DynReal32_2[][];
typedef SCAReal64 DynReal64_2[][];
interface SCAIMDSolverUbsqueal : SCAIService
{
SCAResult usrUbsqueal_32( in    DynInt32    ibodies,
in    SCAInt32    nnode,
in    DynInt32    nodes,
in    DynReal64_2 coords,
in    DynReal64   center,EXT_UBSQUEAL Definition Parameters used in Brake Squeal Analysis&lt;/p&gt;
&lt;p&gt;134 User Defined Services User’s Guide
User Defined Subroutines
Main Index
in    DynReal64   vector,
in    SCAReal64   area,
in    SCAInt32    i2or3,
in    SCAReal64   temp,
in    SCAReal64   press,
in    DynReal64   xnorm,
in    SCAInt32    inc,
out   SCAReal64   stiff,
out   SCAReal64   fric,
in    SCAInt32    isunit,
in    DynInt32    idata,
in    DynReal64   rdata,
in    DynInt32    cidata);
SCAResult usrUbsqueal_64( in    DynInt64    ibodies,
in    SCAInt64    nnode,
in    DynInt64    nodes,
in    DynReal64_2 coords,
in    DynReal64   center,
in    DynReal64   vector,
in    SCAReal64   area,
in    SCAInt64    i2or3,
in    SCAReal64   temp,
in    SCAReal64   press,
in    DynReal64   xnorm,
in    SCAInt64    inc,
out   SCAReal64   stiff,
out   SCAReal64   fric,
in    SCAInt64    isunit,
in    DynInt64    idata,
in    DynReal64   rdata,
in    DynInt64    cidata);
};
}; // ubsqueal
}; // Contact
}; // Uds
}; // Obj
}; // MDSolver
}; // SCA
C++
SCAResult Contact::usrUbsqueal_32(const ubsqueal::DynInt32&amp;amp; ibodies, const SCAInt32 nnode, const ubsqueal::DynInt32&amp;amp; nodes,
const ubsqueal::DynReal64_2&amp;amp; coords, const ubsqueal::DynReal64&amp;amp; center,
const ubsqueal::DynReal64&amp;amp; vector, const SCAReal64 area, const SCAInt32 i2or3,
const SCAReal64 temp, const SCAReal64 press, const ubsqueal::DynReal64&amp;amp; xnorm,
const SCAInt32 inc, SCAReal64&amp;amp; stiff, SCAReal64&amp;amp; fric, const SCAInt32 isunit,
const ubsqueal::DynInt32&amp;amp; idata, const ubsqueal::DynReal64&amp;amp; rdata,
const ubsqueal::DynInt32&amp;amp; cidata)
{
return SCASuccess;
}
SCAResult Contact::usrUbsqueal_64(const ubsqueal::DynInt64&amp;amp; ibodies, const SCAInt64 nnode, const ubsqueal::DynInt64&amp;amp; nodes,
const ubsqueal::DynReal64_2&amp;amp; coords, const ubsqueal::DynReal64&amp;amp; center,
const ubsqueal::DynReal64&amp;amp; vector, const SCAReal64 area, const SCAInt64 i2or3,
const SCAReal64 temp, const SCAReal64 press, const ubsqueal::DynReal64&amp;amp; xnorm,
const SCAInt64 inc, SCAReal64&amp;amp; stiff, SCAReal64&amp;amp; fric, const SCAInt64 isunit,&lt;/p&gt;
&lt;p&gt;135 CHAPTER 1
EXT_UBSQUEAL
Main Index
const ubsqueal::DynInt64&amp;amp; idata, const ubsqueal::DynReal64&amp;amp; rdata,
const ubsqueal::DynInt64&amp;amp; cidata)
{
return SCASuccess;
}
FORTRAN
subroutine ext_ubsqueal(ibodies, nnode, nodes, coords, center,
&amp;amp;             vector, area, i2or3, temp, press, xnorm, inc, stiff,
&amp;amp;             fric, isunit, idata, rdata, cdata, len_idata,
&amp;amp;             len_rdata, len_cdata, error_code)
implicit none
integer, intent(in)  :: len_idata, len_rdata, len_cdata
integer, intent(in)  :: nnode, i2or3, inc, isunit
integer, intent(out) :: error_code
real(8), intent(in)  :: area, temp, press
real(8), intent(out) :: stiff, fric
integer, intent(in), dimension(2)            :: ibodies
integer, intent(in), dimension(nnode)        :: nodes
real(8), intent(in), dimension(i2or3, nnode) :: coords
real(8), intent(in), dimension(i2or3)        :: center
real(8), intent(in), dimension(i2or3)        :: vector
real(8), intent(in), dimension(i2or3)        :: xnorm
integer,          intent(in), dimension(len_idata) :: idata
real(8),          intent(in), dimension(len_rdata) :: rdata
character(len=8), intent(in), dimension(len_cdata) :: cdata
integer, external :: printf06
end subroutine ext_ubsqueal
Input:
ibodies  ibodies(1) is the touching body ID .
ibodies(2) is the touched body ID .
nnode is the number of nodes .
nodes nodes(1) is the touching node ID (user defined) .
nodes(2:nnode) are the node IDs of touched face (user defined) .
coords coord(i2or3,1:1) are the coordinate of touching node .
coord(1:i2or3,2:nnode) are the coordinate of nodes of  touched face (L) .
center is the position of center of rotation axis     (L).
vector is the vector of rotation axis     (L) .
area is the effective area at node(1)   (L2) .
i2or3 is two in a 2-D mode .
is three in a 3-D model .&lt;/p&gt;
&lt;p&gt;136 User Defined Services User’s Guide
User Defined Subroutines
Main Index
EXBRK
Description
The EXBRK  subroutine provides a mechanism to the user to define failure criteria for BJOIN connections in a simulation.
Example
C++:
void  EXBRK
(const cspdbl_int   *nmsets, const cspdbl_int   *ilist,
const cspdbl_int   *isetm,  const cspdbl_int   *ibjoin,
cspdbl_int   *ifail,
const cspdbl_float *fx1,    const cspdbl_float *fy1,temp is the temperature at the contacting node .
press is the contact pressure at the contacting node (F/L2) .
xnorm is the normal to touched face .
inc is the increment number .
isunit is system units:
= 0 not entered
= 1 - SI-m unit (N, m, S, C)
= 2 -SI-mm unit (N, mm, S, C)
= 3 -US (British) unit (lbf, inch, S, F)
idata is user supplied integer data in MATUDS .
rdata is user supplied real data in MATUDS .
cdata is user supplied character data in MATUDS .
len_idata is the length of idata.
len_rdata is the length of rdata.
len_cdata is the length of cdata.
Required Output
stiff is the average normal stiffness at the touched node (F/L3).
fric is the friction coefficient at the touched node .
error_code is returned error code, 0 = success, otherwise fail.
EXBRK Subroutine User-defined breakable joint in a Nastran SOL700 Simulation&lt;/p&gt;
&lt;p&gt;137 CHAPTER 1
EXBRK Subroutine
Main Index
const cspdbl_float *fz1,    const cspdbl_float *fx2,
const cspdbl_float *fy2,    const cspdbl_float *fz2,
const cspdbl_float *xm1,    const cspdbl_float *ym1,
const cspdbl_float *zm1,    const cspdbl_float *xm2,
const cspdbl_float *ym2,    const cspdbl_float *zm2,
const cspdbl_float *fail1,  const cspdbl_float *fail2,
const cspdbl_float *fail3,  const cspdbl_float *fail4,
const cspdbl_float *fail5,  const cspdbl_float *fail6,
const cspdbl_int   *iconn1, const cspdbl_int   *iconn2,
const cspdbl_float *effpls,       cspdbl_int   &lt;em&gt;ierrcode)
{
return;
}
Fortran:
subroutine EXBRK
+ (nmsets,ilist,isetm,ibjoin,ifail,
+  fx1,fy1,fz1,fx2,fy2,fz2,
+  xm1,ym1,zm1,xm2,ym2,zm2,
+  fail1,fail2,fail3,fail4,fail5,fail6,
+  iconn1,iconn2,effpls,ierr_code)
integer(8), intent(in):: nmsets
integer(8), intent(in), dimension(nmsets):: ilist,isetm,ibjoin
integer(8), intent(inout), dimension(nmsets):: ifail
integer(8), intent(in), dimension(8,nmsets):: iconn1,iconn2
real(8), intent(in), dimension(nmsets):: fx1,fy1,fz1,fx2,fy2,fz2
real(8), intent(in), dimension(nmsets):: xm1,ym1,zm1,xm2,ym2,zm2
real(8), intent(in), dimension(nmsets):: fail1,fail2,fail3
real(8), intent(in), dimension(nmsets):: fail4,fail5,fail6
real(8), intent(in), dimension(2&lt;/em&gt;nmsets):: effpls
integer(8), intent(inout) :: ierr_code
return
end subroutine&lt;/p&gt;
&lt;p&gt;138 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description of arguments:
nmsets number of join sets in the user defined string
ilist set numbers in this string
isetm set number of the collection of bjoins to which the bjoin belongs. Bjoints are grouped into sets.
ibjoin If &amp;lt; 0 : negative of the bjjoin id.
   &amp;gt; 0 : crod-id of a splotweld element
ifail global failure flag for the set
fx1             x-component force of point1 of pair
mx1             x-component moment of point1 of pair
fail1           x-component force failure switch
fail2 y-component force failure switch
fail3 z-component force failure switch
fail4 x-component moment failure switch
fail5 y-component moment failure switch
fail6 z-component moment failure switch
iconn1,iconn2   contain connectivity data for the first and the second grid point of the BJOIN pairs. Data concerns
the grid point user number, the number of connected elements, and the connected element user
numbers.
iconn1(1,n) = user number of first point of join pair n
iconn1(2,n) = number of connected elements to point 1 of set n
iconn1(3,n) = user number of connected element
…
iconn1(8,n) = user number of connected element
effpls          effective plastic strain of elements. element ids are given by ICONN1 and ICONN2.
ierr_code      Returned error code; 0 = success, otherwise fail&lt;/p&gt;
&lt;p&gt;139 CHAPTER 1
EXCOMP Subroutine
Main Index
EXCOMP
Description
The EXCOMP  subroutine provides a mechanism to define a composite material in a simulation. Entry MAT8A with option
FT=USER1 must be used.
Example
C++:
void EXCOMP
(const cspdbl_int   *id,     const cspdbl_int   *lenvec,
const cspdbl_int   *ishrpr,
const cspdbl_float *ymx,
const cspdbl_float *ymy,    const cspdbl_float *xnuy,
const cspdbl_float *sxy,    const cspdbl_float *syz,
const cspdbl_float *szx,
const cspdbl_float *xt,     const cspdbl_float *xc,
const cspdbl_float *yt,     const cspdbl_float *yc,
const cspdbl_float *sc,
const cspdbl_float *capa,   const cspdbl_float *cm,
const cspdbl_int   *ibegin, const cspdbl_int   *iend,
const cspdbl_int   *nadvar, const cspdbl_int   *isubly,
cspdbl_float *sig1,         cspdbl_float *sig2,
cspdbl_float *sig4,         cspdbl_float *sig5,
cspdbl_float *sig6,         cspdbl_float *sig51,
cspdbl_float *sig62,
const cspdbl_float *d1,     const cspdbl_float *d2,
const cspdbl_float *d3,     const cspdbl_float *d4,
const cspdbl_float *d5,     const cspdbl_float *d6,
const cspdbl_float *d7,     const cspdbl_float *d8,
const cspdbl_float *dout1,  const cspdbl_float *dout2,
const cspdbl_float *dout4,
cspdbl_float *eft,          cspdbl_float *efc,
cspdbl_float *esf,          cspdbl_float *emt,
cspdbl_float *emc,
const cspdbl_float *q1,     const cspdbl_float *q2,
cspdbl_float *einc,   const cspdbl_float *fcap,
cspdbl_float *fail,         cspdbl_float *falnm1,
cspdbl_float *efail,        cspdbl_float *fail2,
cspdbl_float *user,
cspdbl_float *efib,         cspdbl_float *emtx,
cspdbl_float *eshr,
const cspdbl_int   *mcmar,        cspdbl_int   *ierrcode)EXCOMP Subroutine User-defined composite material in a Nastran SOL700 Simulation&lt;/p&gt;
&lt;p&gt;140 User Defined Services User’s Guide
User Defined Subroutines
Main Index
{
return;
}
Fortran:
subroutine EXCOMP
+ (id,lenvec,ishrpr,
+  ymx,ymy,xnuy,sxy,syz,szx,
+  xt,xc,yt,yc,sc,
+  capa,cm,
+  ibegin,iend,nadvar,isubly,
+  sig1,sig2,sig4,
+  sig5,sig6,sig51,sig62,
+  d1,d2,d3,d4,d5,d6,d7,d8,
+  dout1,dout2,dout4,
+  eft,efc,esf,emt,emc,q1,q2,
+  einc,fcap,
+  fail,falnm1,efail,fail2,user,
+  efib,emtx,eshr,lmcmar,ierr_code)
integer(8),intent(in) :: id, lenvec, ishrpr, ibegin, iend
integer(8),intent(in) :: nadvar, isubly, lmcmar
real(8), intent(in) :: ymx, ymy, xnuy, sxy, syz, szx
real(8), intent(in) :: xt, xc, yt, yc, sc, capa
real(8), intent(in), dimension(lmcmar):: cm
real(8), intent(in), dimension(lenvec):: d1, d2, d3, d4, d5, d6
real(8), intent(in), dimension(lenvec):: d7, d8, dout1, dout2
real(8), intent(in), dimension(lenvec):: dout4, q1, q2
real(8), intent(in), dimension(lenvec,4):: fcap
real(8), intent(inout), dimension(lenvec):: sig1, sig2, sig4
real(8), intent(inout), dimension(lenvec):: sig5, sig6, sig51
real(8), intent(inout), dimension(lenvec):: sig62, eft, efc, esf
real(8), intent(inout), dimension(lenvec):: efib, emtx, eshr
real(8), intent(inout), dimension(lenvec):: emt, emc, einc, fail
real(8), intent(inout), dimension(lenvec):: falnm1, efail, fail2
real(8), intent(inout), dimension(lenvec,nadvar):: user
integer(8), intent(inout) :: ierr_code
return
end subroutine&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P8</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_008/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_008/</guid>
      <description>
        
        
        &lt;p&gt;141 CHAPTER 1
EXCOMP Subroutine
Main Index
Description of arguments:
id material id.
lenvec length of arrays.
ishrpr transverse shear correction index (TRANSHR in PSHELL1)
  0 : constant transverse shear correction
  2 : linear transverse shear correction
  3 : approximated transverse shear correction
ymx Young’s modulus in fiber dir.
ymy Young’s modulus in matrix dir.
xnuy Poisson’s ration nuyx.
sxy inplane shear modulus
syz transverse shear modulus
szx transverse shear modulus
xt fiber tensile strength
xc fiber compressive strength
yt matrix tensile strength
yc matrix compressive strength
sc shear strength
capa shear correction factor
cm material constants used by input
cm(1) E1 in MAT8
cm(2) E2 in MAT8
cm(3) not used
cm(4) NU12 in MAT8
cm(5) not used
cm(6) not used
cm(7) G12 in MAT8
cm(8) G1Z in MAT8
cm(9) G2Z in MAT8
cm(10) MID
cm(11) property degraing usage
  0.0 : no degraing&lt;/p&gt;
&lt;p&gt;142 User Defined Services User’s Guide
User Defined Subroutines
Main Index
  1.0 : degraing option is used
cm(12) PFDST in MAT8A
cm(13) TRSFAIL in MAT8A
  0.0 : SUBL
  1.0 : ELEM
cm(14) PRDFT in MAT8A
cm(15) PRDFC in MAT8A
cm(16) PRDMT in MAT8A
cm(17) PRDMC in MAT8A
cm(18) PRDSH in MAT8A
cm(19) F12 in MAT8A
cm(20) not used
cm(21) sound speed number: sound speed is sqrt(cm(21)/cm(50))
cm(22) not used
cm(23) not used
cm(24) not used
cm(25) not used
cm(26) S in MAT8A
cm(27) XT in MAT8A
cm(28) YT in MAT8A
cm(29) YC in MAT8A
cm(30) ALPHA in MAT8A
cm(31) XC in MAT8A
cm(32) PFD in MAT8A
  1.0: STEPS
  2.0: TIME
  3.0: VELOC
cm(33) VALUE in MAT8A
cm(34) FBTEN in MAT8A
  1.0: CHANG
  2.0: HILL
  3.0: TSAI&lt;/p&gt;
&lt;p&gt;143 CHAPTER 1
EXCOMP Subroutine
Main Index
  4.0: MODTSAI
  5.0: STRESS
  6.0: USER
  7.0: COMBINAT
  8.0: HASHIN
  9.0: USER1
cm(35) FBCOM in MAT8A. value is identical as cm(34)
cm(36) MXTEN in MAT8A. value is identical as cm(34)
cm(37) MXCOM in MAT8A. value is identical as cm(34)
cm(38) MXSHR in MAT8A. value is identical as cm(34)
cm(39)-cm(49) not used
cm(50) RHO in MAT8
cm(51) not used
cm(52) internal material type: 22.0
cm(53)-cm(57) not used
cm(58) output system
  0.0: element system
  1.0: fiber system
cm(59) usage of FT . It is always set to 1.0
cm(60) FT in MAT8A. It is always set to 9.0
cm(61) not used
ibegin begin element counter
iend end element counter
nadvar number of additional vars
  (see mat8a bulk data)
isubly sublayer number
sig1 sigma xx in fiber system
sig2 sigma yy in fiber system
sig4 sigma xy in fiber system
sig5 sigma yz in fiber system
sig6 sigma zx in fiber system
sig51 additional sigma yz due to linear shear correction&lt;/p&gt;
&lt;p&gt;144 User Defined Services User’s Guide
User Defined Subroutines
Main Index
sig62 additional sigma zx due to linear shear correction
d1 strain increment xx
d2 strain increment yy
d3 strain increment zz
d4 shear angle = 2.0 x strain increment xy
d5 strain increment yz
d6 strain increment zx
d7 additional strain increment yz due to linear transverse shear correction
d8 additional strain increment zx due to linear transverse shear correction
dout1 total xx-strain for output
dout2 total yy-strain for output
dout4 total xy-strain for output
eft fiber tension fail switch
  0: fail
  1: not fail
eft fiber compression fail switch
  0: fail
  1: not fail
esf shear fail switch
  0: fail
  1: not fail
emt matrix tenstion fail switch
  0: fail
  1: not fail
emc matrix compression fail switch
  0: fail
  1: not fail
q1 fiber axis rel to element sys
q2 matrix axis
einc internal energy increment
fcap for transverse shear correction
fail overall element fail switch&lt;/p&gt;
&lt;p&gt;145 CHAPTER 1
EXELAS Subroutine
Main Index
EXELAS
Description
The EXELAS  subroutine provides a mechanism to define a user defined elastic spring model with PELASEX.
Example
C++:
void EXELAS
(const cspdbl_int   *n,      const cspdbl_int   *m,
const cspdbl_int   *ix,     const cspdbl_int   *ic,
const cspdbl_float *prop,   const cspdbl_float *hisv,
const cspdbl_float *forceo, const cspdbl_float *c,
const cspdbl_float *di,     const cspdbl_float *v,
const cspdbl_float *urel,   const cspdbl_float *durel,falnm1 transverse shear failure index
only available when TRSFAIL in MAT8A is set to ELEM
  0: fail
  between 0 to 1: degrading transverse shear stress
  1: not fail
efail complete element failure
  0.0: fail
  1.0: not fail
fail2 one-dimensional time step suppression
user user history variables. the size is LENVEC,NADVAR
efib property degradation fiber mode
emtx property degradation matrix mode
eshr property degradation shear mode
lmcmar size of cm array - currently 61
ierr_code the returned error code
  0: success
  otherwise: fail
EXELAS Subroutine User-defined elastic spring in a Nastran SOL700 Simulation&lt;/p&gt;
&lt;p&gt;146 User Defined Services User’s Guide
User Defined Subroutines
Main Index
const cspdbl_float *vrel,   const cspdbl_float *xmass,
cspdbl_float *force,        cspdbl_float *stiff,
cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXELAS
+ (n,m,ix,ic,prop,hisv,forceo,c,di,v,urel,durel,
+  vrel,xmass,force,stiff,ierr_code)
integer(8),intent(in)               :: n,m
integer(8),intent(in),dimension(2)  :: ix, ic
real(8)   ,intent(in)               :: forceo,urel,durel,vrel
real(8)   ,intent(in),dimension(6)  :: prop
real(8)   ,intent(in),dimension(6)  :: hisv
real(8)   ,intent(in),dimension(3,2):: c
real(8)   ,intent(in),dimension(6,2):: di,v
real(8)   ,intent(in),dimension(2)  :: xmass
real(8)   ,intent(out)              :: force
real(8)   ,intent(inout)            :: stiff
integer(8),intent(inout)            :: ierr_code
return
end subroutine
N Element id
M        Property id
IX(2)    Connectivity: IX(1) =grid point at end 1
IC(2)    Component:
 IC(1) component at end 1 (between 1 and 6)
 IC(2) component at end 2 (between 1 and 6)
PROP(6) Properties as input on the PSPRUDS entry
HISV(6) History variables for the element. This array can be used by the user to store variables from one time
step to the next.
FORCEO   Force in the element at the previous time step
 C(3,2)   Deformed coordinates in the basic coordinate system:
 C(1:3,1) x, y, z, coordinates at end 1
 C(1:3,2) x, y, z, coordinates at end 2
DI (6,2) Incremental displacements in the basic coordinate system&lt;/p&gt;
&lt;p&gt;147 CHAPTER 1
EXEOS Subroutine
Main Index
EXEOS
Description
The EXEOS  subroutine provides a mechanism to the user to define equation of state model with EOSUDS in a simulation. DI(1:3,1) x, y, z, translational displacements of end 1
 DI(4:6,1) x, y, z, rotational displacements of end 1
 DI(1:3,2) x, y, z, translational displacements of end 2
 DI(4:6,2) x, y, z, rotational displacements 2
   These are incremental displacements; i.e., the displacements for this time step only.
V(6,2) Velocities in the basic coordinate system
 V(1:3,1) x, y, z, translational velocities of end 1
 V(4:6,1) x, y, z, rotational velocities of end 1
 V(1:3,2) x, y, z, translational velocities of end 2
 V(4:6,2) x, y, z, rotational velocities of end 2
A(6,2) Accelerations in the basic coordinate system
 A(1:3,1) x, y, z translational accelerations of end 1
 A(4:6,1) x, y, z rotational accelerations of end 1
 A(1:3,2) x, y, z, translational accelerations of end 2
 A(4:6,2) x, y, z, rotational accelerations of end 2
UREL    Relative displacement of the element; i.e., the displacement of end 2 in the spring direction minus
the displacement of end 1
DUREL   Relative incremental displacement of the element VREL
VREL Relative velocity of the end points of the element in the direction of the element
XMASS(2) Mass of the grid points at ends 1 and 2
force      Force in the element
stiff      Current stiffness of the element
ierr_code returned error code; 0=success, otherwise fail
EXEOS Subroutine User-defined equation of state model in a Nastran SOL 700 Simulation&lt;/p&gt;
&lt;p&gt;148 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Example
C++:
void EXEOS
(const cspdbl_int   *id,     const cspdbl_int   *lenvec,
const cspdbl_int   *ibegin, const cspdbl_int   *iend,
const cspdbl_float *rho,    const cspdbl_float *dv,
const cspdbl_float *devis,  const cspdbl_float *xmass,
const cspdbl_float *fburn,  const cspdbl_float *pold,
const cspdbl_float *sieold,
cspdbl_float *pnew,         cspdbl_float *sienew,
cspdbl_float *clnew,        cspdbl_float *grungm,
cspdbl_float *damage,       cspdbl_float *softe,
cspdbl_float *volpls,       cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXEOS
+ (id,lenvec,ibegin,iend,
+  rho,dv,devis,xmass,fburn,pold,sieold,
+  pnew,sienew,clnew,grungm,damage,
+  softe,volpls,ierr_code)
integer(8), intent(in) :: id, lenvec, ibegin, iend
real(8), dimension(lenvec), intent(in):: rho,dv,devis,xmass
real(8), dimension(lenvec), intent(in):: pold,sieold,fburn
real(8), dimension(lenvec), intent(inout):: pnew,sienew
real(8), dimension(lenvec), intent(inout):: clnew,grungm
real(8), dimension(lenvec), intent(inout):: damage,softe,volpls
integer(8), intent(inout) :: ierr_code
return
end subroutine
Description of arguments:
id id on EOSUDS entry
lenvec length of arrays.
ibegin start of the element loop.
iend end of the element loop.
rho element density.&lt;/p&gt;
&lt;p&gt;149 CHAPTER 1
EXFAIL Subroutine
Main Index
EXFAIL
Description
The EXFAIL  subroutine provides a mechanism to the user to define a simple material failure model with FAILUDS in a
Nastran SOL700 simulation.
Example
C++:
void  EXFAIL
(const cspdbl_int   *id,     const cspdbl_int   *lenvec,
const cspdbl_int   *ibegin, const cspdbl_int   *iend,
const cspdbl_float *eplas,  const cspdbl_float *effsts,
const cspdbl_float *pres,   const cspdbl_float *sie,
const cspdbl_float *rho,          cspdbl_float &lt;em&gt;ffail,
const cspdbl_int   &lt;em&gt;iusrzn,       cspdbl_int   &lt;em&gt;ierrcode)dv volume change of element.
devis viscous work term.
xmass mass of element.
fburn burn fraction of element (not type 8).
pold old pressure of element.
sieold old specific internal energy of element.
pnew new pressure of element.
sienew new specific internal energy of element.
clnew new sound speed of element.
grungm Gruneisen gamma of element (only type 11).
  p = a&lt;/em&gt;f(rho/rhoref) + b&lt;/em&gt;f(rho&lt;/em&gt;sie)
  where b = Gruneisen gamma.
damage array that allows the user to store an additional variable. Contents are transported and clumped. This
array can also be accessed within EXT_MATYLD and EXT_MATFAIL2.
softe same use as damage.
vlpl same use as damage.
ierr_code is the is returned error code; 0 = success, otherwise fail
EXFAIL Subroutine User-defined simplified material failure model&lt;/p&gt;
&lt;p&gt;150 User Defined Services User’s Guide
User Defined Subroutines
Main Index
{
return;
}
Fortran:
subroutine EXFAIL
+ (id,lenvec,
+  ibegin,iend,eplas,effsts,pres,sie,rho,ffail,iusrzn,ierr_code)
integer(8), intent(in):: id, lenvec,ibegin,iend
real(8), intent(in), dimension(lenvec):: eplas,effsts
real(8), intent(in),  dimension(lenvec):: pres,sie,rho
real(8), intent(inout), dimension(lenvec):: ffail
integer(8), dimension(lenvec):: iusrzn
integer(8), intent(inout)::  ierr_code
return
end subroutine
Description of arguments:
EXFAIL1id id on FAILUDS entry
lenvec length of arrays.
ibegin start of the element loop.
iend end of the element loop.
eplas element effective plastic strain.
effsts element effective stress.
pres element pressure.
sie element specific internal energy.
rho element density.
iusrzn user numbers of elements.
ierr_code is the is returned error code; 0 = success, otherwise fail
EXFAIL1 Subroutine User-defined material failure model&lt;/p&gt;
&lt;p&gt;151 CHAPTER 1
EXFAIL1 Subroutine
Main Index
Description
The EXFAIL1  subroutine provides a mechanism to the user to define a more advanced material failure model with
FAILUDS in a simulation. The failure model is available for orthotropic materials only. The FAILUDS entry must be
referenced on the DMATOR entry.
Example
C++:
void EXFAIL1
(const cspdbl_int   *id,     const cspdbl_int   *lenvec,
const cspdbl_int   *ibegin, const cspdbl_int   *iend,
const cspdbl_int   *iusrzn,
const cspdbl_float *txx,    const cspdbl_float *tyy,
const cspdbl_float *tzz,    const cspdbl_float *txy,
const cspdbl_float *tyz,    const cspdbl_float *txz,
const cspdbl_float *depxx,  const cspdbl_float *depyy,
const cspdbl_float *depzz,  const cspdbl_float *depxy,
const cspdbl_float *depyz,  const cspdbl_float *depxz,
const cspdbl_float *epxx,   const cspdbl_float *epyy,
const cspdbl_float *epzz,   const cspdbl_float *epxy,
const cspdbl_float *epyz,   const cspdbl_float *epxz,
const cspdbl_float *exx,    const cspdbl_float *eyy,
const cspdbl_float *ezz,    const cspdbl_float *exy,
const cspdbl_float *eyz,    const cspdbl_float *exz,
const cspdbl_float *gxy,    const cspdbl_float *gyz,
const cspdbl_float *gzx,
const cspdbl_float *usrvr1, const cspdbl_float *usrvr2,
cspdbl_float *tstepzn,      cspdbl_float *ffail,
cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXFAIL1
+ (id,lenvec,ibegin,iend,iusrzn,
+  txx,tyy,tzz,txy,tyz,txz,
+  depxx,depyy,depzz,depxy,depyz,depxz,
+  epxx,epyy,epzz,epxy,epyz,epxz,
+  exx,eyy,ezz,exy,eyz,exz,
+  gxy,gyz,gzx,
+  usrvr1,usrvr2,
+  tstepzn,ffail,
+  ierr_code)
integer(8), intent(in):: id, lenvec,ibegin,iend
integer(8), intent(in),dimension(lenvec):: iusrzn
real(8), intent(inout),dimension(lenvec):: txx,tyy,tzz,txy&lt;/p&gt;
&lt;p&gt;152 User Defined Services User’s Guide
User Defined Subroutines
Main Index
real(8), intent(inout),dimension(lenvec):: tyz,txz,depxx
real(8), intent(inout),dimension(lenvec):: depyy,depzz,depxy
real(8), intent(inout),dimension(lenvec):: depyz,depxz
real(8), intent(in),dimension(lenvec):: epxx,epyy,epzz
real(8), intent(in),dimension(lenvec):: epxy,epyz,epxz
real(8), intent(inout),dimension(lenvec):: exx,eyy,ezz,exy,eyz,exz
real(8), intent(inout),dimension(lenvec):: gxy,gyz,gzx
real(8), intent(inout),dimension(lenvec):: usrvr1,usrvr2
real(8), intent(inout),dimension(lenvec):: tstepzn,ffail
integer(8), intent(inout)::  ierr_code
return
end subroutine
Description of arguments:
id id on FAILUDS entry.
lenvec length of arrays.
ibegin begin element counter.
iend end element counter.
iusrzn user numbers of elements.
txx&amp;hellip;tzz element normal stress components.
txy&amp;hellip;tyz element shear stress components.
depsxx&amp;hellip;depszz element normal strain increments.
depsxy&amp;hellip;depsyz element shear strain increments.
epsxx&amp;hellip;epszz element normal (last cycle) strain components.
epsxy&amp;hellip;epsyz element shear (last cycle) strain components.
exx&amp;hellip;gzx element elasticity matrix components.
sxx..sxz deviatoric stress tensor of the current cycle after radial scale back.
usrvr1, usrvr2 element user variables.
tstepzn element time step.
ffail element failure flag:
  0 : element has failed
  1 : element has not failed
ierr_code is the returned error code; 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;153 CHAPTER 1
EXFAIL2 Subroutine
Main Index
EXFAIL2
Description
The EXFAIL2  subroutine provides a mechanism to the user to define a material failure model with FAILUDS in a
simulation. This model is only supported by the multi-material solver with strength.
Example
C++:
void EXFAIL2
(const cspdbl_int   *id,      const cspdbl_int   *lenvec,
const cspdbl_int   *ibegin,  const cspdbl_int   *iend,
const cspdbl_float *eplas,   const cspdbl_float *effsts,
const cspdbl_float *pres,    const cspdbl_float *sie,
const cspdbl_float *rho,           cspdbl_float *damage,
cspdbl_float *softe,         cspdbl_float *volpls,
const cspdbl_float *depi,
cspdbl_float *sxx,           cspdbl_float *syy,
cspdbl_float *szz,           cspdbl_float *sxy,
cspdbl_float *syz,           cspdbl_float *sxz,
const cspdbl_float *sxxo,    const cspdbl_float *syyo,
const cspdbl_float *szzo,    const cspdbl_float *sxyo,
const cspdbl_float *syzo,    const cspdbl_float *sxzo,
const cspdbl_float *shear,         cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXFAIL2
+ (id,lenvec,ibegin,iend,
+  eplas,effsts,pres,sie,rho,damage,
+  softe,volpls,depi,
+  sxx , syy , szz , sxy , syz , sxz ,
+  sxxo, syyo, szzo, sxyo, syzo, sxzo,
+  shear,ierr_code)
integer(8), intent(in):: id, lenvec,ibegin,iend
real(8), intent(in),dimension(lenvec):: eplas,effsts,pres
real(8), intent(in),dimension(lenvec):: depi,sie,rho,shear
real(8), intent(in),dimension(lenvec):: sxxo, syyo, szzo
real(8), intent(in),dimension(lenvec):: sxyo, syzo, sxzo
real(8), intent(inout),dimension(lenvec)::sxx,syy,szz,sxy,syz,sxzEXFAIL2 Subroutine User-defined simplified material failure model&lt;/p&gt;
&lt;p&gt;154 User Defined Services User’s Guide
User Defined Subroutines
Main Index
real(8), intent(inout),dimension(lenvec)::damage,softe,volpls
integer(8), intent(inout)::  ierr_code
return
end subroutine
Description of arguments:
EXFLOW
Description
The EXFLOW  subroutine provides a mechanism to the user to define flow boundary with FLOWUDS in a Euler
simulation. It is only available for single hydrodynamic materials, or single materials with strength material problems.id id on FAILUDS entry
lenvec length of arrays.
ibegin begin element counter.
iend end element counter.
eplas element effective plastic strain.
effsts element effective stress.
pres old element pressure.
sie old element specific internal energy.
rho element density.
damage array that allows the user to store an additional variable. Contents are transported and clumped.
This array can also be accessed within EXYLD and EXFAIL2.
softe same use as damage.
volpls same use as damage.
depi plastic strain increment of the current cycle.
sxx..sxz deviatoric stress tensor of the current cycle after radial scale back.
sxx0..sxzo deviatoric stress tensor from the previous cycle.
shear shear modulus.
ierr_code is the returned error code; 0 = success, otherwise fail.
EXFLOW Subroutine User-defined flow boundary in a Simulation&lt;/p&gt;
&lt;p&gt;155 CHAPTER 1
EXFLOW Subroutine
Main Index
Example
C++:
void EXFLOW
(const cspdbl_int   *id,     const cspdbl_int   *lenvec,
const cspdbl_int   *iusrzn,
const cspdbl_float *pzon,   const cspdbl_float *qzon,
const cspdbl_float *uxzon,  const cspdbl_float *uyzon,
const cspdbl_float *uzzon,
const cspdbl_float *rhozon, const cspdbl_float *siezon,
cspdbl_float *pfac,
cspdbl_float *uxfac,        cspdbl_float *uyfac,
cspdbl_float *uzfac,
cspdbl_float *rhofac,       cspdbl_float *siefac,
const cspdbl_float *sx,     const cspdbl_float *sy,
const cspdbl_float *sz,
const cspdbl_float *xminel, const cspdbl_float *xmaxel,
const cspdbl_float &lt;em&gt;yminel, const cspdbl_float &lt;em&gt;ymaxel,
const cspdbl_float &lt;em&gt;zminel, const cspdbl_float &lt;em&gt;zmaxel,
cspdbl_int   &lt;em&gt;imatno,       cspdbl_int   &lt;em&gt;iflwtp,
const cspdbl_int   &lt;em&gt;ibegin, const cspdbl_int   &lt;em&gt;iend,
cspdbl_int   &lt;em&gt;ierrcode)
{
return;
}
Fortran:
subroutine EXFLOW
+ (id,lenvec,iusrzn,pzon,qzon,uxzon,
+  uyzon,uzzon,rhozon,siezon,pfac,uxfac,
+  uyfac,uzfac,rhofac,siefac,sx,sy,sz,
+  xminel,xmaxel,yminel,ymaxel,zminel,zmaxel,
+  imatno,iflwtp,ibegin,iend,ierr_code)
integer(8),intent(in) :: id, lenvec, ibegin, iend
integer(8),intent(inout) :: iflwtp
real(8), intent(in),dimension(&lt;/em&gt;):: pzon, qzon, uxzon, uyzon
real(8), intent(in),dimension(&lt;/em&gt;):: uzzon, rhozon,siezon
real(8), intent(inout),dimension(&lt;/em&gt;):: pfac, uxfac, uyfac, uzfac
real(8), intent(inout),dimension(&lt;/em&gt;):: rhofac,siefac
integer(8),intent(inout),dimension(&lt;/em&gt;):: imatno
integer(8),intent(in), dimension(&lt;/em&gt;):: iusrzn
real(8), intent(in),dimension(&lt;/em&gt;)::  sx, sy, sz
real(8), intent(in),dimension(&lt;/em&gt;):: xminel,xmaxel,yminel
real(8), intent(in),dimension(&lt;/em&gt;):: ymaxel,zminel,zmaxel
integer(8), intent(inout) :: ierr_code
return
end subroutine&lt;/p&gt;
&lt;p&gt;156 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description of arguments:
id id of the FLOWUD boundary
lenvec length of arrays.
iusrzn user numbers of element.
pzon pressure in the element.
qzon artificial viscosity of the element.
uxzon x-velocity of element.
uyzon y-velocity of element.
uzzon z-velocity of element.
rhozon density of element.
siezon specific internal energy element.
pfac pressure at boundary face.
uxfac x-velocity at boundary face.
uyfac y-velocity at boundary face.
uzfac z-velocity at boundary face.
rhofac density of inflowing material.
sx x-component of the face normal.
sy y-component of the face normal.
sz z-component of the face normal.
siefac specific internal energy of inflowing material.
xminel minimal x-coordinate of the boundary face.
xmaxel maximal x-coordinate of the boundary face.
yminel minimal y-coordinate of the boundary face.
ymaxel maximal y-coordinate of the boundary face.
zminel minimal z-coordinate of the boundary face.
zmaxel maximal z-coordinate of the boundary face.
imatno user number of the inflowing material.&lt;/p&gt;
&lt;p&gt;157 CHAPTER 1
EXFLOW3 Subroutine
Main Index
EXFLOW3
Description
The EXFLOW3  subroutine provides a mechanism to the user to define flow boundary with FLOWUDS in a Euler
simulation. MULTI must be set to ON and therefore the use of this routine is only available for the multiple material Euler
solver.
Example
C++:
void EXFLOW3
(const cspdbl_int   *id,     const cspdbl_int   *lenvec,
const cspdbl_int   *iusrzn, const cspdbl_float *pzon,
const cspdbl_float *qzon,
const cspdbl_float *uxzon,  const cspdbl_float *uyzon,
const cspdbl_float *uzzon,
const cspdbl_float *rhozon, const cspdbl_float *siezon,
const cspdbl_float *fmatzon,
cspdbl_float *pfac,
cspdbl_float *uxfac,        cspdbl_float *uyfac,
cspdbl_float *uzfac,
cspdbl_float *rhofac,       cspdbl_float *siefac,
cspdbl_float *fmatfac,
const cspdbl_float *sx,     const cspdbl_float *sy,
const cspdbl_float *sz,
const cspdbl_float *xminf,  const cspdbl_float *xmaxf,
const cspdbl_float *yminf,  const cspdbl_float *ymaxf,
const cspdbl_float *zminf,  const cspdbl_float *zmaxf,
cspdbl_int   *imateul,const cspdbl_int   *lmmult,ifltwp flow type switch:
0: both in and out flow is allowed
1: only outflow is allowed
2: only inflow is allowed
ibegin begin element counter.
iend end element counter.
ierr_code is the returned error code; 0 = success, otherwise fail.
EXFLOW3 Subroutine User-defined flow boundary in a Nastran SOL 700 simulation&lt;/p&gt;
&lt;p&gt;158 User Defined Services User’s Guide
User Defined Subroutines
Main Index
cspdbl_int   *iflwtp,       cspdbl_int   *nmateul,
const cspdbl_int   *ibegin, const cspdbl_int   *iend,
cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXFLOW3
+  (id,lenvec,iusrzn,pzon,qzon,uxzon,
+   uyzon,uzzon,rhozon,siezon,fmatzon,pfac,uxfac,
+   uyfac,uzfac,rhofac,siefac,fmatfac,sx,sy,sz,
+   xminf,xmaxf,yminf,ymaxf,zminf,zmaxf,
+   imateul,lmmult,iflwtp,nmateul,ibegin,iend,
+   ierr_code)
integer(8),intent(in)    :: id, lenvec,  ibegin, iend, lmmult
integer(8),intent(inout) :: iflwtp, nmateul
real(8), intent(in),dimension(lenvec):: pzon, qzon, uxzon, uyzon
real(8), intent(in),dimension(lenvec):: uzzon
real(8), intent(in),dimension(lenvec,lmmult):: rhozon, siezon
real(8), intent(in),dimension(lenvec,lmmult):: fmatzon
real(8), intent(in),dimension(lenvec):: xminf,xmaxf,yminf,ymaxf
real(8), intent(in),dimension(lenvec):: zminf,zmaxf,sx,sy,sz
real(8), intent(inout),dimension(lenvec,lmmult):: uxfac, uyfac
real(8), intent(inout),dimension(lenvec,lmmult):: uzfac, fmatfac
real(8), intent(inout),dimension(lenvec,lmmult):: rhofac, siefac
real(8), intent(inout),dimension(lenvec):: pfac
integer(8),intent(inout),dimension(lmmult):: imateul
integer(8),intent(in),dimension(lenvec):: iusrzn
integer(8),intent(inout) :: ierr_code
return
end subroutine
Description of arguments:
id id of the FLOWUDS boundary
lenvec length of arrays.
iusrzn user numbers of elements.
pzon pressure in the element.
qzon artificial viscosity of the element
uxzon x-velocity of element.
uyzon y-velocity of element.&lt;/p&gt;
&lt;p&gt;159 CHAPTER 1
EXFLOW3 Subroutine
Main Index
uzzon z-velocity of element.
rhozon(,nd) density of element for Eulerian material  nd.
  the user number of Eulerian material  nd is imateul(nd) .
siezon(,nd) specific internal energy element for Eulerian material  nd.
fmatzon(,nd) material fraction element for Eulerian material  nd.
pfac pressure at boundary face.
uxfac x-velocity at boundary face.
uyfac y-velocity at boundary face.
uzfac z-velocity at boundary face.
rhofac(,nd) density of inflowing material.
siefac(,nd) specific internal energy of inflowing material
fmatfac(,nd) material fraction of face.
sx x-component of the face normal.
sy y-component of the face normal.
sz z-component of the face normal.
xminf minimal x-coordinate of the boundary face.
xmaxf maximal x-coordinate of the boundary face.
yminf minimal y-coordinate of the boundary face.
ymaxf maximal y-coordinate of the boundary face.
zminf minimal z-coordinate of the boundary face.
zmaxf maximal z-coordinate of the boundary face.
imateul list of Eulerian materials.
lmmult maximal number of Euler materials that is allowed.
ifltwp flow type switch:
0: both in and out flow is allowed
1: only outflow is allowed
2: only inflow is allowed
nmateul number of eulerian materials.
ibegin begin element counter.
iend end element counter.
ierr_code is the returned error code; 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;160 User Defined Services User’s Guide
User Defined Subroutines
Main Index
EXFUNC
Description
The EXFUNC  subroutine provides a mechanism to the user to define arbitrary function with TABLUDS in a simulation.
Example
C++:
void EXFUNC
(const cspdbl_int   *id,
const cspdbl_float *xval,         cspdbl_float *yval,
const cspdbl_int   *numval,       cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXFUNC
+ (id,xval,yval,numval,ierr_code)
integer(8), intent(in):: id, numval
real(8), intent(in)   ,dimension(numval):: xval
real(8), intent(inout),dimension(numval):: yval
integer(8), intent(inout)::  ierr_code
return
end subroutine
Description of arguments:EXFUNC Subroutine User-defined arbitrary function in a Nastran SOL 700 Simulation
id id of the function defined on input.
xval(numval) x-value that the function requires (time).
yval(numval) value to be returned by the function.
Note that the y-value is multiplied by the scale factor defined on the load entry.
numval number of values.
ierr_code returned error code, 0 = success, otherwise fail.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P9</title>
      <link>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_009/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/msc_nastran_2024.1_user_defined_services_user_guide/msc_nastran_2024.1_user_defined_services_user_guide_009/</guid>
      <description>
        
        
        &lt;p&gt;161 CHAPTER 1
EXINIT Subroutine
Main Index
EXINIT
Description
The EXINIT subroutine provides a mechanism to the user to define an initial condition with TICEUDS in a simulation.
Example
C++:
void EXINIT
(const cspdbl_char  *cname,   const cspdbl_int   *lennam,
const cspdbl_int   *lenvec,  const cspdbl_int   *iusrzn,
const cspdbl_int   *ibegin,  const cspdbl_int   *iend,
cspdbl_float *density,       cspdbl_float *sie,
cspdbl_float *xvel,          cspdbl_float *yvel,
cspdbl_float *zvel,
const cspdbl_int   *ivoid,   const cspdbl_int   *nummat,
const cspdbl_float *xminel,  const cspdbl_float *xmaxel,
const cspdbl_float *yminel,  const cspdbl_float *ymaxel,
const cspdbl_float *zminel,  const cspdbl_float *zmaxel,
cspdbl_int   *ierrcode)&lt;/p&gt;
&lt;p&gt;{
return;
}
Fortran:
subroutine EXINIT
+ (cname,lennam,lenvec,iusrzn,
+  ibegin,iend, density, sie, xvel, yvel, zvel,
+  ivoid,nummat,
+  xminel,xmaxel,yminel,ymaxel,zminel,zmaxel,
+  ierr_code)
integer(8), intent(in) :: lennam, lenvec,ibegin,iend
character(lennam) :: cname
integer(8), intent(in), dimension(lenvec):: iusrzn,ivoid,nummat
real(8), intent(inout), dimension(lenvec):: density, sie
real(8), intent(inout), dimension(lenvec):: xvel, yvel, zvel
real(8), intent(in), dimension(lenvec):: xminel,xmaxel,yminel
real(8), intent(in), dimension(lenvec):: ymaxel,zminel,zmaxel
integer(8), intent(inout) :: ierr_code
return
end subroutineEXINIT Subroutine User-defined initial condition in a Nastran SOL 700 Simulation&lt;/p&gt;
&lt;p&gt;162 User Defined Services User’s Guide
User Defined Subroutines
Main Index
Description of arguments:
EXOUT
Description
The EXOUT subroutine provides a mechanism to the user to define an output request with output request NLOUTUD
in a simulation.cname name of the boundary. Is given by the value of  sid on the  TICEUDS  entry.
lennam length of  cname .
lenvec length of arrays.
iusrzn user numbers of elements.
ibegin begin element counter.
iend end element counter.
density density of element.
sie specific internal energy element.
uxvel x-velocity of element/ gridpoint.
uyvel y-velocity of element/ gridpoint.
uzvel z-velocity of element/ gridpoint.
ivoid void flag of element.
nummat number of materials in element.
xminel minimal x-coordinate of element/ gridpoint.
xmaxel maximal x-coordinate of element/ gridpoint.
yminel minimal y-coordinate of element/ gridpoint.
ymaxel maximal y-coordinate of element/ gridpoint.
zminel minimal z-coordinate of element/ gridpoint.
zmaxel maximal z-coordinate of element/ gridpoint.
ierr_code is the returned error code; 0 = success, otherwise fail.
EXOUT Subroutine User-defined output request in a Nastran SOL 700 Simulation&lt;/p&gt;
&lt;p&gt;163 CHAPTER 1
EXOUT Subroutine
Main Index
Example
C++:
void EXOUT
(const cspdbl_char  *cname,   const cspdbl_int   *lennam,
const cspdbl_int   *lenvec,  const cspdbl_int   *iusrzn,
const cspdbl_int   *nztype,
const cspdbl_int   *ibegin,  const cspdbl_int   *iend,
const cspdbl_int   *nmziid,  const cspdbl_int   *nmzxid,
cspdbl_int   *ielmvars,      cspdbl_float &lt;em&gt;xelmvars,
const cspdbl_float &lt;em&gt;xminel,  const cspdbl_float &lt;em&gt;xmaxel,
const cspdbl_float &lt;em&gt;yminel,  const cspdbl_float &lt;em&gt;ymaxel,
const cspdbl_float &lt;em&gt;zminel,  const cspdbl_float &lt;em&gt;zmaxel,
cspdbl_int   &lt;em&gt;iwork,         cspdbl_float &lt;em&gt;xwork,
cspdbl_int   &lt;em&gt;ierrcode)
{
return;
}
Fortran:
subroutine EXOUT
+ (cname,lennam,lenvec,iusrzn,nztype,
+  ibegin,iend,nmziid,nmzxid,ielmvars,xelmvars,
+  xminel,xmaxel,yminel,ymaxel,zminel,zmaxel,
+  iwork,xwork,ierr_code)
character(&lt;/em&gt;) :: cname
integer&lt;/em&gt;8,intent(in)::lennam,ibegin,iend,lenvec,nmziid
integer&lt;/em&gt;8,intent(in)::nmzxid,nztype
integer&lt;/em&gt;8,intent(in)::iusrzn(lenvec)
integer&lt;/em&gt;8,intent(inout)::ielmvars(nmziid,lenvec),iwork(lenvec)
real&lt;/em&gt;8,intent(in)::xminel(lenvec),xmaxel(lenvec)
real&lt;/em&gt;8,intent(in)::yminel(lenvec),ymaxel(lenvec)
real&lt;/em&gt;8,intent(in)::zminel(lenvec),zmaxel(lenvec)
real&lt;/em&gt;8,intent(inout)::xelmvars(nmzxid,lenvec)
real&lt;/em&gt;8,intent(inout)::xwork(lenvec)
integer(8),intent(inout) :: ierr_code
return
end subroutine
Description of arguments:
cname name of the output request. Is given by the value of &amp;ldquo;nid&amp;rdquo; on the NLOUTUD entry.
lennam length of  cname .
lenvec length of arrays.&lt;/p&gt;
&lt;p&gt;164 User Defined Services User’s Guide
User Defined Subroutines
Main Index
iusrzn user numbers of elements.
nztype type of element:
2 Beam, rod, sprint and damper
3 T riangular shell
4 Quadratic shell
5 Membrane
6 Dummy triangular
7 Dummy quadratic
8 Langrangian solid
9 Eulerian solid (hydrodynamic)
10 Eulerian solid (with strength)
11 Eulerian solid (multimaterial)
ibegin start element counter.
iend end element counter.
nmiid number of integer variables.
nmxid number of real variables.
ivars(nv,nz) integer variable  nv for element  nz.
  A list of integer element variables is given in the  OUT file.
xvars(nv,nz) real variable nv for element nz.
  A list of real element variables is given in the  OUT file.
xminel minimal x-coordinate of the element.
xmaxel maximal x-coordinate of the element.
yminel minimal y-coordinate of the element.
ymaxel maximal y-coordinate of the element.
zminel minimal z-coordinate of the element.
zmaxel maximal z-coordinate of the element.
iwork integer work memory.&lt;/p&gt;
&lt;p&gt;165 CHAPTER 1
EXPOR Subroutine
Main Index
EXPOR
Description
The EXPOR subroutine provides a mechanism to the user to define a porosity model with PORUDS in a simulation.
Example
C++:
void EXPOR
(const cspdbl_int   *id,      const cspdbl_int   *lenvec,
const cspdbl_int   *ibegin,  const cspdbl_int   *iend,
const cspdbl_int   *ieul,
const cspdbl_float *press,   const cspdbl_float *densty,
const cspdbl_float *sie,
const cspdbl_float *xvel,    const cspdbl_float *yvel,
const cspdbl_float *zvel,
const cspdbl_float *ux,      const cspdbl_float *uy,
const cspdbl_float *uz,
const cspdbl_float *area,
const cspdbl_float *sx,      const cspdbl_float *sy,
const cspdbl_float *sz,
const cspdbl_float *visc,          cspdbl_float *vtrans,
cspdbl_float *dmass,
cspdbl_float *fpress,        cspdbl_float *fsie,
cspdbl_float *xvelf,         cspdbl_float *yvelf,
cspdbl_float *zvelf,
cspdbl_float *coeffv,        cspdbl_int   *imatno,
cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXPOR
+ (id,lenvec,ibegin,iend,ieul,
+  press,densty,sie,xvel,yvel,zvel,ux,uy,uz,
+  area,sx,sy,sz,visc,vtrans,dmass,fpress,fsie,
+  xvelf,yvelf,zvelf,coeffv,imatno,ierr_code)xwork real work memory.
ierr_code returned error code; 0 = success, otherwise fail.
EXPOR Subroutine User-defined porosity model in a Nastran SOL 700 Simulation&lt;/p&gt;
&lt;p&gt;166 User Defined Services User’s Guide
User Defined Subroutines
Main Index
integer(8),intent(in), dimension(&lt;em&gt;):: ieul
integer(8),intent(inout), dimension(&lt;/em&gt;):: imatno
integer(8),intent(in) :: id, lenvec, ibegin, iend
real(8), intent(in), dimension(&lt;em&gt;):: press,densty,sie
real(8), intent(in), dimension(&lt;/em&gt;):: xvel,yvel,zvel,ux,uy,uz
real(8), intent(in), dimension(&lt;em&gt;):: area,sx,sy,sz,visc
real(8), intent(inout), dimension(&lt;/em&gt;):: vtrans,dmass,fpress
real(8), intent(inout), dimension(&lt;em&gt;):: fsie,xvelf,yvelf,zvelf
real(8), intent(inout), dimension(&lt;/em&gt;):: coeffv
integer(8), intent(inout) :: ierr_code
return
end subroutine
Description of arguments:
id id of the PORUDS entry
lenvec length of arrays.
ibegin begin segment counter.
iend end segment counter.
ieul user number of euler element connected to the segment.
press pressure in the element connected to the segment.
density density in the element connected to the segment.
sie sie in the element.
xvel x-velocity component of the element.
yvel y-velocity component of the element.
zvel z-velocity component of the element.
ux x-velocity component of the moving face the segment is part of.
uy y-velocity component of the moving face.
uz z-velocity component of the moving face.
area total segment area.
sx x-component of the segment normal.
sy y-component of the segment normal.
sz z-component of the segment normal.
visc artificial viscosity of the element connected to a segment.
vtrans transported volume through the segment.&lt;/p&gt;
&lt;p&gt;167 CHAPTER 1
EXSHR Subroutine
Main Index
EXSHR
Description
The EXSHR subroutine provides a mechanism to the user to define a shear model with SHRUDS in a simulation.
Example
C++:
void EXSHR
( const cspdbl_int   *id,    const cspdbl_int   *lenvec,
const cspdbl_float *exx,   const cspdbl_float *eyy,
const cspdbl_float *ezz,   const cspdbl_float *exy,
const cspdbl_float *eyz,   const cspdbl_float *ezx,
const cspdbl_float *pres,  const cspdbl_float *edis,
const cspdbl_float *sie,   const cspdbl_float *rho,
const cspdbl_float *fburn, const cspdbl_float *zmass,
cspdbl_float *shear, const cspdbl_int   *ibegin,
const cspdbl_int   *iend,        cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXSHR
+ (id,lenvec,
+  exx,eyy,ezz,exy,eyz,ezx,
+  pres,edis,sie,rho,fburn,zmass,shear,dmass transported mass through the segment.
fpress pressure at the segment face.
fsie specific internal energy at the segment face.
xvelf x-velocity component of the fluid at the segment face.
yvelf y-velocity component of the fluid at the segment face.
zvelf z-velocity component of the fluid at the segment face.
coeffv porosity coefficient of the segment.
imatno user number of the inflowing material.
ierr_code returned error code; 0 = success, otherwise fail.
EXSHR Subroutine User-defined shear model in a Nastran SOL 700 Simulation&lt;/p&gt;
&lt;p&gt;168 User Defined Services User’s Guide
User Defined Subroutines
Main Index
+  ibegin,iend,ierr_code)
integer(8),intent(in)    :: id, lenvec, ibegin, iend
real(8), intent(in),dimension(lenvec):: exx,eyy,ezz,exy,eyz,ezx
real(8), intent(in),dimension(lenvec):: pres,edis,sie,rho
real(8), intent(in),dimension(lenvec):: fburn,zmass
real(8), intent(inout),dimension(lenvec):: shear
integer(8),intent(inout)    :: ierr_code
return
end subroutine
Description of arguments:
EXSPR
Description
The EXSPR  subroutine provides a mechanism to define a user defined elastic spring model with PSPREX.id id on SHRUDS entry
lenvec length of arrays.
exx..ezx element strain components.
pres element pressure.
edis element distortional energy.
sie element specific internal energy.
rho element density.
fburn element burn fraction.
zmass mass of element.
shear shear modulus.
ibegin begin of the element loop.
iend end of the element loop.
ierr_code is the is returned error code, 0 = success, otherwise fail.
EXSPR Subroutine User-defined elastic spring in a Nastran SOL 700 Simulation&lt;/p&gt;
&lt;p&gt;169 CHAPTER 1
EXSPR Subroutine
Main Index
Example
C++:
void EXSPR
(const cspdbl_int   *n,      const cspdbl_int   *m,
const cspdbl_int   *ix,     const cspdbl_int   *ic,
const cspdbl_float *prop,   const cspdbl_float *hisv,
const cspdbl_float *forceo, const cspdbl_float *c,
const cspdbl_float *di,     const cspdbl_float *v,
const cspdbl_float *urel,   const cspdbl_float *durel,
const cspdbl_float *vrel,   const cspdbl_float *xmass,
cspdbl_float *force,        cspdbl_float *stiff,
cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXSPR
+ (n,m,ix,ic,prop,hisv,forceo,c,di,v,urel,durel,
+  vrel,xmass,force,stiff,ierr_code)
integer(8),intent(in)               :: n,m
integer(8),intent(in),dimension(2)  :: ix, ic
real(8)   ,intent(in)               :: forceo,urel,durel,vrel
real(8)   ,intent(in),dimension(6)  :: prop
real(8)   ,intent(in),dimension(6)  :: hisv
real(8)   ,intent(in),dimension(3,2):: c
real(8)   ,intent(in),dimension(6,2):: di,v
real(8)   ,intent(in),dimension(2)  :: xmass
real(8)   ,intent(out)              :: force
real(8)   ,intent(inout)            :: stiff
integer(8),intent(inout)            :: ierr_code
return
end subroutine
Description of arguments:
N        Element id
M        Property id
 IX(2)    Connectivity: IX(1) = grid point at end 1
 IC(2)    Component:
 IC(1) component at end 1 (between 1 and 6)&lt;/p&gt;
&lt;p&gt;170 User Defined Services User’s Guide
User Defined Subroutines
Main Index
 IC(2) component at end 2 (between 1 and 6)
PROP(6) Properties as input on the PSPRUDS entry
HISV(6) History variables for the element. This array can be used by the user to store variables from one
time step to the next.
FORCEO   Force in the element at the previous time step
C(3,2)   Deformed coordinates in the basic coordinate system:
 C(1:3,1) x, y, z, coordinates at end 1
 C(1:3,2) x, y, z, coordinates at end 2
DI (6,2) Incremental displacements in the basic coordinate system
 DI(1:3,1) x, y, z, translational displacements of end 1
 DI(4:6,1) x, y, z, rotational displacements of end 1
 DI(1:3,2) x, y, z, translational displacements of end 2
 DI(4:6,2) x, y, z, rotational displacements 2
  These are incremental displacements; i.e., the displacements for this time step only.
V(6,2) Velocities in the basic coordinate system
V(1:3,1) x, y, z, translational velocities of end 1
V(4:6,1) x, y, z, rotational velocities of end 1
V(1:3,2) x, y, z, translational velocities of end 2
V(4:6,2) x, y, z, rotational velocities of end 2
A(6,2) Accelerations in the basic coordinate system
A(1:3,1) x, y, z translational accelerations of end 1
A(4:6,1) x, y, z rotational accelerations of end 1
A(1:3,2) x, y, z, translational accelerations of end 2
A(4:6,2) x, y, z, rotational accelerations of end 2
UREL Relative displacement of the element; i.e., the displacement of end 2 in the spring direction
minus the displacement of end 1
DUREL   Relative incremental displacement of the element  VREL
VREL Relative velocity of the end points of the element in the direction of the element
XMASS(2) Mass of the grid points at ends 1 and 2
force     Force in the element
stiff     Current stiffness of the element
ierr_code  returned error code; 0 = success, otherwise fail&lt;/p&gt;
&lt;p&gt;171 CHAPTER 1
EXTVEL Subroutine
Main Index
EXTVEL
Description
The EXTVEL  subroutine provides a mechanism to the user to define enforced motion at grid points in a simulation.
Example
C++:
void EXTVEL
(const cspdbl_int   *id,    const cspdbl_int   *ngp,
cspdbl_float *xpos,        cspdbl_float *ypos,
cspdbl_float *zpos,        cspdbl_float *xvel,
cspdbl_float *yvel,        cspdbl_float *zvel,
cspdbl_float *xavel,       cspdbl_float *yavel,
cspdbl_float *zavel,       cspdbl_float *pmass,
cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXTVEL
+ (ilid,ngp,xpos,ypos,zpos,
+  xvel,yvel,zvel,xavel,yavel,zavel,pmass,
+  ierr_code)
integer(8),intent(in)  :: ilid, ngp
real(8), intent(inout) :: xpos, ypos, zpos
real(8), intent(inout) :: xvel, yvel, zvel
real(8), intent(inout) :: xavel, yavel, zavel, pmass
integer(8), intent(inout) :: ierr_code
return
end subroutine
Description of arguments:EXTVEL Subroutine User-defined enforced motion at grid points
ilid lid of the FORCUDS entry.
ngp user node id.
xpos x coordinate of node.&lt;/p&gt;
&lt;p&gt;172 User Defined Services User’s Guide
User Defined Subroutines
Main Index
EXVISC
Description
The EXVISC  subroutine provides a mechanism to define a user defined elastic damper model with PVISCEX.
Example
C++:
void EXVISC
(const cspdbl_int   *n,      const cspdbl_int   *m,
const cspdbl_int   *ix,     const cspdbl_int   *ic,
const cspdbl_float *prop,   const cspdbl_float *hisv,
const cspdbl_float *forceo, const cspdbl_float *c,
const cspdbl_float *di,     const cspdbl_float *v,
const cspdbl_float *urel,   const cspdbl_float *durel,
const cspdbl_float *vrel,   const cspdbl_float *xmass,
cspdbl_float *force,
cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXVISC
+ (n,m,ix,ic,prop,hisv,forceo,c,di,v,urel,durel,ypos y coordinate of node.
zpos z coordinate of node.
xvel x nodal velocity.
yvel y nodal velocity.
zvel z nodal velocity.
xavel x nodal angular velocity.
yavel y nodal angular velocity.
zavel z nodal angular velocity.
pmass nodal mass.
ierr_code is the returned error code; 0 = success, otherwise fail.
EXVISC Subroutine User-defined elastic damper in a Nastran SOL 700 Simulation&lt;/p&gt;
&lt;p&gt;173 CHAPTER 1
EXVISC Subroutine
Main Index
+  vrel,xmass,force,ierr_code)
integer(8),intent(in)               :: n,m
integer(8),intent(in),dimension(2)  :: ix, ic
real(8)   ,intent(in)               :: forceo,urel,durel,vrel
real(8)   ,intent(in),dimension(6)  :: prop
real(8)   ,intent(in),dimension(6)  :: hisv
real(8)   ,intent(in),dimension(3,2):: c
real(8)   ,intent(in),dimension(6,2):: di,v
real(8)   ,intent(in),dimension(2)  :: xmass
real(8)   ,intent(out)              :: force
integer(8),intent(inout)            :: ierr_code
return
end subroutine
Description of arguments:
N        Element id
M        Property id
IX(2)    Connectivity: IX(1) =grid point at end 1
IC(2)    Component:
 IC(1) component at end 1 (between 1 and 6)
 IC(2) component at end 2 (between 1 and 6)
PROP(6) Properties as input on the PSPRUDS entry
HISV(6 )   
             History variables for the element. This array can be used by the user to store variables from
one time step to the next.
FORCEO   Force in the element at the previous time step
C(3,2)   Deformed coordinates in the basic coordinate system:
C(1:3,1) x, y, z, coordinates at end 1
C(1:3,2) x, y, z, coordinates at end 2
DI (6,2) Incremental displacements in the basic coordinate system
 DI(1:3,1) x, y, z, translational displacements of end 1
 DI(4:6,1) x, y, z, rotational displacements of end 1
 DI(1:3,2) x, y, z, translational displacements of end 2
 DI(4:6,2) x, y, z, rotational displacements 2
  These are incremental displacements; i.e., the displacements for this time step only.&lt;/p&gt;
&lt;p&gt;174 User Defined Services User’s Guide
User Defined Subroutines
Main Index
EXYLD
Description
The EXYLD  subroutine provides a mechanism to the user to define a yield material model with YLDUDS in a simulation.
Example
C++:
void EXYLD
(const cspdbl_int   *id,     const cspdbl_int   *lenvec,
const cspdbl_int   *iusrzn,
const cspdbl_float *pres,   const cspdbl_float *edis,
const cspdbl_float *sie,    const cspdbl_float *rho,
const cspdbl_float *fburn,        cspdbl_float *effpls,
const cspdbl_float *zmass,  const cspdbl_float *effsts,
const cspdbl_float *twoj2,  const cspdbl_float *effsr,V(6,2) Velocities in the basic coordinate system
 V(1:3,1) x, y, z, translational velocities of end 1
 V(4:6,1) x, y, z, rotational velocities of end 1
 V(1:3,2) x, y, z, translational velocities of end 2
 V(4:6,2) x, y, z, rotational velocities of end 2
A(6,2) Accelerations in the basic coordinate system
 A(1:3,1) x, y, z translational accelerations of end 1
 A(4:6,1) x, y, z rotational accelerations of end 1
 A(1:3,2) x, y, z, translational accelerations of end 2
 A(4:6,2) x, y, z, rotational accelerations of end 2
UREL Relative displacement of the element; i.e., the displacement of end 2 in the spring direction
minus the displacement of end 1
DUREL   Relative incremental displacement of the element VREL
VREL Relative velocity of the end points of the element in the direction of the element
XMASS(2) Mass of the grid points at ends 1 and 2
force      Force in the element
ierr_code   returned error code; 0 = success, otherwise fail
EXYLD Subroutine User-defined yield material model&lt;/p&gt;
&lt;p&gt;175 CHAPTER 1
EXYLD Subroutine
Main Index
cspdbl_float *usrvr1,       cspdbl_float *usrvr2,
const cspdbl_float *relv,
const cspdbl_float *sxxo,   const cspdbl_float *syyo,
const cspdbl_float *szzo,   const cspdbl_float *sxyo,
const cspdbl_float *syzo,   const cspdbl_float *sxzo,
const cspdbl_float *sxxt,   const cspdbl_float *syyt,
const cspdbl_float *szzt,   const cspdbl_float *sxyt,
const cspdbl_float *syzt,   const cspdbl_float *sxzt,
const cspdbl_float *dexx,   const cspdbl_float *deyy,
const cspdbl_float *dezz,   const cspdbl_float *dexy,
const cspdbl_float *deyz,   const cspdbl_float *dezx,
cspdbl_float *tdet,         cspdbl_float *yldsq,
cspdbl_float *damage,       cspdbl_float *softe,
cspdbl_float *volpls,
const cspdbl_int   *ibegin, const cspdbl_int   *iend,
cspdbl_int   *ierrcode)
{
return;
}
Fortran:
subroutine EXYLD
+ (id,lenvec,iusrzn,
+  pres,edis,
+  sie,rho,fburn,effpls,zmass,effsts,twoj2,
+  effsr,usrvr1,usrvr2,relv,
+  sxxo,syyo,szzo,sxyo,syzo,sxzo,
+  sxxt,syyt,szzt,sxyt,syzt,sxzt,
+  dexx,deyy,dezz,dexy,deyz,dezx,
+  tdet,yldsq,damage,softe,volpls,
+  ibegin,iend,ierr_code)
integer(8),intent(in) :: id, lenvec, ibegin,iend
integer(8), intent(in), dimension(lenvec):: iusrzn
real(8), intent(in), dimension(lenvec):: pres,edis
real(8), intent(in), dimension(lenvec):: sie,rho,fburn
real(8), intent(in), dimension(lenvec):: zmass,effsts
real(8), intent(in), dimension(lenvec):: twoj2,effsr,relv
real(8), intent(in), dimension(lenvec):: sxxo,syyo,szzo
real(8), intent(in), dimension(lenvec):: sxyo,syzo,sxzo
real(8), intent(in), dimension(lenvec):: sxxt,syyt,szzt|
real(8), intent(in), dimension(lenvec):: sxyt,syzt,sxzt
real(8), intent(in), dimension(lenvec):: dexx,deyy,dezz
real(8), intent(in), dimension(lenvec):: dexy,deyz,dezx
real(8), intent(inout), dimension(lenvec):: usrvr1,usrvr2,effpls
real(8), intent(inout), dimension(lenvec):: tdet,yldsq,damage
real(8), intent(inout), dimension(lenvec):: softe,volpls
integer(8), intent(inout) :: ierr_code
return&lt;/p&gt;
&lt;p&gt;176 User Defined Services User’s Guide
User Defined Subroutines
Main Index
end subroutine
Description of arguments:
id id on YLDUDS entry
lenvec length of arrays.
iusrzn element number.
pres old element pressure.
edis old element distortional energy.
sie old element specific internal energy.
rho element density.
fburn (euler) burn fraction of element.
effpls element effective plastic strain.
zmass mass of element.
effsts element old effective stress.
twoj2 tentative second invariant element.
effsr effective strain rate element.
usrvr1,usrvr2 user variables element.
relv relative element volume.
sxxo..sxzo old deviatoric element stresses.
sxxt..sxzt trial deviatoric element stresses.
dexx..dezx strain rate components.
tdet detonation time element.
yldsq yield stress.
damage array that allows the user to store an additional variable. Contents are transported and
clumped. This array can also be accessed within  exyld  and exfail2 .
softe same use as  damage .
volpls same use as  damage .
ibegin start of the element loop.
iend end of the element loop.
ierr_code is the returned error code; 0 = success, otherwise fail.&lt;/p&gt;
&lt;p&gt;177 CHAPTER 1
EXYLD Subroutine
Main Index
User Service Ease of Use
Introduction
In some applications there may be only one user service required. For helping user work on these applications without going
through the whole service development procedure, MSC Nastran introduced two command line keywords uds and
udssave . These keywords are used to build user service by MSC Nastran at job submittal time. The user only needs to
provide source file and give service information in the connect service statement in model file. MSC Nastran will build user
service from the source file and the given service name. This feature is also supported for UDS option in CBUSH2D,
CBUSH2DA, NLRSFD and NLRSFDA.
This section does not apply to the SOL 700 UDS application as the ease of use option is not yet available for SOL 700.
Requirement
The MSC Software Development Kit (SDK) is required. After SDK installation, its T ools directory must be added in the
PATH environment variable.
Python 3.6 o r greater version is required . The python.exe path must be added in the PATH environment variable on
Windows.
UDS requires Windows SDK version 10.0.18362.1. This requirement can be downloaded from a MicroSoft site.
Usage of Keyword uds and udssave
The uds keyword is used to specify the source file with user subroutine implementations. Suppose source file mysource.F
has user subroutines EXT_UMAT  and EXT_NOTIFY . The EXT_UMAT  and EXT_NOTIFY  are predefined user subroutine
names, they will be used to find out which interfaces have been implemented in source file. All related subroutines are
required to be put into one source file.
mysource.F:
subroutine ext_umat(&amp;hellip;)
implicit none
&amp;hellip;
end
subroutine ext_notify(&amp;hellip;)
implicit none
&amp;hellip;
end
In MSC Nastran model file test.dat, the connect service statement is used to connect a user service.
test.dat:
connect service material &amp;lsquo;UDSTest.Myapp&amp;rsquo;
&amp;hellip;
MATUDS  1       MATUSR  materialumat
GENUDS  material&lt;/p&gt;
&lt;p&gt;178 User Defined Services User’s Guide
User Defined Subroutines
Main Index
&amp;hellip;
When running MSC Nastran with keyword uds as the following, the source file mysource.F will be used to build use service.
T wo interfaces SCAMDSolverUmat and SCAIMDSolverRuntimeInfo will be implemented in the user service for
subroutine EXT_UMAT  and EXT_NOTIFY . The user service name UDSTest.Myapp  is from the connect service statement
in test.dat .
The supported interfaces and predefined user subroutine names in FORTRAN and C++ are list below. Refer to interface
and user subroutine section for details.Example: nastran test.dat uds=mysource.F
Interface MethodFORTRAN Subroutine
Name CPP Function Name
SCAIMDSolverCrplaw usrCrplaw_32 EXT_CRPLAW uds_crplaw_32
SCAIMDSolverCrplaw usrCrplaw_64 EXT_CRPLAW uds_crplaw_64
SCAIMDSolverHypela2 usrHypela2_32 EXT_HYPELA2 uds_hypela2_32
SCAIMDSolverHypela2 usrHypela2_64 EXT_HYPELA2 uds_hypela2_64
SCAIMDSolverOrient usrOrient_32 EXT_ORIENT uds_orient_32
SCAIMDSolverOrient usrOrient_64 EXT_ORIENT uds_orient_64
SCAIMDSolverUcohesive usrUcohesive_32 EXT_UCOHESIVE uds_ucohesive_32
SCAIMDSolverUcohesive usrUcohesive_64 EXT_UCOHESIVE uds_ucohesive_64
SCAIMDSolverUcohesive usrUcohes_32 EXT_UCOHES uds_ucohes_32
SCAIMDSolverUcohesive usrUcohes_64 EXT_UCOHES uds_ucohes_64
SCAIMDSolverUelastomer usrUelastomer_32 EXT_UELASTOMER uds_uelastomer_32
SCAIMDSolverUelastomer usrUelastomer_64 EXT_ UELASTOMER uds_uelastomer_64
SCAIMDSolverUfail usrUfail_32 EXT_UFAIL uds_ufail_32
SCAIMDSolverUfail usrUfail_64 EXT_UFAIL uds_ufail_64
SCAMDSolverUmat usrUmat_32 EXT_UMAT uds_umat_32
SCAMDSolverUmat usrUmat_64 EXT_UMAT uds_umat_64
SCAMDSolverUprogfail usrUprogfail_32 EXT_UPROGFAIL uds_uprogfail_32
SCAMDSolverUprogfail usrUprogfail_64 EXT_UPROGFAIL uds_uprogfail_64
SCAMDSolverMotion usrMotion_32 EXT_MOTION uds_motion_32
SCAMDSolverMotion usrMotion_64 EXT_MOTION uds_motion_64
SCAMDSolverSepfor usrSepfor_32 EXT_SEPFOR uds_sepfor_32&lt;/p&gt;
&lt;p&gt;179 CHAPTER 1
EXYLD Subroutine
Main Index
In addition to write subroutines in a source file, user subroutines can be put in MSC Nastran input file. There is the BEGIN
BULK UDS section in input file for user subroutine implementations. The content of this section will be used to create
the source file when building user service.
BEGIN BULK
…
BEGIN BULK UDS=material
subroutine ext_umat(&amp;hellip;)
implicit none
&amp;hellip;
end
subroutine ext_notify(&amp;hellip;)
implicit none
&amp;hellip;SCAMDSolverSepfor usrSepfor_64 EXT_SEPFOR uds_sepfor_64
SCAMDSolverSepstr usrSepstr_32 EXT_SEPSTR uds_sepstr_32
SCAMDSolverSepstr usrSepstr_64 EXT_SEPSTR uds_sepstr_64
SCAMDSolverUbsqueal usrUbsqueal_32 EXT_UBSQUEAL uds_ubsqueal_32
SCAMDSolverUbsqueal usrUbsqueal_64 EXT_UBSQUEAL uds_ubsqueal_64
SCAMDSolverUfric usrUfric_32 EXT_UFRIC uds_ufric_32
SCAMDSolverUfric usrUfric_64 EXT_UFRIC uds_ufric_64
SCAMDSolverNlrsfd runNlrsfd EXT_NLRSFD uds_nlrsfd_32
SCAMDSolverNlrsfd runNlrsfd_64 EXT_NLRSFD uds_nlrsfd_64
SCAMDSolverNlrsfda runNlrsfda_32 EXT_NLRSFDA uds_nlrsfda_32
SCAMDSolverNlrsfda runNlrsfda_64 EXT_NLRSFDA uds_nlrsfda_64
SCAMDSolverUselem usrUselem_32 EXT_USELEM uds_uselem_32
SCAMDSolverUselem usrUselem_64 EXT_USELEM uds_uselem_64
SCAIMDSolverRuntimeInfo notify_32 EXT_NOTIFY uds_notify32
SCAIMDSolverRuntimeInfo notify_64 EXT_NOTIFY uds_notify64
SCAIMDSolverCBUSH2D cbush2d_32 EXT_CBUSH2D uds_cbush2d_32
SCAIMDSolverCBUSH2D cbush2d_64 EXT_CBUSH2D uds_cbush2d _64
SCAIMDSolverCBUSH2D cbush2da_32 EXT_CBUSH2DA uds_cbush2da_32
SCAIMDSolverCBUSH2DA cbush2da_64 EXT_CBUSH2DA uds_cbush2da_64Interface MethodFORTRAN Subroutine
Name CPP Function Name&lt;/p&gt;
&lt;p&gt;180 User Defined Services User’s Guide
User Defined Subroutines
Main Index
End
ENDDATA
T o build use service from subroutines in BEGIN BULK UDS  section in an input file, the uds keyword should be set to
model in MSC Nastran run.
The udssave  keyword is used to specify the user service build location.
If udssave  is specified, the built user service will be saved to the location. If udssave  is not specified, the MSC Nastran
output directory will be used to build user service and the service will be removed after MSC Nastran run.
After building a user service with the udssave  keyword, any model using the service can run without building it again.
T o use the service, it is required to set the SCA_LIBRARY_PATH and SCA_SERVICE_CATALOG  environment variables to
the correct path and file. To facilitate the variable setting procedure, a file named udspath  (udspath.bat  on Windows)
will be created. In this file, the two environment variables are set accordingly to the specified build location. You can run
this file to set the environment variables and then run models.
NOTE: The udspath  is an example of setting service environment variables. The file is created in a Korn shell, users
running other shells should set environment variables accordingly.
Example: Use udspath  to set environment variables and run model with build service
source udspath
export SCA_LIBRARY_PATH
export SCA_SERVICE_CATALOG
nastran test.dat
User Routines Ease of Use
Introduction
Starting in 2023.4 User Routines may be used via the UDR command line option. Switching from UDS= to UDR=
instructions are below:
1.Updates for use
1.1Remove the CONNECT line in your input file.
1.2Use UDR/UDRPATH* instead of UDS/UDSSAVE on the command line.Example: nastran test.dat uds=model
Example: nastran test.dat uds=mysource.F udssave=/scratch/mydir&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
