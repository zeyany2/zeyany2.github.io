<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DOC REPO – MSC Nastran manuals</title>
    <link>//uildDrafts:1313/docs/release_guide/</link>
    <description>Recent content in MSC Nastran manuals on DOC REPO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="//uildDrafts:1313/docs/release_guide/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>User&#39;s Manual P1</title>
      <link>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_001/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_001/</guid>
      <description>
        
        
        &lt;p&gt;MSC Nastran 2024.1
Release GuideMSC Nastran Release Guide&lt;/p&gt;
&lt;p&gt;Worldwide Web
&lt;a href=&#34;https://www.hexagon.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.hexagon.com&lt;/a&gt;
Support
&lt;a href=&#34;https://simcompanion.hexagon.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://simcompanion.hexagon.com&lt;/a&gt;
Disclaimer
Hexagon reserves the right to make changes in specifications and other information contained in this document without prior notice.
The concepts, methods, and examples presented in this text are for illustrative and educational purposes only, and are not intended
to be exhaustive or to apply to any particular engineering problem or design. Hexagon assumes no liability or responsibility to any
person or company for direct or indirect damages resulting from the use of any information contained herein.
User Documentation: Copyright 2024 Hexagon AB and/or its subsidiaries. All Rights Reserved.
This notice shall be marked on any reproduction of this documentation, in whole or in part. Any reproduction or distribution of this
document, in whole or in part, without the prior written consent of Hexagon is prohibited.
This software may contain certain third-party software that is protected by copyright and licensed from Hexagon suppliers. Additional
terms and conditions and/or notices may apply for certain third party software. Such additional third party software terms and
conditions and/or notices may be set forth in documentation and/or at third-party software information  (or successor website designated
by Hexagon from time to time).
PCGLSS 8.0, Copyright © 1992-2016, Computational Applications and System Integration Inc. All rights reserved. PCGLSS 8.0 is
licensed from Computational Applications and System Integration Inc.
The Hexagon logo, Hexagon, MSC Software logo, MSC, Dytran, Marc, MSC Nastran, Patran, e -Xstream, Digimat, and Simulating
Reality are trademarks or registered trademarks of Hexagon AB and/or its subsidiaries in the United States and/or other countries.
NASTRAN is a registered trademark of NASA. FLEXlm and FlexNet Publisher are trademarks or registered trademarks of Flexera
Software. All other trademarks are the property of their respective owners.
Use, duplicate, or disclosure by the U.S. Government is subjected to restrictions as set forth in FAR 12.212 (Commercial Computer
Software) and DFARS 227.7202 (Commercial Computer Software and Commercial Computer Software Documentation), as
applicable.
U.S. Patent 9,361,413
May 17, 2024
NA:V2024.1:Z:Z:Z:DC-REL-PDFCorporate Office
Hexagon Manufacturing Intelligence, Inc. UK
78 Portsmouth Road Cedar House
Cobham, Surrey KT11 1HY
Telephone: (+44) 02070686555&lt;/p&gt;
&lt;p&gt;Documentation Feedback
At Hexagon Manufacturing Intelligence, we strive to produce the highest quality documentation and
welcome your feedback. If you have comments or suggestions about our documentation, write to us .
Please include the following information with your feedback:
Document name
Release/Version number
Chapter/Section name
Topic title (for Online Help)
Brief description of the content (for example, incomplete/incorrect information, grammatical
errors, information that requires clarification or more details and so on).
Your suggestions for correcting/improving documentation
Note:   The above mentioned e-mail address is only for providing documentation specific
feedback. If you have any technical problems, issues, or queries, please contact Technical
Support .&lt;/p&gt;
&lt;p&gt;C o n t e n t s
MSC Nastran 2024.1 Release Guide
Contents
Main Index
Contents
Preface
List of MSC Nastran Guides . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8
Corrected and Fixed Error List  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9
Training and Internet Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9
MSC Nastran Documentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10
MSC Nastran Documentation Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10
Utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10
1 Overview of MSC Nastran 2024.1
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12
Advanced Implicit Nonlinear (SOL 400) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12
Dynamic Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12
Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12
Rotordynamics Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12
Design Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12
Numerical Methods and High Performance Computing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12
General Analysis Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13
Platform Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13
Appendix  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13
Feature Deprecation List  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13
Features Removed from MSC Nastran  in 2022 .2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13
Features to be Removed from MSC Nastran in 2023. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14
2 Advanced Implicit Nonlinear (SOL 400)
NLPERF - High-Performance Nonlinear Solver  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18
Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18
Details of Key Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  20
Demonstrations: Example Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  24&lt;/p&gt;
&lt;p&gt;MSC Nastran 2024.1 Release Guide2
Main Index
Benefits with New or Improved Features in the New SOL400 solver . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  34
Unsupported MSC Nastran Input Entities  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  34
Comparing the classic SOL 400 with the new SOL 400 solver  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  37
Understanding any result discrepancies: New Nonlinear Performance Solver (NLPERF)
versus.Classic SOL 400 Solver (CNLS)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  37
Known Issues in this release  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  40
3 Dynamic Analysis
Single-step TPA  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  42
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  42
Benefits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  43
Model Set-up and TPA Workflow  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  43
User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  46
Guidelines and Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  47
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  48
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  53
Nastran PEM Solution Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  55
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  55
Benefits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  55
User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  55
Inputs / Outputs Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  59
Guidelines, Perspectives and Limitations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  59
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  60
ADAMS MNF Enhancement: Acoustic Pressure R ecovery in Adams . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  63
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  63
Benefits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  63
User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  63
Guidelines  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  64
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  65
Peakout Support for ERP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  66
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  66
Benefits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  66
Feature Description  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  66
User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  66
Examples:  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  67
Guidelines and Limitation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  67
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  67
MSC Nastran Cohesive Elements in Linear Analysis  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  72
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  72
Benefits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  72
User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  72&lt;/p&gt;
&lt;p&gt;3 Contents
Main Index
Example (\tpl\lincohe\s101_cifhex_ef.dat ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  72
Limitations: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  73
4 Modules
Case Control Output Requests for Modules - MDSET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  76
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  76
Benefits  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  76
User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  78
Output  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  79
Limitations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  79
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs . . . . . . . . . . . . . . . . . . . . . . .  80
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  80
User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  80
Guidelines and Limitations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  87
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  87
5 Rotordynamics Enhancements
SOL 128 Postprocessing Improvements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  94
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  94
Benefits  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  94
Feature Description  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  94
User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  94
Example:  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95
Guidelines and Limitation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  97
ADAMS MNF Enhancement: Rotordynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  101
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  101
Benefits  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  101
User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  101
Guidelines  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  102
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  103
6 Design Optimization
Symmetry Constraints on Topometry optimization  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  107
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  107
Benefits  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  107
User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  107
Test Cases  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  108
Guidelines and Limitations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  112&lt;/p&gt;
&lt;p&gt;MSC Nastran 2024.1 Release Guide4
Main Index
Optimization Enhancements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  113
7 Numerical Methods and High Performance Computing
Real Coupled Modes - Support External SE and Residual Vectors Computation for METHOD(SYMCOUP)  115
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  115
Advantages of the New Features  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  115
User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  115
Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  115
Test Case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  115
Linear Statics Performance Improvement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  120
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  120
Benefits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  120
Technical Discussion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  120
User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  121
Guidelines and Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  121
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  121
Automatic Multilevel Static Reduction (AMSR) for External Superelements and External Modules  . . . .  123
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  123
Benefits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  123
Technical Discussion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  123
User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  124
Guidelines and Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  124
Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  124
Mumps Out-of-core Support and Mumps DMP in Lanczos  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  127
Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  127
Benefits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  127
Technical Discussion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  127
User Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  127
Guidelines and Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  128
8 General Analysis Enhancements
LOG File Summary Output Enhancement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  130
9 Platform Support
Supported Hardware and Operating Systems  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  134
Software Development Kit (SDK)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  134&lt;/p&gt;
&lt;p&gt;5 Contents
Main Index
A Python Code for Post Processing TPA HDF5 File
Python Code for Post Processing TPA HDF5 File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  136
Approach 1: Postprocessing (by GUI) for Targeted TPA Results  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  136
Approach 2: Postprocessing (by PDF)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  148&lt;/p&gt;
&lt;p&gt;MSC Nastran 2024.1 Release Guide6
Main Index&lt;/p&gt;
&lt;p&gt;Main Index
Preface
Preface
List of MSC Nastran Guides     8
Training and Internet Resources     9
MSC Nastran Documentation     10&lt;/p&gt;
&lt;p&gt;MSC Nastran 2024.1 Release Guide
List of MSC Nastran Guides8
Main Index
List of MSC Nastran Guides
A list of some of the MSC Nastran guides is as follows:
Installation and Release Guides
Installation and Operations Guide
Release Guide
Reference Guides
Quick Reference Guide
DMAP Programmer’s Guide
Reference Guide
Utilities Guide
Getting Started Guide
SOL 400 Getting Started Guide
MSC Nastran Error Messages Guide
Demonstration Guides
Linear Analysis
Implicit Nonlinear (SOL 400)
Explicit Nonlinear (SOL 700)
MSC Nastran Verification Guide
User’s Guides
Automated Component Modal Synthesis (ACMS)
Access Manual
Aeroelastic Analysis
Design Sensitivity and Optimization
DEMATD
Dynamic Analysis
Embedded Fatigue
Embedded Vibration Fatigue
Explicit Nonlinear (SOL 700)
High Performance Computing
Linear Static Analysis
Nonlinear (SOL 400)
Numerical Methods
Rotordynamics&lt;/p&gt;
&lt;p&gt;9  MSC Nastran 2024.1 Release Guide
Preface
Main Index
You may find any of these documents from Hexagon at:
&lt;a href=&#34;https://simcompanion.hexagon.com/customers/s/article/MSC-Nastran-Support-Home-Page&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://simcompanion.hexagon.com/customers/s/article/MSC-Nastran-Support-Home-Page&lt;/a&gt;
Technical Support
For technical support phone numbers and contact information, please visit:
&lt;a href=&#34;https://simcompanion.hexagon.com/customers/s/article/support-contact-information-kb8019304&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://simcompanion.hexagon.com/customers/s/article/support-contact-information-kb8019304&lt;/a&gt;
Support Center ( &lt;a href=&#34;https://simcompanion.hexagon.com/customers/s/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://simcompanion.hexagon.com/customers/s/&lt;/a&gt; )
The SimCompanion link above gives you access to the wealth of resources for Hexagon  products. Here you
will find product and support contact information, product documentations, knowledge base articles,
product error list, knowledge base articles and SimAcademy Webinars. It is a searchable database which
allows you to find articles relevant to your inquiry. Valid MSC customer entitlement and login is required to
access the database and documents. It is a single sign-on that gives you access to product documentation for
complete list of products from Hexagon , allows you to manage your support cases, and participate in our
discussion forums.
Corrected and Fixed Error List
For a list of corrected defects in the MSC Nastran 2024.1  release, please visit our Sim Companion site and
see: &lt;a href=&#34;https://simcompanion.hexagon.com/customers/s/article/MSC-Nastran-Issue-Lists-Known-and-Fixed-ki8008006&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://simcompanion.hexagon.com/customers/s/article/MSC-Nastran-Issue-Lists-Known-and-Fixed-ki8008006&lt;/a&gt;
Training and Internet Resources
The Hexagon  corporate site  has the information on the latest events, products, and services for the
CAD/CAE/CAM marketplace.
Design and Engineering e-Learning
The above link will point you to schedule and description of seminars. Following courses are recommended
for beginning MSC Nastran users.
NAS120 - Linear Static Analysis using MSC Nastran and Patran
This seminar introduces basic finite element analysis techniques for linear static, normal modes, and
buckling analysis of structures using MSC Nastran and Patran. MSC Nastran data structure, the element
library, modeling practices, model validation, and guidelines for efficient solutions are discussed and
illustrated with examples and workshops. Patran will be an integral part of the examples and workshops and
will be used to generate and verify illustrative MSC Nastran models, manage analysis submission requests,
and visualize results. This seminar provides the foundation required for intermediate and advanced MSC
Nastran applications.Superelements and Modules
Thermal Analysis
User Defined Services&lt;/p&gt;
&lt;p&gt;MSC Nastran 2024.1 Release Guide
MSC Nastran Documentation10
Main Index
MSC Nastran Documentation
For quick access to the full set of MSC Nastran Documentation on Windows, do the following:
1.Go to your MSCNastran_Installation_DIR\ 2024.1\doc\pdf_nastran\  directory.
2.Right-click nastran_library.pdf  to create a shortcut to the Windows Desktop.
3.Click Send to &amp;ndash;&amp;gt; Desktop&lt;br&gt;
This creates a shortcut to your Windows Desktop.
MSC Nastran Documentation Requirements
The following browsers are recommended to view and navigate through the PDF based MSC Nastran
documentation:
Utilities
The MSC utilities including MultiOpt described in this release guide have been moved from the MSC
Nastran Installation and Operators Guide  to their own manual labeled MSC Nastran Utilities Guide .VendorDesktop
Environment Browser Browser Version
Linux (64-bit) KDE Konqueror 4.3.4 or higher
Linux (64-bit) Gnome Evince 2.28.2 or higher
Microsoft (64-bit) Windows 10 Adobe Reader 10.1.4 or higher
Note:   Adobe has dropped support for Reader on Linux. The browsers in the above table have been
tested and work with the current version of the MSC Nastran Documentation.&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 1: Overview of MSC Nastran 2024.1&lt;br&gt;
1Overview of MSC Nastran
2024.1
Introduction     12
Feature Deprecation List     13&lt;/p&gt;
&lt;p&gt;MSC Nastran 2024.1 Release Guide
Introduction12
Main Index
Introduction
Hexagon is pleased to introduce you to the exciting new technologies in this release of MSC Nastran —the
premier and trusted CAE solution for aerospace, automotive, defense, and manufacturing industries
worldwide. This Release Guide contains descriptions for the MSC Nastran 2024.1 version.
This release includes new features and enhancements in following topics :
Advanced Implicit Nonlinear (SOL 400)
NLPERF - High-Performance Nonlinear Solver
Dynamic Analysis
Single-step TPA
Nastran PEM Solution Enhancements
ADAMS MNF Enhancement: Acoustic Pressure Recovery in Adams
Peakout Support for ERP
MSC Nastran Cohesive Elements in Linear Analysis
Modules
Case Control Output Requests for Modules - MDSET
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs
Rotordynamics Enhancements
SOL 128 Postprocessing Improvements
ADAMS MNF Enhancement: Rotordynamics
Design Optimization
Symmetry Constraints on Topometry optimization
Optimization Enhancements
Numerical Methods and High Performance Computing
Real Coupled Modes - Support External SE and Residual Vectors Computation for METHOD(SYMCOUP)
Linear Statics Performance Improvement
Automatic Multilevel Static Reduction (AMSR) for External Superelements and External Modules
Mumps Out-of-core Support and Mumps DMP in Lanczos&lt;/p&gt;
&lt;p&gt;13 MSC Nastran 2024.1 Release Guide
Overview of MSC Nastran 2024.1
Main Index
General Analysis Enhancements
LOG File Summary Output Enhancement
Platform Support
Supported Hardware and Operating Systems
Appendix
Python Code for Post Processing TPA HDF5 File
Feature Deprecation List
Features Removed from MSC Nastran in 2022 .2
In an effort to streamline the MSC Nastran program and simplify ongoing maintenance activity, the
following obsolete capabilities have been removed.
Features Removed in 202 2.2
SOL 600 nonlinear solution sequence
Obsolete DMAP modules:
A502FBS ALU2GINO COMIFP COMPRESS COMPRT DBEXEC
DMPR DOMEVL DOMOPT DRMS2 DSADXP DSAMRG
DSVG3 DSVG4 DUMMODi FMSCMD GEOMSRVR IFPBSH2
INPUTT3 INREL JINTG JPOST L16MD1 L16MD2
LAMTPRT LCONFIN LCONTCT MACOFP MAKESPR MODA
MODB MODC MODEMG MODTA MPRO MSC2SAM
MSGSTRES NASSETS NDDLCPRT NEWUSET NLITERA ORTHOG
OUTPUT OUTPUT3 PARASOL PLTTRAN PLTVEC PLVCDR
RBMG2 REIGL RGYASY SAM2MSC SCE1 SFMIG68
SMP1 SMP2 TABPCH TABPTP TASN TOLAPH
UEIGL UREDUC VARIAN&lt;/p&gt;
&lt;p&gt;MSC Nastran 2024.1 Release Guide
Feature Deprecation List14
Main Index
Features to be Removed from MSC Nastran in 2023
In an effort to streamline the MSC Nastran program and simplify ongoing maintenance activity, some
obsolete capabilities have been identified and tagged for removal in a future release of the program in 2023,
allowing for a reasonable notice period.
Features Tagged for Removal in 2023
Grid point re-sequencing (PARAM,OLDSEQ and SEQP module)
SOL 190 (DBTRANS)
TAUCS solve r
SSSALTERS :Note:   Please review the list of features marked for deprecation below to ensure that there will be no
disruption to your use of MSC Nastran. If you see a feature that you currently use and do not
wish to lose, contact Technical Support  to report it.
SSSAlter Description
111_by_mode Output (displacements, stresses, PSD, etc.) by mode in SOL 111 so the
contribution of each mode to the complete solution can be evaluated.
append Append eigensolutions.
buckle2_400 Nonlinear buckling in SOL 400 (implementation planned).
cditer200 Constrained displacement iterations (CDITER) in SOL 200.
Cmsef Identify participation of component modes in the system modes by
computing strain energy fractions (implemented with CMSENRGY).
Cov In SOL 200, compute variances in response due to variances in design
variables.
Cygyro In SOL 114, add centripetal, coriolis, and differential stiffness.
dmigtrn T ransform the DMIG matrix selected by the K2GG Case Control
command from the coordinate system listed on PARAM XCID to the basic
coordinate system. The transformed DMIG matrix is then output to the
punch file.
effmass_sm Calculate model effective mass for models using the large mass technique.
emoutput Partial constraint forces.
ese_eke Element strain and kinetic energy.
Fsum Sum steady and oscillating solutions in frequency response.&lt;/p&gt;
&lt;p&gt;15 MSC Nastran 2024.1 Release Guide
Overview of MSC Nastran 2024.1
Main Index
gc_oload Write the GROUNDCHECK forces to the op2 or xdb file in the form of
OLOAD vectors allowing groundcheck forces to be examined using fringe
plots in a post processor.
Genel In SOL 112, calculate the forces resulting from a GENEL element in
OLOAD format (implemented with GPFORCE).
Glforce Calculate superelement interface loads.
Gpftrn GPForces in transient solutions (implemented with GPFORCE).
Gridlock Calculate grid point locations in the basic coordinate system.
Irs Improved (dynamic) reduction system.
k6ese Strain energy due to K6ROT .
mfreqe Calculate the contribution of each mode to the strain
Energy (implemented with MODALSE).
modeval In SOL 103, determine if the modes obtained are capable of representing
the solution to a set of applied loadings without having to perform a
dynamic analysis.
mtrane Calculate the strain energy and kinetic energy in a transient solution by
mode (implemented with MODALKE and MODALSE).
Nlgyro In SOL 106 add centripetal terms to the tangent stiffness matrix during
modes calculation specified by the parameter NMLOOP .
Nlirm Inertia relief in SOL 106.
Norm Normalize g-set eigenvector to maximum displacement=1.0.
nosesubc Replace all superelement subcases with residual subcases to facilitate post-
processors.
oloadcd T ransform the oload resultant into a user-defined coordinate system.
ortx10 In SOL 110, scale complex eigenvectors for generalized mass as an identity
matrix.
ortx7 In SOL 107, scale complex eigenvectors for generalized mass as an identity
matrix.
Prop Compute the propeller aerodynamic coefficients and wing/nacelle
aerodynamic interference loads for aircraft flutter analysis.
rnormal Provide repeatable modes for the Lanczos method.
Segyro Incorporate coriolis, centripetal, and differential stiffness terms into the
superelement stiffness and damping matrices.SSSAlter Description&lt;/p&gt;
&lt;p&gt;MSC Nastran 2024.1 Release Guide
Feature Deprecation List16
Main Index
spc101 In SOL 101 only, print separate SPCFORCE output for modelled-in SPC
(those on GRID/PS and SPC+sets) and AUTOSPC reactions.
tempmat In SOL 106, apply temperature-dependent material to higher-order solid
linear elements in a nonlinear solution.
trncomp In transient analysis, calculate the composite ply-by-ply stresses (or strains)
and failure indices (implemented).SSSAlter Description&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P2</title>
      <link>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_002/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_002/</guid>
      <description>
        
        
        &lt;p&gt;Main Index
Chapter 2: Advanced Implicit Nonlinear (SOL 400)
MSC Nastran Release Guide
2Advanced Implicit Nonlinear
(SOL 400)
NLPERF - High-Performance Nonlinear Solver     18&lt;/p&gt;
&lt;p&gt;18 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
NLPERF - High-Performance Nonlinear Solver
Introduction
The NLPERF solver (High-Performance Nonlinear Solver), introduced in the current MSC Nastran 2024.1 release, is a
high-performance non linear solver based on a revamped SOL400 architecture. While the primary focus of this initial release
is performance, the NLPERF solver will be continually developed and further updates to functionality, robustness and
performance will be provided in future releases.
Background Information
The conventional SOL 400 solver in MSC Nastran includes a wide range of capabilities and features, including linear and
nonlinear analysis, static and transient analysis, modes/frequency analysis, structural and thermal loads, contact analysis,
various nonlinear material models, and support for linear, conventional nonlinear, and advanced nonlinear elements.
Additionally, it accommodates super-element integration with various nonlinear elements.
However, MSC Nastran&amp;rsquo;s existing architecture for SOL 400 has challenges for large industrial applications, particularly with
regard to combinations of linear elements, conventional nonlinear elements, and advanced nonlinear elements, leading to
significant I/O requirements and limited shared memory parallel (SMP) performance. SOL 400&amp;rsquo;s SMP support scales only
up to about 4 threads for advanced nonlinear elements and 8 - 12 threads for the Pardiso solver limiting the overall scaling
to 4 - 8 threads and thereby restricting its potential for larger applications. Furthermore, SOL 400 does not support the
MUMPS solver for non-linear analysis which offers both shared-memory and distributed-memory capabilities.
In light of these limitations, the new non-linear solver aims to revamp the current SOL 400 architecture to improve the
processing efficiency for different element types, minimize I/O overhead, and address bottlenecks in SMP threading. By
doing so, all users of MSC Nastran for nonlinear analysis will benefit from the aforementioned improvements.
Terminology
CNLS: Classic Nonlinear Solver SOL 400, i.e., current SOL 400
NLPERF:  High-Performance Nonlinear Solver SOL 400
Scope
The first release of NLPERF is limited to linear and nonlinear static analysis. The following points should be noted:
Supported Options:
•Geometric, material and contact nonlinearities
•Fixed and adaptive time stepping (including arc length methods)
•Linear and nonlinear elements (conventional and advanced)
•Superelements and Modules
•Multiple load steps in single subcas e&lt;/p&gt;
&lt;p&gt;19  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
Unsupported Options:
•Transient Analysis
•Linear Perturbation
•Thermo-Mechanical Coupled Analysis
•Multiple Subcases
Activation of NLPERF
To invoke the new nonlinear solver, a new keyword is added in NLMOPTS which allows the user to select between the
Classic and the High-Performance SOL 400. The keyword information is found in the following table:
•If the above keyword is not present or CNLS is specified, the job will continue to run with the classic SOL 400
solver (CNLS).
•For NLSSEL set to NLPERF, SOL 400 will attempt to use the NLPERF solver. If it is not possible (due to
unsupported features), then the job will stop with a USER FATAL MESSAGE .
•For NLSSEL set to AUTO, SOL 400 will automatically determine if the model can run with NLPERF or
CNLS based on all the entries in the MSC Nastran input. If NLPERF can be used, then the model will be run
using the new solver. If NLPERF cannot be used, then the model will automatically revert to using the CNLS
solver. In this case, a USER INFORMATION MESSAGE  will be issued .
Improvements in NLPERF
1.Element Processing Improvements
a.Reducing I/O greatly for advanced nonlinear elements
b.Supporting default In-Core memory processing for advanced nonlinear elements.&lt;br&gt;
2.Solver Improvements
a.Supporting MUMPS solver, including SMP and DMP support and Out-of-Core support. Note that the DMP
option can be used for both single node and multi-node setups.
b.Incorporating state-of-the-art matrix reordering improvements that limit the number of matrix reorderings and
thereby reduce serial bottlenecks for solver performance.
3.Improving HPC performance with SMP up to 32 threads
4.Providing a new output file ( jobname.itr ) with more detailed iteration convergence informationTable 2-1  Keyword support for NLPERF SOL 400
Bulk Data Entry Keyword Solver Options
NLMOPTS NLSSELCNLS (Default: Classic SOL 400)
NLPERF (High-Performance SOL 400)
AUTO&lt;/p&gt;
&lt;p&gt;20 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
5.New GUI monitor to visualize the convergence behavior across iterations
6.Supporting contact capability with the Arc-Length Metho d
Details of Key Features
In this section, we will discuss the enhancements incorporated into the release of the new nonlinear solver. These
improvements aim to enhance the solver&amp;rsquo;s capabilities and performance.
Enhancements in Architecture
State -of-the- ar t Flow Structure
In the classic structure of SOL 400, the element stiffness matrix for all nonlinear elements is calculated within an element
loop, as shown in Figure 2-1. This is implemented in a fine-grained loop by branching between conventional and advanced
elements to generate the element stiffness in conventional MSC Nastran format and assembling it into the global stiffness
matrix. This process requires significant I/O and limits the performance for multiple threads.
This element level loop logic for assembly is also used for stress recovery for conventional and advanced nonlinear elements.
Figure 2-1  Current Architecture of SOL 400 for Stiffness (data recovery is similar)
Within the revamped architecture, elements are categorized in PHASE I into three groups, based on their material/property
and formulation:
•Conventional linear elements
•Conventional nonlinear elements
•Advanced nonlinear elements&lt;/p&gt;
&lt;p&gt;21  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
Conventional and advanced nonlinear elements are processed independently by using their respective data flows. This
reduces I/O and leverages improved SMP performance. Figure 2-2 shows the new architecture.
DMAP Structure Improvement
The nonlinear process in SOL400 is based on Newton-Raphson Increment - Iteration techniques. In conventional
SOL400, the iteration loop is implemented at the DMAP level (NONLIN.DMAP). The generation and assembly of the
matrix (EMG/EMA modules), as well as stress recovery/convergence checking (NLSOLV module), are accessed via DMAP
for each iteration and this requires extra datablock reading and writing.
In High-Performance SOL 400 , the following enhancements are implemented:
a.Stiffness update-related capabilities (generation and assembly) are integrated into one module.
b.For High-Performance SOL 400, both stiffness computations and stress recovery are moved into a single
iteration looping structure without having to move in and out of DMAP  returning a nonlinear increament .
Figure 2-2  The Revamped Architecture of SOL 400 for Stiffness and Data Recover y
New SUBDMAP: nascont.dmap
This new subdmap  is used to control the revamped flow structure. It includes three modules:
•NMINIT.F: initialization for each load step
•NMINCIT.F: control and implement increment and iteration
•NMOUTPT.F: preparing the result datablocks output for an output increment for both conventional nonlinear
elements and advanced nonlinear elements&lt;/p&gt;
&lt;p&gt;22 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
MUMPS Solver
MSC Nastran NLPERF supports both the MUMPS as well as P ARDISO solver. MUMPS is the default solver.
The MUMPS solver supports multi-threading as well as distributed parallel mode. The PARDISO solver supports only
multi-threading parallel mode.
By default, MUMPS uses Metis for bandwidth optimization during the initial solve. For later solves, the reordering
algorithm checks to see if the footprint of the operating matrix has changed. If the matrix footprint has changed significantly
due to new contact/separation, etc, then a new reordering will be triggered. Otherwise , the previous optimized bandwidth
order is reused, and the reordering will be skipped.
Out-of-Core Process with MUMPS Solver
MUMPS solver supports out of core (OOC) factorization/solution when sufficient memory is not available. This is
controlled through the MDLPRM, PRDOOC, n  option.
Shared Memory Parallel (SMP) and Distributed Memory Parallel (DMP)
Enhanced SMP and DMP options can be leveraged in this version. Various examples demonstrating scalability for different
element types are demonstrated in Section 7.
Note the following:
a.Element Processing: SMP capabilities are only available for advanced nonlinear elements. The number of
threads to be used are determined by the SMP=n   and DMP=m  command line options as detailed in Table 2-3.
b.Matrix Solver: SMP and DMP capabilities are available for the Mumps solver. Only SMP capabilities are
available for the Pardiso solver. The number of threads to be used for the matrix solver are specified through the
following options in the command line:
SMP=n and DMP=mTable 2-2  Keywords for OOC in MUMPS
Keyword Description
MDLPRM,PRDOOC,1 MUMPS will use all possible machine memory if needed, and attempt to stay
in-core. If the memory is still not sufficient, it will go out-of-core. (Default)
MDLPRM,PRDOOC,2 MUMPS will use an internally estimated minimum core memory for its
operation. It will then go out-of-core. Note that this is a memory friendly option
but can be at the expense of improved performance and scalability.&lt;/p&gt;
&lt;p&gt;23  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
The number of threads used for elements and for the Mumps solver for different machine configurations are defined in the
table below :
Iteration File
A new .itr  file is generated for NLPERF SOL 400 allowing the user to access information generated during the Newton-
Raphson process. This .itr  file provides the increment number, iteration count, singularity ratio, maximum residual force,
maximum reaction force, maximum iterative and incremental displacements, and convergence ratio in a single compact
location.
Convergence Monitor with GUI for Analysis Behavior
A new Graphic User Interface (GUI) is available for the user to monitor the progress of the nonlinear run based on the
iteration file. It can be used to show the history of the convergence behavior to help the user to understand the status of the
nonlinear analysis. It also allows users to turn on or off the GUI monitor to quickly check the analysis status or inspect
convergence history from existing iteration files .
Memory Management
In order to reduce I/O for the NLPERF solver, a dual memory management scheme has been implemented. In addition to
conventional Open Core memory in MSC Nastran which is to be used only within a MSC Nastran module, a new memory
area called Persistent Memory is introduced. Like Open Core memory, Persistent Memory is used for the consumption and
computation of analysis data within MSC Nastran modules. However, unlike Open Core, Persistent Memory contains data
that can persist across functional module calls. This reduces the need to read and write MSC Nastran data blocks, thereby
reducing I/O.
For the new SOL 400, 80% of the memory specified by the user is reserved for Persistent Memory by default. The
remaining 20% is used for MSC Nastran Open Core and Executive memory areas: approximately 10% for Open Core and
10% for Buffer Pool. If 70% is specified, then approximately 20% will be reserved for Open Core and 10% for Buffer Pool.
Generally, buffer pool is reserved to 10% of memory specified. T o change the percentage of memory reserved for Persistent
Memory, use the “pmem”  command line option. The format is pmem=val  where val is a positive integer indicating the
desired percentage. The default value for PMEM is pmem=80+ where the + sign implies that more memory will be allocated
from the system if the pmem limit is reached.
For optimal Persistent Memory allocation, it is recommended to utilize &amp;ldquo;mem=max&amp;rdquo; and specify the memory allocation for
MSC Nastran using the “memorymax”  keyword. This approach ensures proper and efficient utilization of memory
resources for MSC Nastran operations.Table 2-3  Usage of SMP and DMP
SMP DMP Single Host Multi-Host
n m Number of Threads for Elements = n m Number of Threads for Elements on parent node =
nm (could cause over-subscription)
Number of Threads for Solver per each (m)
solver process = nNumber of Threads for Solver on each (m) node = n&lt;/p&gt;
&lt;p&gt;24 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
If Nastran fails with System Fatal Message 3008, this indicates insufficient Nastran Open Core memory. T o allocate more
memory to Open Core, you should decrease the default Persistent Memory allocation. This can be done by reducing the
percentage of total memory allocated to PMEM. For example:
mem=max memorymax=100gb
•By default, 80% of total memory is allocated to Persistent Memory
Nastran Open Core: 10gb; Nastran Buffer Pool: 10gb; Persistent Memory: 80gb
•If Nastran fails due to insufficient memory, reduce the PMEM allocation:
mem=max memorymax=100gb  pmem=70
•Nastran Open Core: 20gb; Nastran Buffer Pool: 10gb; Persistent Memory: 70gb
Similarly, if MSC Nastran has insufficient Persistent Memory, the PMEM allocation will need to be increased above 80%.
Note that since the default is 80+, more PMEM memory will be automatically allocated from the system if available.
Demonstrations: Example Problems
In this section, we will examine the user interface, detailing how to access the new solver directly from the MSC Nastran
input deck. Additionally, we will showcase performance improvements on customer models, highlighting the enhanced
capabilities of this solver release.
Setting up the run
The examples can be located under MSC Nastran&amp;rsquo;s Test Problem Library (TPL) using the following path:
..\tpl\enhnlso\pl4007load.dat&lt;br&gt;
..\tpl\enhnlso\enhnaselm02.dat
The keywords to activate the new solver are highlighted in yellow in the input decks below:
SOL 400
CEND
TITLE = MSC.Nastran job created on 16-May-06 at 10:05:01
ECHO = NONE
$ Direct Text Input for Global Case Control Data
NLPARM=1
SUBCASE 1
$ Subcase name : Default
SUBTITLE=Default
ANALYSIS=NLSTATICS
STEP 1
SPC = 2
LOAD = 10&lt;/p&gt;
&lt;p&gt;25  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
DISPLACEMENT(SORT1,REAL)=ALL
SPCFORCES(SORT1,REAL)=ALL
&amp;hellip;
BEGIN BULK
NLMOPTS,NLSSEL,NLPERF
&amp;hellip;
SOL 400
CEND
$ Direct Text Input for Global Case Control Data
TITLE = ENHNLSO
SUBCASE 1
STEP 1
SUBTITLE = NLS
ANALYSIS = NLSTATIC
NLSTEP = 1
SPC = 1
DISPLACEMENT(PRINT,SORT1,REAL)=ALL
SPCFORCES(PRINT,SORT1,REAL)=ALL
STRESS(PRINT,SORT1,REAL,VONMISES,BILIN)=ALL
$ Direct Text Input for this Subcase
BEGIN BULK
NLMOPTS LRGSTRN 2
NLSSEL  NLP ERF
ASSM    OFF&lt;/p&gt;
&lt;p&gt;26 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
Performance Improvements
The performance improvement of NLPERF is investigated for the battery pack, motor assembly and chassis assembly
models shown in Figure 2-3.
Figure 2-3  Details of Battery, Motor and Chassis Assembly Models
The performance improvement  observed in following v ariants (1. only conventional elements, 2. hybrid of conventional
and advanced nonlinear elements, and 3. only advanced nonlinear elements) of battery assembly model is shown in
Figure 2-4 with labels Nas, Hyb, and Adv respectively.
For serial runs, NLPERF showed better performance by using 40% to 44% less wall time compared to the time taken by
CNLS. With SMP=32 runs, NLPERF showed better performance by using 65  - 72% less wall time compared to the time
taken by CNLS (2.8x to 3.6x speedup).&lt;/p&gt;
&lt;p&gt;27  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index&lt;/p&gt;
&lt;p&gt;Figure 2-4  Performance Improvement in Battery Assembly Model
The motor assembly and chassis assembly models also show similar performance improvement for NLPERF in both serial
and SMP=32 runs, as shown in Figure 2-5 and Figure 2-6.
The performance improvement of NLPERF has also been observed for various industry strength customer benchmarks
with similar or better performance improvements (2x to 3x+ speedup) as shown in Figure 2-7.&lt;/p&gt;
&lt;p&gt;28 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
Figure 2-5  Performance Improvement in Motor Assembly Model
Figure 2-6  Performance Improvement in Chassis Assembly Model&lt;/p&gt;
&lt;p&gt;29  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
Figure 2-7  Performance Improvement in Engine Assembly Model
The performance of NLPERF in MUMPS Distributed Memory Parallel (DMP) runs is also tested for the motor and
battery assembly models for various combinations of DMP (1 to 8) and SMP (1 to 32) runs. The performance data from
these DMP &amp;amp; SMP runs for NLPERF for a s ingle host are shown in Figure 2-8 and Figure 2-9.  The MUMPS solver in
NLPERF is showing good performance for SMP/DMP runs in a single-host system. The performance of the battery
assembly model for SMP/DMP runs for both single and dual hosts are compared in Figure 2-10. For DMP=4 &amp;amp; DMP=16
run, the dual host run shows around 16% additional performance improvement compared to a single host run.
Figure 2-8  NLPERF - Mumps DMP Performance Data of Motor Assembly Model&lt;/p&gt;
&lt;p&gt;30 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index&lt;/p&gt;
&lt;p&gt;Figure 2-9  NLPERF - Mumps DMP Performance Data of Battery Assembly Model&lt;/p&gt;
&lt;p&gt;Figure 2-10  NLPERF - Mumps DMP Performance Data - Single and Dual Host Runs&lt;/p&gt;
&lt;p&gt;31  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
New ITR File
With NLPERF , a new output file with the extension .itr provides more information during the analysis. Here is an example
of an .itr  file. It includes SUBCASE, LOAD STEP , INCREMENT, and ITERATION information.
It provides progress messages for an iteration process as well as the convergence behavior.
Here is the convergence information of residual force (or/and moment)
For the displacement, it shows the following information:&lt;/p&gt;
&lt;p&gt;32 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
It also reports CONTACT SEPARATION information, as well as CUT-BACK information, if they occur.
At the end of each increment, it summarizes the number of SEPARATIONs and CUT-BACKs as follows:
GUI to Monitor Analysis Behavior
With NLPERF , a new GUI to monitor the convergence behavior (called the Convergence Monitor) is developed to help
users to check the process of the nonlinear analysis. It makes use of the aforementioned ITR (seen in New ITR File ) to
graphically display the iteration process. It allows the user to visually observe the convergence behavior of the analysis.
It provides two ways to access the GUI monitor for checking the analysis status as follows:
A) Activating GUI monitor in the running command line
The GUI for the Convergence Monitor may be activated at the beginning of the analysis by requesting MONITOR in the
command line, for example:
nast_ver input_data_file monitor=yes keywords
The default for the MONITOR option is NO, i.e., the GUI monitor will not be activated when the MSC Nastran analysis
run starts.
B)Activating by MSC utility
The GUI for the Convergence Monitor may be activated at any time by an MSC standalone utility as follows:
msc_ver monitor job.itr&lt;/p&gt;
&lt;p&gt;33  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
The following figure shows the interface of the GUI for the Co nvergence Mo nitor.
Figure 2-11  GUI Interface for Convergence Monitor with NLPERF
After activating the Convergence Monitor Graph, the BROWSE option can be used to display the ITR file.
On the left panel, it shows:
1.Increment with iteration,
2.Singularity ratio,
3.Number of separations,
4.Number of cut-backs (Bisection),
5.Wall time.
On the right panel, it has two figures of convergence ratio vs. increments or cumulative iterations, respectively.
If both force and displacement convergence criteria are used, the left Y-axis is used for the residual force convergence ratio,
and the right Y-axis is used for the displacement convergence ratio.
If the Y-axis scale range is exceeded, the middle mouse wheel can be used on the Y- axis to adjust the range. For the X-axis,
20 cycles can be viewed at a time - the horizontal bar can be moved back and forth to the increments and iterations of
interest.&lt;/p&gt;
&lt;p&gt;34 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
Figure 2-12  Usage of GUI for Convergence Monitor with NLPERF
Out-of-Core with MUMPS
The out-of-core (OOC) performance of NLPERF is investigated for the battery pack model as shown in Figure 2-3. The
battery pack model is tested on a Linux 64bit machine with 1 TB machine memory (RAM). With implementation of the
OOC feature for the MUMPS solver, the NLPERF analysis runs successfully and consumes 466 GB memory for MUMPS
solver. The use of the minimum memory option MDLPRM, PRDOOC, 2 further limits memory consumption to 324 GB.
Benefits with New or Improved Features in the New SOL400 solver
The revamped structure reduces I/O during nonlinear analysis with advanced nonlinear elements.
•The Mumps solver is supported in NLPERF in both SMP and DMP modes. There is no Mumps support in
CNLS. While the default mode is in-core, MUMPS can also be used in an out-of-core mode.
•Advanced elements support SMP threading to higher thread counts. For larger models, scaling can go up to
24 - 32. In CNLS, typical SMP scaling for advanced elements does not exceed 4 - 8.
•New ITR file provides more and clear information of convergence behavior during the analysis
•New GUI monitor provides users a helpful tool to check the analysis status for large scale model visually and
easily
•The Arc Length Method is supported for contact problems in NLPERF .
Unsupported MSC Nastran Input Entities
Note:   In this release, ONLY nonlinear statics (NLSTATICS) is supported with ONE subcase that can include
one or more load steps.&lt;/p&gt;
&lt;p&gt;35  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
Below is a list of unsupported entities.
FMS commands
•CONNECT SERVICE for UDS
•NLRESTART
CASE control commands
•Any ANALYSIS types except NLSTATIC
•No support for Multi-Discipline
•No support for Linear Perturbation
•Multiple SUBCASEs
•NLOPRM (only NLDBG for contact is supported)
•RGYRO (Roto-dynamic)
•NLBUCK (Nonlinear Buckle)
•IMPERF (Imperfection)
•BSQUEAL (Brake Squeal analysis)
•NLIC (linear perturbation)
•COSMSEL (Co-simulation with scFlow)
•IRLOAD (Nonlinear Inertia Relief)
•Design Optimization (DES*)
•SMETHOD
•ESE, EKE, and EDE
•GPFORCE (Grid point force)
•MONITOR
•STOCHAS
•HADAPTL
•NLADAPT
•TEMP (MATE) and TEMP (BOTH)
Bulk Data entries
•ACMODL (Fluid-Structure Interface Parameters)
•CINTC
•RBAR entry where the C NA and CNB entries are both non-zero. Note that RBAR will work if only CNA-CMB
or CMA-CNB is specified.&lt;/p&gt;
&lt;p&gt;36 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
•RBE1 entry, RSSCON and RSPLINE
•RTRPLT and RTRPLT1
•Quadratic elements with missing mid-side node(s)
•Smart Super-element (Linear and Nonlinear; ROM)
•NLPARM (select options are unsupported)
a.For KMETHOD, AUTO, ITER, SEMI, are not supported
b.CONV: some c onvergence criteria are n ot supported
i.Strain energy checking (W) and any combination of W with displacement checking (U) or residual
checking (P)
ii.U, P, UP without Vector style checking (V)
iii.Auto-Switch (A) is always turned off
iv.    See Convergence criteria  for the Convergence criteria table
c.The following parameters in NLPARM are not supported:
i. MAXDIV  Limit on probable divergence conditions per iteration before the solution is assumed to diverge
ii. MAXQN  Maximum number of quasi-Newton correction vectors to be saved on the database.&lt;br&gt;
iii. MAXLS  Maximum number of line searches allowed for each iteration.&lt;br&gt;
iv. FSTRESS  Fraction of effective stress used to limit the sub-increment size in the material routines.&lt;br&gt;
v. LSTOL  Line search tolerance.&lt;br&gt;
vi. MAXR  Maximum ratio for the adjusted arc-length  increment relative to the initial value.
•NLSTEP (select options are unsupported)
CONV: Same conditions as described for NLPARM
•PLPLANE
•PAXISYM
•PLCOMP
•UDS
•MATDIGI
•TEMPRB
•NLMOPTS, TEMPP, LINE
Supported Parameter entries
In NLPERF , ONLY  the following parameters are supported.
•AUTOMSET&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P3</title>
      <link>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_003/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_003/</guid>
      <description>
        
        
        &lt;p&gt;37  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
•EPSILONT
•FOLLOWK
•KDIAG
•LGDISP
•K6ROT
•WTMASS
•NLAYERS
Comparing the classic SOL 400 with the new SOL 400 solver
•OLOAD RESULTANTS&lt;br&gt;
a.In the new SOL 400 (NLPERF), OLOAD RESULTANTS are displayed for every load step right before
the analysis of the current load step. Note that all loads that are applied on the geometry are taken into
account including loads that are of follower-force type.
b.In classic SOL 400 (CNLS), OLOAD RESULTANTS are displayed for all the load steps before all the
analysis and for PARAM,LGDISP. Note that only loads that are not of follower-force type are included in
the OLOAD RESULTANT.
Understanding any result discrepancies: New Nonlinear Performance Solver
(NLPERF) versus. Classic SOL 400 Solver (CNLS)
The new SOL 400 solver may produce results with some variations in comparison to the classic SOL 400 version. In this
section, a concise overview of potential factors that could contribute to result discrepancies is provided.
Contact Related
Friction convergence check in Node-to-Segment contact
NLPERF checks friction convergence at every iteration with an internal tolerance of 0.05
CNLS does not check for friction convergence.
Geometry Adjustment with Initial stress free procedure in Segment-to-Segment contact
NLPERF: the initial stress free projection with segment-to-segment contact uses a new algorithm which may adjust either
contact body surfaces in the contact pair .
CNLS: the initial stress-free projection adjusts the geometry of the secondary contact body surface only.
Convergence check with separation in Segment-to-Segment contact
NLPERF: when UV convergence criterion is prescribed by the user, P convergence criterion (i.e., residual convergence
check) is automatically implemented after separation occurs.&lt;/p&gt;
&lt;p&gt;38 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
Lagrange Multiplier vs. Matrix Solver Constraint Method
For Node-to-Surface (N2S) contact, classic SOL 400 uses the Lagrange multiplier technique in which rigid elements are
assembled into the global stiffness matrix, whereas the new solver uses row-column elimination applied to the global
stiffness matrix. In case of constraint conflicts, this might lead to different results between the two solvers.&lt;br&gt;
Output of Contact Force
In NLPERF , the output of Contact Force includes the contribution from the residual forces. If the residual force is relatively
large and has not completely converged, the contact force output may be different from the CNLS contact force output.
If boundary constraints are defined on the nodes of the contact surfaces, the reaction forces of the boundary constraints are
included in the output of the contact force in NLPERF .
When using N2S contact in NLPERF for layered shells, the separation forces between surfaces in a particular pair are
calculated using only the contribution from the touching node in this pair, while in CNLS the contributions from all
surfaces connected to the touching node are considered. This may lead to different separation behavior..&lt;br&gt;
BCGRID
If the BCGRID option defines contact nodes which belong to different element types, for instance when defined for both
bi-linear and quadratic elements, NLPERF does not work correctly.
Convergence criteria
In both NLPARM and NLSTEP , some CNLS CONV criteria are not available in NLPERF:
•Strain energy checking criteria (W) is not supported in NLPERF.
•Strain energy checking (W) with any combination of displacement checking (U) and residual checking (P) is
not supported in NLPERF
•U, P or UP without vector component checking (V) is not supported in NLPERF
•Auto Switch option (A) is not supported in NLPERF
UP Converge Check Logic
When using UP converge criteria, CNLS and NLPERF behave slightly differently. In CNLS, if the P value is very small in
the first iteration, it may ignore the U check and may consider the iteration to be converged. However, in NLPERF , it still
checks U and does a minimum of 2 iterations.Convergence Option CNLS NLPERF
UV, PV, UPV supported as is supported as is
U, P , UP supported as is V option is used (UV, PV, UPV)
W supported as is not supported, default CONV is used
UW,  PW, UPW supported as is W is dropped. V option is used (UV, PV, UPV)&lt;/p&gt;
&lt;p&gt;39  CHAPTER 2
Advanced Implicit Nonlinear (SOL 400)
Main Index
Prediction Correction with Time Step Update
At the beginning of each new increment, stress, strain, and other results from the previous increment are used to calculate
the stiffness.
In CNLS, the increments of stress, strain, etc is unchanged when used to calculate the stiffness even if the time step of the
new increment has been changed.
In NLPERF , if the time step of the new increment has changed (EITHER increasing or decreasing), the effective scale factor
is calculated and applied to those increments of stress, strain, etc . from the previous increment for the stiffness calculation
of the first iteration as prediction.
Solvers (MSCLDL or Pardiso vs. MUMPS)
In NLPERF , the default solver is MUMPS. The classic SOL 400 (CNLS) supports both MSCLDL (Default) and Pardiso
but not MUMPS.
Pressure Loads
For linear triangular faces (e.g. Pressure loads on 4 node TETRA, triangular face of a PENTA, etc.), CNLS (classic SOL
400) allows for non-uniform distribution of pressure, but the new solver NLPERF does not support it. NLPERF uses only
one integration point for the pressure integration; therefore, 1/3 of the pressure value at the centroid multiplied by the area
of the face is distributed to each corner node.
Different Formulation of K6ROT
For both CNLS (classic SOL 400) and NLPERF , the K6ROT parameter may be specified to control a potential drill
rotation singularity. However, the formulation used in CNLS is different to NLPERF . In CNLS, the effect of a change in
the rotation is considered, while in NLPERF it is not.&lt;br&gt;
Follower Force Differential Stiffness
In CNLS, the follower force differential stiffness is calculated for these types: point loads and pressure loads. In NLPERF ,
point load follower forces are not supported.
Solution of Unsymmetric Matrix
In CNLS, if an unsymmetric matrix is present, an unsymmetric solution procedure is selected automatically to solve the
problem. In NLPERF , a symmetric matrix solution is applied by default: the use of an unsymmetric solution procedure
must be specified manually.
Differential Stiffness
Differential stiffness is not supported for rigid elements (RBAR, RBE2, RBE3, RROD) and for beam-shell offsets in
NLPERF . This can negatively impact convergence for problems where the rigid elements or offset vectors are undergoing
large rotations or large thermal deformations.&lt;/p&gt;
&lt;p&gt;40 MSC Nastran 2024.1 Release Guide
NLPERF - High-Performance Nonlinear Solver
Main Index
AUTOMSET
In NLPERF , AUTOMSET=AUTO is the default for the residual structure. For upstream    super-elements, the default is
AUTOMSET=NO. If AUTOMSET is explicitly specified in the input, then both upstream super-elements as well as the
structure will have the same setting.
Known Issues in this release
1.When super-elements are present and simple, general or rigid element types in the super-elements connected to a
boundary grid of the residual structure do not have the same number of degrees-of-freedom as the residual elements
connected to the same grid, NLPERF may exit with a Fatal Error or may generate incorrect results. This includes
the case where the residual structure does not contain any elements.
2.External Modules connected with MPCs to the residual structure are not supported in NLPERF. This includes the
case where a superelement is connected via more than one rigid element to the residual structure. For external
superelements or modules, all boundary nodes must be defined in the master input file under the bulk data section.
3.In some cases, contact with LINCNT may yield incorrect results.
4.NASTRAN SYSTEM=213 is not supported in either CNLS or NLPERF for advanced nonlinear elements are
present.Note:   Except the issues listed in Section 6 and 8 for unsupported entries and items which may induce the
different results, the followings are also Known Issues.&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 3: Dynamic Analysis
3 Dynamic Analysis
Single-step TPA     42
Nastran PEM Solution Enhancements     55
ADAMS MNF Enhancement: Acoustic Pressure Recovery in Adams     63
Peakout Support for ERP     66&lt;/p&gt;
&lt;p&gt;42 MSC Nastran 2024.1 Release Guide
Single-step TPA
Main Index
Single-step TPA
Introduction
In NVH (Noise, Vibration, and Harshness) studies, Transfer Path Analysis (TPA) has been a well-established experimental
and simulation-based technique [ 1., 2., 3., 4.] for estimating and ranking the noise and vibration contributions via the
different structural transmission paths in a structure or structure-cavity system.
There are three elements which a TPA concerns:
1.System&amp;rsquo;s actively vibrating components , such as engines, gearing or power train systems, or wheel
suspension/chassis systems, from which the source excitations are originated and enter the system.
2.System&amp;rsquo;s passive components , where the structural or acoustic responses at some selected receiver locations, such
as velocity at a steering wheel or sound pressure near a passenger&amp;rsquo;s ear, are of interest.
3.Transmission paths , which are often associated with what is called attachment, interface, or connection points,
connecting the passive components to the active ones. The engine mounts, for example, are typically chosen as paths
for diagnosing the engine-generated noises. A path represents the pathway of a vibration energy flow, from an
interface or attachment point to the receiver point.
TPA allows engineers to represent the source excitations by the forces and vibrations at the interface points on the passive
side. Each degree of freedom (DOF) of an interface/attachment point represents a path, where the operational force from
the active side is applied. In most engineering practice, only the three translational DOF&amp;rsquo;s are considered, while the three
rotational ones are ignored. The responses at the receiver point from an individual path constitute the contributions from
the path.
For finite-element based TPA, normally two-step s are required:
Step One: Full assembly Frequency Response Analysis for responses and interface forces
•Identify the active and passive components in the whole assembly system, such as a full vehicle model.&lt;br&gt;
•Specify the interface GRID points at the interfaces between the active and passive components.
•Specify the receiver points where structural or acoustic responses are computed.
•Run a Frequency Response Analysis with the source excitations to get the responses at the receiver points;
Extract the complex grid point forces (GPFORCE) at the interface GRID points, exerted from the active side,
at all forcing frequencies. These GPFORCE components will be applied at each DOF of a path for TPA.
Step Two: Calculate FRF/NTF and perform TPA
•Separate the passive components from the active ones at the interface attachment points
•Calculate the Frequency Response Functions (FRF) or Noise Transfer Functions (NTF) by applying a unit load
at each path. Now the path is represented by its FRF/NTF.
•Perform the TPA analysis: Calculate the contribution from a path by multiplying its FRF/NTF with the
corresponding GPFORCE component.&lt;/p&gt;
&lt;p&gt;43 Dynamic Analysis
Single-step TPA
Main Index
MSC Nastran has always had the ability t o perform TPA, by following the above-mentioned two-step approach. Obviously,
it demands a heavy user involvement in terms of the input set-up, data I/O, multiple job runs, and data post-processing.
An automated TPA, or the Single-step TPA, is desirable in engineering applications.
Benefits
The Single-step TPA has streamlined the multi-step simulation process. There is only one single input file that the user
needs to prepare. The TPA job is run as a regular MSC Nastran job. When the job is completed, all TPA related results are
stored in an HDF5 file for plot ting a nd display.
Model Set-up and TPA Workflow
Figure 3-1 illustrates the model set-up for a TPA procedure on a typical vehicle body-chassis system. The Body/Cavity
subsystem (passive) is connected at the interface GRID points to the chassis/suspension/power train subsystem  (active) ,
where the source excitations (operational loads) enter the vehicle from the wheels/engine mounts and pass through the
chassis/suspensions/engine mounts into the Body/Cavity at the interface GRID points.
The interface forces, Fi, at the interface GRID points, are computed from the source excitations, and the responses, Ui, at
certain points are also computed, before performing a TPA.
To perform a TPA, the body is disconnected from the chassis/suspensions at all interface GRID points. The body/cavity
finite element model is used for computing the F RF/NTF, Hi , by applying a unit load at each DOF of path i. With both
FRF/NTF and the interface force, Fi (GPFORCE), of path i, the contribution, Ui , from path i, is computed as shown in
the equation of Figure 3-1.
Figure 3-1  TPA Set-up of a Vehicle Body-Chassis System in 3D&lt;/p&gt;
&lt;p&gt;44 MSC Nastran 2024.1 Release Guide
Single-step TPA
Main Index
(3-1)
where,
A full TPA model input consists of four main sections:
Case Control Section for a SOL111 run  contains :
•METHOD Command(s)
•FREQ Command
•SDAMP (optional)
•Physical Loading for the Active Model
•TPASET Case Control Command
Main Bulk Data Section  contains
•EIGRL entries
•FREQ entries
•Physical Loading for the Active Model
•TPADEFN Bulk Data entry
•Damping and common parameters
•HDF5OUT INPUT YES
BEGIN BULK PASSIVE
•Contains passive model including user defined interface GRID points
BEGIN BULK ACTIVE
•Contains active model including the associated connector CBUSH/RBEi type elements connecting the interface
GRID points to the active model.
TPA results are computed and stored in HDF5 file as:
•FRF/NTF due to unit load per path
•Interface force per path (GPFORCE)
•Contributions to the total response from individual pathsUt Structural or acoustic responses at selected locations
Ui Contributions from Path i
Hi FRF/NTF for Path i
Fi Interface forces from the active side&lt;/p&gt;
&lt;p&gt;45 Dynamic Analysis
Single-step TPA
Main Index
•Rankings of path contributions at peak responses
The workflow of Single-step TPA is shown in the following flow chart:&lt;/p&gt;
&lt;p&gt;46 MSC Nastran 2024.1 Release Guide
Single-step TPA
Main Index
User Interface
Case Control and Bulk Data Delimiter Commands
Designates the end of the Case Control Section and/or the beginning of a Bulk Data Section.
Format:&lt;/p&gt;
&lt;p&gt;Requests a Transfer Path Analysis.
Format:
TPASET = n
Bulk Data Entry
Defines a TPA set-up.
Format:BEGIN BULK Case Control and Bulk Data Delimiter
Describer Meaning
ACTIVE Indicates the beginning of an active sub-model Bulk Data Section for Single-step TPA
PASSIVE Indicates the beginning of a passive sub-model Bulk Data Section for Single-step TPA
TPASET Transfer Path Analysis (TPA) Request
Describer Meaning
n Set identification of Bulk Data entry, TPADEFN. (Integer&amp;gt;0; Required)
TPADEFN Definition of a Transfer Path Analysis (TPA)
1 2 3 4 5 6 7 8 9 10
TPADEFN SETID GRIDSET UNIT
RESPTYP1 OUTSET1 RESPTYP2 OUTSET2 -etc.- -etc.-BEGINBULKACTIVE
PASSIVE&lt;/p&gt;
&lt;p&gt;47 Dynamic Analysis
Single-step TPA
Main Index
Example:
Guidelines and Limitations
The success of a Single-step TPA relies on an adequate partitioning of the full model into the passive sub-model, which
situates between BEGIN BULK PASSIVE and BEGIN BULK ACTIVE. The rest of model belongs to the active sub-
model. The passive sub-model must contain both the response and the interface grid points, which are defined by the Bulk
Data entry, TPADEFN, and the active sub-model must contain the interface connector elements, such as CBUSH and
RBEi, which connect the interface grid points on the passive side to the active side.
Bulk Data entry, HDF5OUT with INPUT YES , is required for Single-step TPA post-processing with HDF5 database.
In Bulk Data entry, TPADEFN, RESPTYP is “D”, “V” or “A” for a structural GRID point. For a fluid GRID point, it
must be “P” for pressure.
After a Single-step TPA job is terminated, a LOG file, tpa.log, is created. The user can find the runtime information of the
workflow. When the job is terminated abnormally, error information shows up in the LOG file.
The following limitations should be observed:
•Single-step TPA is supported only in SOL 111  (Modal Frequency Response ).
•Multiple TPA configurations are not supported. In other words, Case Control command, TPASET, is not
SUBCASE-selective. It must be placed above all SUBCASE statements.
•Both NASTRAN HDF5(702)  and PARAM, MDLPRM  are not allowed in place in Bulk Data entry,
HDF5OUT, where INPUT YES  is required for creating TPA results in HDF5 database.TPADEFN 100 1001
DA 2002 P 3001
Describer Meaning
SUBID Case Control TPASET ID. (Integer&amp;gt;0; Required)
GRIDSET SET3 ID of interface GRID points, where transfer paths are defined and investigated. (Integer&amp;gt;0;
Required)
UNIT Fortran Unit ID for the internal use. (Integer&amp;gt;0; Default=24)
RESPTYPi Response type of OUTSETi with any combination of “D”, “V” or “A”, as well as “P”. D is for
DISPLACEMENT , V for VELOCITY and A for ACCELERATION. For a fluid GRID point, P is
for PRESSURE. (Character; Default =“D”)
OUTSETi SET3 ID of response GRID points, where the responses, such as
DISP/VELO/ACCEL/PRESSURE, are targeted for TPA. Integer&amp;gt;0; Required).&lt;/p&gt;
&lt;p&gt;48 MSC Nastran 2024.1 Release Guide
Single-step TPA
Main Index
Post Processing and Results Plot
TPA results are computed and stored in HDF5 database files. They are readily available for results display and plotting,
using a user-preferred GUI tool.
For the user&amp;rsquo;s convenience, a Python-based snippet code is provided here for TPA results display, see Appendix A: Python
Code for Post Processing TPA HDF5 File. Additional information on HDF5 can be found in [ 5.].
Example
A vehicle vibrational model is taken as an example for demonstrating the Single-step TPA, as shown in Figure 3-2.
Figure 3-2  Yaris Model for Single-step TPA
It contains about 995,106 shell elements (CQUAD4 and CTRIA3), 22,301 solid elements (CHEXA and CPENTA), and
1,065,542 GRID points. There are 12 interface GRID points, which separate the passive part from the active one in the
full model.
The input file ( MSC_DOC_DIR\tpl6\single_step_tpa\ostpa_yaris.dat ) description of this model is shown as
follows.
SOL 111
DIAG 5,8,15,53
domainsolver acms
$
CEND
ECHO=NONE
$set 200= 48067
$set 7000=101,102,141,201,202,241,301,&lt;/p&gt;
&lt;p&gt;49 Dynamic Analysis
Single-step TPA
Main Index
$         321,341,401,421,441
METHOD(STRUCTURE) =        9
FREQUENCY         =        8
$
$ To activate Single-step TPA
TPASET = 100
SUBCASE       1
LABEL General Frequency Response Analysis
DLOAD =        2
$
BEGIN BULK
$
MDLPRM  OFFDEF  LROFF
PARAM,GRDPNT,0
PARAM,PRGPST,NO
$
$ HDF5OUT INPUT YES is required for post-processing of TPA results
HDF5OUT PRCISION 32     INPUT   YES
$
$=======2=======3=======4=======5=======6=======7=======8=======9=======0
$TPADEFN SETID   GRIDSET UNIT
$       RESPTYP1OUTSET1 RESPTYP2 &amp;hellip;     &amp;hellip;
$=======2=======3=======4=======5=======6=======7=======8=======9=======0
$ Define interface and response GRID sets, and response type
TPADEFN 100     2000    24                                              +&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;  A       2001
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$SET3,1000,elem,1,thru,12
SET3,2000,grid,101,102,141,201,202,241
,301,321,341,401,421,441
SET3,2001,grid,48067
PARAM,G,0.06
FREQ1          8      1.     1.0     99
EIGRL          9            200.               0                MASS
$
$===============================
$ Passive part for FRF and EXTSE
$===============================
BEGIN BULK PASSIVE
$ Passive part
include &amp;lsquo;Yaris_bodyonly.bdf&amp;rsquo;
$===============================
$ Active part for loads
$===============================
BEGIN BULK ACTIVE&lt;/p&gt;
&lt;p&gt;50 MSC Nastran 2024.1 Release Guide
Single-step TPA
Main Index
$ Active part
include &amp;lsquo;Yaris_chassisonly.bdf&amp;rsquo;
DAREA          1 4024329       3      1.
DAREA          1 4024325       3      1.
DAREA          1       2       3      1.
DAREA          1       1       3      1.
RLOAD2         2       1                      1.
$
ENDDATA
Upon the job completion, an HDF5 file, ostpa_yaris.h5 , is created to store TPA results, as shown in Figure 3-3.
Figure 3-3  TPA Results Stored in HDF5
Using the snippets of Python scripts, attached in the Ap.A: Python Code for Post Processing TPA HDF5 File  for post-processing and
results plot, we can plot the TPA results from the HDF5 file. The following TPA results are plotted using the method of
Approach 2. Some of plot examples are shown in the following figures of plots.  Figure 3-4 shows 3D waterfall plots of TPA&lt;/p&gt;
&lt;p&gt;51 Dynamic Analysis
Single-step TPA
Main Index
path contributions to the Acceleration X-component at GRID 48067. The plots are made from the datasets, TPA-M and
TPA-PH, of data-group, Acce-X.
Figure 3-4  3D Waterfall Plots of Path Contributions to Acceleration X-component at GRID 48067
Figure 3-5 shows the summation of individual path contributions in comparison to the computed (total) acceleration
response at its X-component. The curve labeled as “Solver” represents the total response directly computed by MSC
Nastran SOL 111 solver. The one labeled as “Complex Sum&amp;quot; represents the complex (Real/Imaginary) summation of all
individual path contributions on the Acceleration X-component at GRID 48067. The curve labeled as “InPhase Sum”&lt;/p&gt;
&lt;p&gt;52 MSC Nastran 2024.1 Release Guide
Single-step TPA
Main Index
represents the summation in Magnitude of all individual path contributions. The differences between the Complex Sum
and Solver can be used as a measure for the validation of Single-step TPA algorithm, as shown in the bottom figure.
Figure 3-5  Summation of Path Contributions vs. Total Response
Figure 3-6 shows the ranking of path contributions at a peak response of Acceleration X-component of GRID 48067, at
excitation frequency of 53 Hz. The ranking picks top path contributors in terms of percentage on complex Magnitude and
Phase angle. The summation of all path contributions is also displayed by the vertical bar on the right-hand side in the
middle plot.&lt;/p&gt;
&lt;p&gt;53 Dynamic Analysis
Single-step TPA
Main Index
Figure 3-6  Path Contribution Ranking at Peak Response
Other examples of smaller Single-step TPA models can be found in MSC_DOC_DIR\tpl\single_step_tpa\ .
References
1.J. Plunt, Finding and Fixing Vehicle NVH Problems with Transfer path Analysis, Sound and Vibration, 39(11),
2005.
2.Altair OptiStruct, Transfer Path Analysis, 2023.&lt;/p&gt;
&lt;p&gt;54 MSC Nastran 2024.1 Release Guide
Single-step TPA
Main Index
3.Siemens PLM Software, Transfer Path Analysis, Qualifying and Quantifying Vibro-acoustic transfer paths, White
paper, 2018.
4.MSC Nastran Dynamic Analysis User&amp;rsquo;s Guide, Chapter 4: Frequency Response Analysis, Frequency Response
Function (FRF) and FRF Based Assembly (FBA) and Inter Component Force (ICF) Calculations for
FRF/FBA/TPA Capability.
5.MSC Nastran Reference Guide- Interface with Other Programs&lt;/p&gt;
&lt;p&gt;55 Dynamic Analysis
Nastran PEM Solution Enhancements
Main Index
Nastran PEM Solution Enhancements
Introduction
To address the demands arising from the continuous increase in the model size and the number of modes, the MSC Nastran
PEM workflow has been enhanced.
The 2024.1 release provides:
1.A new method to compress the Reduced Impedance Matrices (RIM) in the modal approach
2.An increased computational efficiency and reduction of memory requirements for the MSC Nastran PEM
workflow using the modal approach for RIM
Benefits
Reduces the hardware requirements to run models with a reduced time of computation.
User Interface
To enable the enhanced MSC Nastran PEM workflow:
1.RIM in modal approach must be selected using parameter TRMBIM
2.A new entry APIM must be defined in the File Management Section (FMS)
The compressed RIM feature can be activated using the existing ACPEMCP entry in the Bulk Data Section. T wo new
entries, CRIMSR and CRIMFR have been added.
The File Management Section
Define through the Application Program Interface Manager a program to be launched in place of Nastran
Format:
APIM PROGRAM=PROG ENVIR=ENV
Example:
APIM PROGRAM=ACTWFM ENVIR=NASTPEMAPIM Application Program Interface Manager&lt;/p&gt;
&lt;p&gt;56 MSC Nastran 2024.1 Release Guide
Nastran PEM Solution Enhancements
Main Index
Remarks:
1.PROGRAM=ACTWFM stands for Actran Workflow Manager and ENVIR=NASTPEM allow to perform Nastran
PEM analysis using this external program in place of Nastran.
Parameter Descriptions
TRMBIM
Default = PHYSICAL
TRMBIM is used to define the formulation used for reduced impedance matrix, RIM, for all trim components requested
under TRIMGRP case control commands. Its default is &amp;lsquo;PHYSICAL&amp;rsquo; which will generate RIM in physical coordinates.
The other valid options for TRMBIM are.
1.&amp;lsquo;MODAL&amp;rsquo; which will produce RIM in modal coordinates
2.&amp;lsquo;DATACHK&amp;rsquo; which perform dry run without producing Reduce Impedance Matrix or results. Job will be
terminated afterwards.
Bulk Data Entry Descriptions
Defines the interface coupling conditions and constraints of a trim component.
Format:Describer Meaning
PROG PROGRAM NAME TO BE LAUNCHED
ALLOWED VALUE: ACTWFM
ENVIR ENVIRONMENT VARIABLE RELATED TO THE PROGRAM
ALLOWED VALUE: NASTPEM
ACPEMCP Trim Component Interface Coupling and Constraints Definition
1 2 3 4 5 6 7 8 9 10
ACPEMCP TID SGLUED SSLIDE SOPEN SIMPER OOC SPM SAIRGAP
SCUX SCUY SCUZ SCRX SCRY SCRZ SCFP RID
CRIMSR CRIMFR&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P4</title>
      <link>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_004/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_004/</guid>
      <description>
        
        
        &lt;p&gt;57 Dynamic Analysis
Nastran PEM Solution Enhancements
Main Index
Example:
ACPEMCP 1  1002  1004&lt;br&gt;
Describer Meaning
TID  Identification number of trim component. (Integer&amp;gt;0; Required)
SGLUED Identification number of SET1/SET3 entry of grids belonging to the solid-phase and/or structure
volume elements in the trim component, which are glued to a structure; see Remark 2. (Integer  0 or
Blank)
SSLIDE Identification number of SET1/SET3 entry with grids belonging to the solid-phase and/or structure
volume elements in the trim component, which are in the sliding-contact to a structure; see Remark 3.
(Integer 0 or Blank)
SOPEN Identification number of SET1/SET3 entry of grids belonging to the fluid-phase elements in the trim
component, which has an open interface with the cavities; see Remark 4. (Integer 0 or Blank)
SIMPER Identification number of SET1/SET3 entry of grids of the solid-phase and/or structure volume elements
in the trim component, which has an impervious interface with the cavities; see Remark 5. (Integer0 or
Blank)
OOC Number of blocks for Out-Of-Core solver, see remark 8. (Integer≥1, Default=1)
SPM Flag for selecting single precision MUMPS for computing reduced impedance matrix, see Remark 9.
(Integer0 or Blank)
SAIRGAP Identification number of SET1/SET3 entry with grids belonging to the solid-phase and/or structure
volume elements in the trim component, which are in contact with structure via air gap. See Remark 10.
(Integer  0 or Blank)
SCUX ID of SET1/SET3 with which grid IDs in the trim component TID is zero-constrained in translation X
direction of output coordinate system. (Integer 0 or Blank)
SCUY ID of SET1/SET3 with which grid IDs in the trim component TID is zero-constrained in translation Y
direction of output coordinate system. (Integer 0 or Blank)
SCUZ ID of SET1/SET3 with which grid IDs in the trim component TID is zero-constrained in translation Z
direction of output coordinate system. (Integer 0 or Blank)
SCRX ID of SET1/SET3 with which grid IDs in the trim component TID is zero-constrained in rotation X
direction of output coordinate system. (Integer 0 or Blank)
SCRY ID of SET1/SET3 with which grid IDs in the trim component TID is zero-constrained in rotation Y
direction of output coordinate system. ( Integer0 or Blank)
SCRZ ID of SET1/SET3 with which grid IDs in the trim component TID is zero-constrained in rotation Z
direction of output coordinate system. (Integer 0 or Blank)
SCFP ID of SET1/SET3 with which grid IDs in the trim component TID is zero-constrained in fluid
pressure. (Integer0 or Blank)
RID ID of a region of a TRMC. ( Integer ≥ 0  or Blank) .&lt;/p&gt;
&lt;p&gt;58 MSC Nastran 2024.1 Release Guide
Nastran PEM Solution Enhancements
Main Index
Remarks:
1.ACPEMCP is a required entry for each trim component that is referenced by TRIMGRP. It must be put in the
main Bulk Data section or BEGIN BULK. It specifies the boundary coupling conditions as well as the coupling
degrees of freedom for computing the reduced boundary impedance matrices of the trim component.
2.A glued interface means that the trim component is completely constrained on to the structure, such as a car body.
There is no relative movement between the trim component and the structure at the interface.
3.A sliding interface means that the trim component is laid on the surface of structure, such as a car body. There is
no relative movement in the normal direction of the interface between the trim component and the structure.
Relative sliding movement is allowed in the contact surface.
4.An open interface means that the free flow of fluid between the fluid-phase and cavities occurs at the interface.
5.An impervious or closed interface means that the fluid flow between the trim component and cavities is prohibited
at the interface. This can happen when the porous material is covered by a thin film which stops the fluid flow or
the cavity is in touch with a structure part of the trim component.
6.The SET1/SET3 entries must reside in the Bulk Data section introduced by Case Control, BEGIN BULK TRMC.
7.Under current PEM implementation, only 3D elements are allowed for trim components. Hence, SCRX, SCRY
and SCRZ fields of ACPEMCP are not processed.
8.OOC is intended for large trim component s. The number in the O OC field defines the number of blocks to be
used for the Schur complement evaluation which reduces the memory requirement. A side effect of OOC&amp;gt;1 is that
a full RIM is generated, instead of lower triangular RIM, which is similar to PARAM,PEMFRIM,1.
9.SPM is a flag for selecting single precision MUMPS in ACTRAN. With default value of 0, double precision
MUMPS is utilized. Single precision MUMPS will be used with SPM field having value greater 0. Single precision
MUMPS has the benefits of reduced memory requirement and better performance. However, single precision
MUMPS may suffer a minor degradation on accuracy.
10. An air gap interface means the trim component is assumed to be coupled to the structure through a very thin air
layer. The thin air layer is taken into the analysis without being modeled (not being defined in the trim model file).
11. A TRMC can have many ACPEMCP entries. However, an ACPEMCP of a TRMC with blank RID field is a must
before ACPEMCP with non-blank RID can show up.
12. CRIMSR and CRIMFR compression ratios allow to reduce the size of the reduce impedance matrices. This size
reduction allows a significant memory disk usage reduction. This compression may imply a loss of accuracy on
results. A ratio of 1.0 means no compression. CRIMSR and CRIMFR requires the modal approach be selected for
RIM (PARAM,TRMBIM,MODAL)CRIMSR Reduced Impedance Matrix Compression Ratio for coupling with structure (1.0 ≥ Real &amp;gt; 0.0,
Default=1.0)
CRIMFR Reduced Impedance Matrix Compression Ratio for coupling with cavity (1.0 ≥ Real &amp;gt; 0.0, Default=1.0)Describer Meaning&lt;/p&gt;
&lt;p&gt;59 Dynamic Analysis
Nastran PEM Solution Enhancements
Main Index
Inputs / Outputs Description
The input of the enhanced MSC Nastran PEM workflow uses the normal M SC Nastran PEM SOL 111 input, w ith the
addition of the APIM FMS entry and the modal approach for generating the RIM ( PARAM,TRMBIM,MODAL).
The output requests and output format remain unchanged, only the destination folder of the results is changed.
With the enhanced MSC Nastran PEM workflow many directories are created corresponding to the different step s of the
workflow:
•report: Contains log files.
•00_PRE_SOL_103: Contains input and log files.
•01_Mapping_Control: Contains input and log files.
•02_SOL_103: Contains input and log files.
•03_ACTRAN: Contains input and log files.
•04_SOL_111: Contains input, log and result files.
The usual *.h5, *.f06, *.pch and *.op2 files containing the results are stored in the 04_SOL_111 directory.
Guidelines, Perspectives and Limitations
Guidelines to set-up a model remain unchanged, except for the requirement that an APIM FMS entry m ust be added to
the input deck.
In order to keep good accuracy of results using the compressed RIM feature, it is recommend to not request compression
factors below 0.9. It is possible that, for some TRIM, the compression will not provide sufficiently accurate results. In this
case increasing the compression ratio value or deactivating the compression for this particular TRIM should result in the
expected results.
The enhanced MSC Nastran PEM workflow using the modal approach for RIM is not fully compatible with all the
capabilities of the MSC Nastran PEM workflow using the physical approach for RIM:
•ACOWEAK coupling
•PARAM,DBALL,SCRATCH
•Participation factors considering effects of the TRIM
•Trim data recovery
The RIM compression feature is not compatible with analytical TRIM and no modeling using compressed RIM and
analytical TRIM is allowed.
It is not recommended to run many different models in the same directory using the enhanced MSC Nastran PEM
workflow. Results will be overwritten.
The enhanced MSC Nastran PEM workflow do es not yet support  jobs using multi hosts.&lt;/p&gt;
&lt;p&gt;60 MSC Nastran 2024.1 Release Guide
Nastran PEM Solution Enhancements
Main Index
Example
Here are the results of the enhanced workflow obtained for the Dodge Neon model.&lt;/p&gt;
&lt;p&gt;Figure 3-7  View of the Car System
2D Elm = 1219407 TRIM = 4 7.6mi DOF 5229 (Structure) Modes
3D Elm = 407764 Subcases = 3 20 RIM Frequency 1231 (Fluid) Modes&lt;/p&gt;
&lt;p&gt;61 Dynamic Analysis
Nastran PEM Solution Enhancements
Main Index
In the following charts are presented the improvements resulting from using t he enhanced workflow in terms of
performances.&lt;/p&gt;
&lt;p&gt;62 MSC Nastran 2024.1 Release Guide
Nastran PEM Solution Enhancements
Main Index
Compared to physical approach for RIM, the enhanced MSC Nastran PEM workflow provides the same results. Results
when RIM compression is activated provide a very good accuracy.&lt;/p&gt;
&lt;p&gt;63 Dynamic Analysis
ADAMS MNF Enhancement: Acoustic Pressure R ecovery in Adams
Main Index
ADAMS MNF Enhancement: Acoustic Pressure R ecovery in
Adams
Introduction
Many OEMs want to review acoustic pressures in their Adams flexible body models. The flexible body models are generated
from a fluid-structure-interaction model defined in MSC Nastran. Previously, only the structural component modes of
these models were stored in the Adams MNF and used to perform durability studies in Adams. In in order to recover the
acoustic pressures the transient results of the Adams simulation had to be transferred back to Nastran.
This release enables the recovery of acoustic pressures directly in Adams. In order to facilitate this the fluid modes at user
specified acoustic grids are included in the Adams MNF along with the structural modes.
Benefits
In prior releases, recovering acoustic pressures from Adams simulations involved a three-step process:
1.MNF of flexible structure only is created in Nastran
2.Adams simulation is performed with this MNF, lastly
3.Nastran is restarted to recover acoustic pressures with results from Adams.
With this enhancement simulating acoustic pressures can be done in two steps, allowing the acoustic pressures to be plotted
directly in Adams without having to go back to Nastran to recover. These acoustic pressures can be included in design or
DOE studies to improve model design.
User Interface
The ability to select fluid grids for acoustic recovery in Adams has been added to the ADAMSMNF command. The new
option on the ADAMSMNF case control for doing this is ACSETID as shown below:
Format:
ADAMSMNF {ACSETID=n}
Examples:
SET 10 = 55, 67, 1889
ADAMSMNF FLEXBODY = YES ACSETID = 10ADAMSMNF (Case) Control for Nastran/ADAMS Interface&lt;/p&gt;
&lt;p&gt;64 MSC Nastran 2024.1 Release Guide
ADAMS MNF Enhancement: Acoustic Pressure R ecovery in Adams
Main Index
Representative sample Nastran Input file for using the Adams MNF Acoustic enhancement:
$ Exec. Control Section
$ For models &amp;gt; 1 Million DOFs: METHOD(SYMCOUP) with LANCZOS
$ employing MUMPS are highly recommended
SPARSESOLVER READ(FACTMETH=MUMPS)
SOL 103
CEND
$ Case Control Section
TITLE = Sample Nastran Input File for Including Acoustic Modes in MNF
SUBTITLE = Generate MNF for ADAMS
ADAMSMNF FLEXBODY = YES ACSETID = 91
SET 91 = 10030, 10020, 10030
$ METHOD(SYMCOUP) and METHOD(COUPLED) are supported
METHOD(SYMCOUP) = 10
&amp;hellip;
$ Bulk section
BEGIN BULK
DTI, UNITS, 1, KG, N, M, S
EIGRL,10,,,,40
&amp;hellip;
ENDDATA
Guidelines
1.ACSETID references the SET of fluid grids for which acoustic modes are exported. A small number of fluid grids
is recommended for ACSETID. A warning message is issued and acoustic modes are not exported if this set does
not exist or if ACSETID=ALL is chosen by the user.
2.MSC Nastran prints out MNF_Info messages to the F06 on the number of fluid grid modes that were output to
the MNF:
MNF_Info: Acoustic Mode info:
MNF_Info:    Count: 3Describer Meaning
ACSETID Include fluid modes from acoustic grids defined in SET n in the MNF
n SET id that defines the fluid grids.&lt;/p&gt;
&lt;p&gt;65 Dynamic Analysis
ADAMS MNF Enhancement: Acoustic Pressure R ecovery in Adams
Main Index
Example
The Adams Car model shown in Figure 3-8 is being driven over a rough road. The flexible body was created from an MNF
generated by MSC.Nastran SOL 103 with 108 modes and a coupled fluid-structure mesh. Four fluid grids were selected
for acoustic recovery and the modes of these grids were included in the MNF along with the modes of the structure.
Figure 3-8  Adams Car Model with Flex Body from MSC Nastran
Figure 3-9  Acoustic Pressure Time History Plotted at Four Fluid Grids
Figure 3-9 shows the acoustic pressures of the four fluid grids in the cabin of the flexible body. These acoustic pressure time
history plots were generated directly in Adams. Several examples using the Adams MNF acoustic capability are provided in
MSC Nastran Documentation Installation directory: ..\tpl\adamsmnf3
(a) Driving on a Rough Road (b) Flex Body Deformation&lt;/p&gt;
&lt;p&gt;66 MSC Nastran 2024.1 Release Guide
Peakout Support for ERP
Main Index
Peakout Support for ERP
Introduction
In this release, MSC Nastran is enhanced to support the calculation of peak solution s of equivalent radiated power i.e
ERP (SOLUTION=PEAK).
Computation of the equivalent radiated power (ERP) is a simplified method to gaining information about maximal possible
acoustic radiated power of components and panels for specific excitations in frequency response analysis. Currently, when
a user requests ERP (Equivalent Radiated Power) one also needs to define at which frequencies to calculate and write the
ERP results using the SOLUTION keywork on ERP command.
This enhancement extend s the current usage of the already existing PEAKOUT command used for participation factor
calculations and ODS output to the ERP command. The purpose of the PEAK command is to find frequencies of peak
responses, at which ERP will be calculated.
Benefits
The PEAKOUT e xtension of the ERP command will have following benefits:
a.Allow PEAKOUT  request for ERP command.
b.Remove requirement of DISP command for peak dof requested in PEAKOUT .
c.Improve internal routines and workflow to  improve performance .
d.Fixes some robustness issues of the existing PEAKOUT command, which is currently supported for various
output like ODS and PFXX[XX=MODE, PANEL &amp;amp; GRID].
Feature Description
PEAKOUT for ERP has the following features:
1.New solution to calculate peak responses for ERP.
2.Supported for frequency response analysis solutions SOL 108, SOL 111, SOL 200 [Analysis=DFREQ and
MFREQ] and SOL 400 [Analysis=DFREQ and MFREQ].
3.Peak solution for ERP can be computed for both structural and fluid DOF&amp;rsquo;s responses.
User Interface
A new command option, ERP (SOLUTION=peak),  is introduced to support the peak ERP calculations
The modified command includes peak as one of the solution  option s.&lt;/p&gt;
&lt;p&gt;67 Dynamic Analysis
Peakout Support for ERP
Main Index
Examples:
SET 17 = 10.,20.,30.,40.,80.,100. $ A list of frequencies
SET 25 = ROOF, DOORLF $ A list of ERP Panel names
$ from a ERPPNL Bulk Entry
ERP ( PRINT,PUNCH,SOLUTION=17,KEY=frac ) = 25
ERP ( PRINT,PUNCH,SOLUTION=peak, KEY=frac ) = 25
Remark
1.Peak frequency search is controlled by Case Control command, PEAKOUT, which is activated by
ERP(SOLUTION=PEAK).
Guidelines and Limitation
1.One should also include the PEAKOUT command when ERP(Solution=peak) is requested.
2.In general, user must define ERPPNL to get ERP calculations.
3.Displacement output request is no longer required for DOF-SET defined in PEAKOUT command.
Examples
An example of using ERP (solution=peak) is shown below. ( ..\tpl\peakerp\pf8a_erp.dat )Describer Meaning
SOLUTION Keyword to select frequencies or time.
ALL If associated with SOLUTION, all frequencies or times are selected. If associated with
setp, all ERPPNL entries are selected.
setf Identifier of Case Control SET command defining frequencies.
sett Identifier of Case Control SET command defining times.
peak Requests ERP output at peak frequencies found by the PEAKOUT Case Control
command. See Remark 1. (Character).ERPSORT2
SORT1PRINT, PUNCH
PLOTSOLUTIONALL
setf
sett
peak
= &lt;/p&gt;
&lt;p&gt;68 MSC Nastran 2024.1 Release Guide
Peakout Support for ERP
Main Index
Example-1: A fluid structure interaction model which includes a cavity modeled using CHEXA and CPENTA using
PSOLID + MAT10 as the property and material, and the structural component includes beam and shell elements.
Figure 3-10  FE Model of Fluid Cavity and Structure
Here Six ERPPNL are defined using CQUAD4 elements Which includes following element sets.
ERPPNL, LEFT, 101, RIGHT , 201, FRONT, 301, REAR, 401, TOP , 501, BOTTOM, 601.
$ Panels
SET3, 101, ELEM, 127, THRU, 162, 667, THRU, 738
SET3, 201, ELEM,  37, THRU,  72, 739, THRU, 810
SET3, 301, ELEM, 331, THRU, 384
SET3, 401, ELEM,  25, THRU,  36, 73, THRU, 126
SET3, 501, ELEM, 271, THRU, 294, 601, THRU, 612
SET3, 601, ELEM,   1, THRU,  24, 455, THRU, 478,
, 497, THRU, 562
Figure 3-11  Panels defined for ERP&lt;/p&gt;
&lt;p&gt;69 Dynamic Analysis
Peakout Support for ERP
Main Index
Now define the case control command to get peak ERP as follows.
ASSIGN USERFILE = &amp;rsquo;erp_cabin_p8a.csv&amp;rsquo; UNIT=50  FORM=FORMATTED STATUS=NEW, DELETE
set 998=1035, 1038,11217     $ Displacement output Set for plot
set 999=1035/T3              $ Peakout DOF set for Structural
$ responses
set 888=11217                $ Peakout DOF set for Fluid
$ pressure responses
FREQ = 100
peakout npeak=4, peakfrfs=999,peakfrff=888
DISP(PLOT)=998
subcase 1
DLOAD = 200
ERP (PRINT, SOLUTION=peak , ERPRHO=1.21, ERPC=340., CSV=50,
ERPREFDB=1.0E-12, FILTER=0.0001) =ALL
subcase 2
DLOAD = 300          &lt;br&gt;
ERP(PRINT, SOLUTION=peak , ERPRHO=1.21,ERPC=340., CSV=50,
ERPREFDB=1.0E-12, FILTER=0.0001) = ALL
Here we find the peak responses of structural DOF and fluid DOF separately in f06.
a.Peak frequencies for structural DOF 1035/T3 are found and written as follows
AUTOMATIC PARTICIPATION ANALYSIS
SUBCASE       : 1
RESPONSE GRID : 10353 (FOR STRUCTURE GRID, LAST DIGIT IS DOF)
NUMBER OF RESPONSE PEAKS FOR PF DETECTED: 3
*** USER INFORMATION MESSAGE 22508 (SETPEAK)
FREQUENCY : 6.800000E+01
*** USER INFORMATION MESSAGE 22508 (SETPEAK)
FREQUENCY : 7.900000E+01
*** USER INFORMATION MESSAGE 22508 (SETPEAK)
FREQUENCY : 5.700000E+01
b.Peak frequencies for fluid  DOF 11217 are found and written as follows
AUTOMATIC PARTICIPATION ANALYSIS&lt;br&gt;
SUBCASE       : 1
RESPONSE GRID : 11217 (FOR STRUCTURE GRID, LAST DIGIT IS DOF)
NUMBER OF RESPONSE PEAKS FOR PF DETECTED: 4
*** USER INFORMATION MESSAGE 22508 (SETPEAK)
FREQUENCY : 3.800000E+01
*** USER INFORMATION MESSAGE 22508 (SETPEAK)
FREQUENCY : 6.800000E+01&lt;/p&gt;
&lt;p&gt;70 MSC Nastran 2024.1 Release Guide
Peakout Support for ERP
Main Index
*** USER INFORMATION MESSAGE 22508 (SETPEAK)
FREQUENCY : 7.700000E+01
*** USER INFORMATION MESSAGE 22508 (SETPEAK)
FREQUENCY : 5.900000E+01
Also we get output calculated peak ERP in f06 and CSV file. Example for f06
PANEL = LEFT      (AREA =    9.875000E-01)
E Q U I V A L E N T   R A D I A T E D   P O W E R
FILTER :                        1.000000E-04
FREQUENCY              ERP             FRACTION           ERP(dB)
3.800000E+01        1.434299E-06      1.160619E-02      6.156640E+01
5.900000E+01        2.500835E-07      2.023648E-03      5.398085E+01
6.800000E+01        1.235806E-04      1.000000E+00      8.091950E+01
7.700000E+01        4.625162E-06      3.742629E-02      6.665127E+01
&lt;strong&gt;ERP MAX&lt;/strong&gt;        1.235806E-04
Acoustic pressure response plot for Node 11217 also shows peak responses at the identified frequencies.
The ERP command also allows user to create a CSV file in tabulated form which contains ERP output for all subcases and
selected response ids, furthermore csv data can be plotted as a bar chart.&lt;/p&gt;
&lt;p&gt;71 Dynamic Analysis
Peakout Support for ERP
Main Index&lt;/p&gt;
&lt;p&gt;72 MSC Nastran 2024.1 Release Guide
MSC Nastran Cohesive Elements in Linear Analysis
Main Index
MSC Nastran Cohesive Elements in Linear Analysis
Introduction
Nonlinear Cohesive Elements in MSC Nastran SOL400 analysis or from crash type analysis can now be used in standard
MSC Nastran linear analysis by defining in plane stiffness and normal stiffness.
Benefits
This is a major modeling advantage. Cohesive zone modeling is used to model fracture and fragmentation processes in
various materials. Cohesive elements can be used for modeling glue lines. These types of elements are often used in a crash
analysis. The same model can then be used in a standard linear analysis solution, such a linear static analysis or frequency
response analysis. Allowing the cohesive elements to remain “elastically” active in the model removes the requirement of
major modeling changes in the model for linear analysis.
User Interface
The Cohesive elements available in MSC Nastran are the CIFHEX, CIFPENT, and CIFQUAD elements. They utilize the
PCOHE property entry and the MCOHE material entry. To utilize these elements in MSC Nastran linear analysis, only
the MCOHE entry needs to be modified.
The modification to MCOHE for linear analysis is:
where, MCOHE is modified to include a value of -2 for MODEL  (User supplied linear properties), ET - Stiffness in the
plane of the cohesive element, EN - Stiffness normal to the plane of the cohesive element.
Example ( \tpl\lincohe\s101_cifhex_ef.dat )
A beam consists of two separate sections, which are butted together along the section shown by the numbered GRID points.&lt;br&gt;
To hold the two section together, three CIFHEX elements are used as shown in white (note that thickness is zero).
Supported 123 DOF at blue dots and at red dots, enforced motion 23 DOF +.01 for grids to left side of butt and 23 DOF
-.01 for grid  point s on right side of butt .1 2 3 4 5 6 7 8 9 10
MCOHE MID MODEL TID
COHE CRTOD MAXOD SNSR EXP VED RRRD SFC
SNER ET EN&lt;/p&gt;
&lt;p&gt;73 Dynamic Analysis
MSC Nastran Cohesive Elements in Linear Analysis
Main Index
Figure 3-12  Beam with 2 Sections Held Together by Cohesive Elements
Following is an extract from f06 showing stresses appropriate to the type of linear analysis (SOL 101)
S T R E S S E S   I N   H E X A H E D R O N   I N T E R F A C E   E L E M E N T S     ( C I F H E X )
ELEMENT GRID/   POINT    &amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;STRESSES&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;      &amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;STRAINS&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;      DAMAGE
ID   GAUSS     ID    NORMAL-X    SHEAR-XY    SHEAR-XZ    NORMAL-X    SHEAR-XY    SHEAR-XZ    VALUE
0      21 GRID   CENTER  2.6266E+03 -2.9885E-11 -3.6970E+02  2.9184E-03 -4.2690E-17 -5.2814E-04   0.0
25  3.1100E+00 -7.8747E+01 -4.3774E-01  3.4555E-06 -1.1250E-04 -6.2534E-07   0.0
26  5.2501E+03 -2.9389E+02 -7.3896E+02  5.8334E-03 -4.1984E-04 -1.0557E-03   0.0
9  5.2501E+03  2.9389E+02 -7.3896E+02  5.8334E-03  4.1984E-04 -1.0557E-03   0.0
2  3.1100E+00  7.8747E+01 -4.3774E-01  3.4555E-06  1.1250E-04 -6.2534E-07   0.0
55  3.1100E+00 -7.8747E+01 -4.3774E-01  3.4555E-06 -1.1250E-04 -6.2534E-07   0.0
56  5.2501E+03 -2.9389E+02 -7.3896E+02  5.8334E-03 -4.1984E-04 -1.0557E-03   0.0
40  5.2501E+03  2.9389E+02 -7.3896E+02  5.8334E-03  4.1984E-04 -1.0557E-03   0.0
37  3.1100E+00  7.8747E+01 -4.3774E-01  3.4555E-06  1.1250E-04 -6.2534E-07   0.0
Limitations:
1.If included in SOL105, these elements will only contribute linear stiffness, that is, no differential stiffness effects
will be considered.
2.The associated PCOHE/MCOHE entries do not provide for material frequency dependency.
3.The element, property, and material IDs are limited to the standard MSC Nastran 8 digits.
4.For the linear model Tied_Shell_Edge_to_Surface will not be considered.
5.Mass and damping matrices will not be generated in this release .&lt;/p&gt;
&lt;p&gt;74 MSC Nastran 2024.1 Release Guide
MSC Nastran Cohesive Elements in Linear Analysis
Main Index&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 4: Modules MSC Nastran Implicit Nonlinear (SOL 600) User’s Guide MSC Nastran 2013.1
Release Guide
4 Modules
Case Control Output Requests for Modules - MDSET     76
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs     80&lt;/p&gt;
&lt;p&gt;76 MSC Nastran 2024.1 Release Guide
Case Control Output Requests for Modules - MDSET
Main Index
Case Control Output Requests for Modules - MDSET
Introduction
Currently, the Case Control output requests are applied to all Modules. For example, if the STRESS command requests
output for element 101, the program will output stress results for all Modules with element 101. This enhancement will
allow the user to specify which Module(s) with element 101 the program will compute stress results instead of all Modules
with element 101.
A new Case Control command called MDSET is provided. MDSET is similar in format to the SET command with
module-ID added.
MDSET n = { h1 [h2 h3 h4 [THRU h5 [EXCEPT h6 …] ] … }{ m1/i11 i12 i13 … [m2/i21 i22 i23 … i24
[THRU i25 [EXCEPT i26 …] … ] }
where, hi and iij are element or grid IDs, and mi are module IDs.
Benefits
Let&amp;rsquo;s assume a model with two modules with IDs 10 and 20. Both modules have grids 101 through 109 and elements 101
through 104. However, the user wants displacement only in module 10 for grid 105 and stress only in module 20 for
element 103. With the SET command, this is not possible, resulting in excessive output.
SUBCASE 11
SET 1 = 105
DISP=1
SET 2 = 103
STRESS = 2&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P5</title>
      <link>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_005/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_005/</guid>
      <description>
        
        
        &lt;p&gt;77  CHAPTER 4
Modules
Main Index
With MDSET instead of SET:
SUBCASE 11
MDSET 1 = 10/105
DISP=1
MDSET 2 = 20/103
STRESS=2
The following is obtained in the f06.&lt;/p&gt;
&lt;p&gt;78 MSC Nastran 2024.1 Release Guide
Case Control Output Requests for Modules - MDSET
Main Index
User Interface
Define sets that associate module ID with the entity (element and grid) ID and are referenced by data recovery commands
like DISP , STRESS, etc.
Format:
MDSET n = { h1 [h2 h3 h4 [THRU h5 [EXCEPT h6 …] ] … }{ m1/i11 i12 i13 … [m2/i21 i22 i23 … i24
[THRU i25 [EXCEPT i26 …] … ] }
Example s:
MDSET 1 = 1/1 2/3 3/2 5/6
MDSET 100 = 14/ALL
MDSET 4 = 0/17 13/12 0/34 THRU 45 87/1 THRU 100
MDSET 48 = 17 807/1 THRU 100 EXCEPT 55
MDSET 615 = 43/75 62 107 26MDSET Set Definition for Modules Data Recovery
Describer Meaning
n Set identification number. MDSETs specified under a SUBCASE command are recognized for that
SUBCASE only (Integer &amp;gt; 0).
hi Element or grid identification number whose results will be computed for all modules. MDSET has
two sections, which are divided at the beginning of the first module/entity pair. Every entity specified
before the first pair is assigned to all modules and every entity after is assigned to a specific module.
The first section uses the same format as the SET command. (Integer&amp;gt;0 or “ALL”)
mi Module identification number (Integer&amp;gt;0)
iij Element or grid identification number whose results will be computed only for module mi.
(Integer&amp;gt;0 or “ALL”)
i24 THRU i25 Range of element or grid identification numbers (Integer&amp;gt;0 and i25&amp;gt; i24)
EXCEPT Element or grid identification numbers following EXCEPT will be deleted from the set if they are in
the range of the set defined by the preceding
THRU. An EXCEPT list may not include a THRU list or ALL.
ALL All elements or grids in the module.&lt;/p&gt;
&lt;p&gt;79  CHAPTER 4
Modules
Main Index
Remarks:
1.An MDSET command may be more than one physical line. A comma at the end of a physical line signifies a
continuation line follows. Commas may not end a set. THRU may not be used for continuation. Place a number
after the THRU.
2.The element or grid identification numbers following EXCEPT within the range of the THRU must be in
ascending order.
3.MDSET may only be used when Modules exist. If there are no Modules, then the program will issue a User Fatal
Message.
4.The members in a SET and MDSET command with the same set ID will be merged. If there are duplicate set IDs
and just ALL is specified on either MDSET or SET, then ALL overrides the other set without ALL.
5.MDSET is supported in the following solution sequences: 101, 103, 105, 107 through 112, 200 (analysis only),
and 400.
6.MDSET may be referenced by these commands only:
Output
MDSETs control the results in the f06, pch, h5, and op2 files.
Limitations
No graphical user interface.DISP MAXMIN PACCELERATION
SPCF GPKE
FORCE MPRESS
STRAIN EKE
MPCF EDE
STRESS VELOCITY
ESE ACCELERATION
GPFORCE SDISPLACEMENT
NLLOAD SVELOCITY
NLSTRESS SACCELERATION
OLOAD SVECTOR&lt;/p&gt;
&lt;h1&gt;80 MSC Nastran 2024.1 Release Guide
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs
Main Index
HDF5DA - Dedicated and Appended HDF5 Files for MSC
Nastran MODULEs
Introduction
If a MSC Nastran model contains Modules, then the Case Control command (HDF5DA) allows the creation of a separate
.h5 file (for input and response output) for each Module. This command points to the corresponding Bulk Data entry
(HDF5DA). If these .h5 files exist (from a previous MSC Nastran run), then this new feature will enable the appending of
the new input/output data to the .h5 files.
Benefits
•By default, a single .h5 file is created from a model containing all MSC Nastran Modules.
•This new feature overcomes this limitation, by introducing the option of creating separate dedicated
input/output .h5 files (one for each Module). In addition, if these  .h5  files already exist, the data from a new
Nastran run can be appended to such files.
•Thus, the user can now post-process the results on any desired Module alone, for any desired (timestamp tagged)
run stored in a .h5 file
User Interface
All solution sequences which support MSC Nastran Modules (i.e., SOLs 101, 103, 105 through 112, and 400) support
this new HDF5DA Case Control command and Bulk Data entry.
This command will allow each MSC Nastran Module to receive a dedicated HDF5 output file. These HDF5 files may exist,
i.e., be from a previous MSC Nastran run. If so, then the new output will be appended.
Format:
Example:
HDF5DA = 17HDF5DA (Case) (Case) Modules Dedicated and Appended HDF5 Output Control
HDF5DA0
1–
n&lt;/h1&gt;&lt;p&gt;81  CHAPTER 4
Modules
Main Index
Remarks:
1.This is only valid when MODULEs are present. It is ignored if there&amp;rsquo;s no BEGIN (BULK) MODULE.
2.This case control command must be present for any dedicated HDF5 and must be above or in the first subcase
3.When HDF5DA = -1, the dedicated HDF5 output file for each module is named with job filename along with the
module ID (separated by an underscore), as shown:
Jobname_ModuleID.h5
4.For n &amp;gt; 0, the Bulk Data entry HDF5DA is used to identify module configuration and file names. The associated
HDF5DA Bulk Data entry must be present in the primary BEGIN BULK section (e.g., MODULE 0).
5.This command does not support the &amp;lsquo;intermediate&amp;rsquo; nonlinear solution output in HDF5 files at each solution output
interval (activated by the NLOPRM OUTCTRL=INTERM ).
6.If this command is not present or HDF5DA=0 is specified, then HDF5 output for all modules goes into a single
.h5 file, and its properties are controlled by the HDF5OUT bulk data entry.Describer Meaning
0 T o enable a single comprehensive .h5 output file (for all modules together). This is the default (same as
if the HDF5DA Case Control is not present).
-1 T o enable separate .h5 output files (one per each module). See Remark 3.
n Identification number of an HDF5DA Bulk Data entry, specifying module configuration and .h5 file
names. (Integer &amp;gt; 0)&lt;/p&gt;
&lt;p&gt;82 MSC Nastran 2024.1 Release Guide
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs
Main Index
This entry is referenced by the HDF5DA Case Control. It&amp;rsquo;s used to specify the dedicated HDF5 file name, via the
UDNAME entry, for individual BEGIN MODULE.
Format:
Example:
Remarks:
1.This entry must be present for any dedicated HDF5 module file and be referenced by HDF5DA case control.
2.Every module (primary and secondary, including MODULE 0) must have a pair of (MDID, UDID) listed in this
entry.
3.Unique UDID is not required for each UDIDi field. (i.e., Two or more module outputs can be directed to same
H5 file).
4.This entry must be in the main bulk data section. It may not occur in a BEGIN MODULE.
5.&amp;lsquo;MDLPRM, HDF5, value&amp;rsquo; and any of its variants are forbiddenHDF5DA (Bulk) List of Modules for Dedicated and Appended HDF5 Output
1 2 3 4 5 6 7 8 9 10
HDF5DA ID CONFIG
MDID0 UDID0 MDID1 UDID1 MDID2 UDID2 MDID3 UDID3
MDID4 UDID4 MDID5 UDID5 -etc.-
HDF5DA 17 1
0 100 2 200
Describer Meaning
ID ID associated with the Case Control HDF5DA command. (Integer &amp;gt; 0)
CONFIG ID of a UDNAME entry to assign a name for assembly configuration. The number of characters should
not exceed 64 on the referenced UDNAME. (Integer ≥ 0). Default=0 for no configuration name.
MDIDi MODULE ID for a dedicated HDF5 file. Residual structure is considered MODULE 0. See Remark 2.
(Integer ≥ 0)
UDIDi ID of a UDNAME entry to specify the dedicated HDF5 file name for module MDIDi. (Integer &amp;gt; 0).&lt;/p&gt;
&lt;p&gt;83  CHAPTER 4
Modules
Main Index
Provides the name of a file that can be referenced from other bulk data entries such as FTGLOAD, TABLRPC, MATDIGI
and HDF5DA.
Format:
Example:
Remarks:
1.The UDID is referenced by FTGLOAD, TABLRPC, MATDIGI or HDF5DA entries.
2.The NAME is limited to a maximum of 255 characters (corresponding to 4 lines of data in fields 2-9). For Fatigue
analysis using .rsp  (RPC) files, there is a 128-character limit (corresponding to 2 lines of data in fields 2-9).
Embedded blanks are not supported. see Remark 5. for HDF5DA use.
3.This entry must be in the main bulk data section. It may not occur in a BEGIN MODULE.
4.If the UDNAME is used for CONFIG field on HDF5DA entry, then the NAME should not exceed 64 characters.
5.For HDF5DA files, this entry can have any number of “name” lines. However, there is a machine dependent
practicality as to how characters are allowed in file names and in path names. In general, computer file names
(Windows) are limited 28-1=255 characters. Path names, including the file name (Linux) are in general restricted
to a total length of 212 -1= 4095 characters. This computes, in theory, that up to 64 lines may be entered with the
last line terminating in column 71. Thus, we have the limit dir.name ≤ 4095 characters.
6.For HDF5DA files, the NAME field cannot be left blank, and the filename must have .h5 or .H5 extension. Single
or double quotation marks are not allowed.UDNAME (Bulk) User Defined File Name
1 2 3 4 5 6 7 8 9 10
UDNAME UDID
NAME
UDNAME 100
C:/myleftwing/manuever1-10.h5
Describer Meaning
UDID Unique UDID (Integer&amp;gt;0)
NAME Name of a file (with or without path) such as the external loading time history in DAC or RPC format
or DIGIMAT material file or H5 file see Remark 5. (Character).&lt;/p&gt;
&lt;p&gt;84 MSC Nastran 2024.1 Release Guide
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs
Main Index
7.Characters % and | will cause the complete line to be deleted no matter where they occur in a line. Also, the character
$ will cause a line to be truncated at the $ and the remaining line replaced with embedded blanks including the $
location. Embedded blanks indicate a command end and should be avoided in path and file names.
8.In general, it is recommended that the characters in the following table not be used for file names:
Illegal Filename Characters&lt;/p&gt;
&lt;h1&gt;Pound &amp;lt; left angle bracket $ dollar sign + plus sign&lt;/h1&gt;&lt;p&gt;% percent &amp;gt; right angle bracket ! exclamation point ` backtick
&amp;amp; ampersand * asterisk &amp;rsquo; single quotes | pipe
{ left curly bracket ? question mark &amp;quot; double quotes = equal sign
} right curly bracket / forward slash *&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The slash is allowed in the path but not in the filename.: colon
\ back slash * blank spaces @ at sign
•Don&amp;rsquo;t start or end your filename with a space, period, hyphen, or underline.
•Keep your filenames to a reasonable length and under 31 characters is recommended.
•Some operating systems are case sensitive; always use lowercase.
•Avoid using spaces and underscores; use a hyphen instead.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;85  CHAPTER 4
Modules
Main Index
This entry allows general HDF5 parameters control.
Format:
Example:HDF5OUT HDF5 Output Parameters
1 2 3 4 5 6 7 8 9 10
HDF5OUT PARAM1 VAL1 PARAM2 VAL2 PARAM3 VAL3 PARAM4 VAL4
PARAM5 VAL5 -etc.-
HDF5OUT 3 PRCISION 64
Describer Meaning
PARAM(i) Name of a parameter. Allowable names are given in Table 4-1 (Character).
VAL(i) Value of the parameter. See Table 4-1 (Real or Integer).
Table 4-1  HDF5OUT Parameters
Name Description Type and Value
GM12 Option to write GEOM1 and GEOM2 data blocks in the .h5 file, integer, 1
(default) or 0.
1 (default) Write GEOM1 and GEOM2 data blocks into .h5
0 Do not write GEOM1 and GEOM2 data blocks into .h5
etc. For all other PARAM(i), existing in prior Nastran versions, refer to the QRG.&lt;/p&gt;
&lt;p&gt;86 MSC Nastran 2024.1 Release Guide
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs
Main Index
This entry allows HDF5 parameter control for Dedicated and Appended HDF5 files (for Modules only).
Format:
Example:
Remarks:
1.This entry is to specify HDF5 default overrides for individual MSC Nastran Modules.
2.This entry must be in the Main Bulk Data (i.e., MODULE 0).
3.This entry overrides, for individual Modules, the HDF5OUT bulk data parameter specifications.
4.If HDF5 output is desired, the HDF5OUT Bulk Data entry is required.H5OUT HDF5 Output Parameters for Dedicated and Appended HDF5
1 2 3 4 5 6 7 8 9 10
H5OUT MDID
PARAM1 VAL1 PARAM2 VAL2 -etc.- -etc.-
H5OUT 1
INPUT NO
H5OUT 80
ROTDOF NO
Describer Meaning
MDID An MSC Nastran Module ID. (Integer ≥ 0)
PARAM(i) Name of a parameter. Allowable names are given in the HDF5OUT entry, see Table 4-1. (Character)
VAL(i) Value of the parameter. See HDF5OUT entry, see Table 4-1 (Real or Integer).&lt;/p&gt;
&lt;p&gt;87  CHAPTER 4
Modules
Main Index
5.The HDF5OUT bulk data parameters PRCISION, CMPRMTHD, and LEVEL are not allowed on the H5OUT.&lt;br&gt;
Guidelines and Limitations
•&amp;lsquo;Intermediate&amp;rsquo; nonlinear solution output in HDF5 files at each solution output interval (activated by the
NLOPRM OUTCTRL=INTERM) is not supported.
Example
A given UAV assembly is made of fourteen Modules. See tpl\nh5_Module\uav_base_gm12.dat  for the first run and
tpl\nh5_Module\uav_base_app.dat  for the second (appended) run, in the documentation installation folder.&lt;/p&gt;
&lt;p&gt;88 MSC Nastran 2024.1 Release Guide
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs
Main Index
Input Deck (uav_base_gm12.dat):
SOL 101
CEND
$
HDF5DA = 1
$
SUBCASE 2001
LABEL = UPLOAD ON AILERONS
LOAD  = 2002
DISPLACEMENT = ALL
SPC = 1
BEGIN BULK
$
$&amp;mdash;&amp;mdash;-2&amp;mdash;&amp;mdash;-3&amp;mdash;&amp;mdash;-4&amp;mdash;&amp;mdash;-5&amp;mdash;&amp;mdash;-6&amp;mdash;&amp;mdash;-7&amp;mdash;&amp;mdash;-8&amp;mdash;&amp;mdash;-9&amp;mdash;&amp;mdash;-0&amp;mdash;&amp;mdash;-
HDF5DA  1       100
0       1       41      41      42      42      43      43
44      44      45      45      47      47      48      48
49      49      51      51      52      52      61      61
62      62      63      63      71      71
$&amp;mdash;&amp;mdash;-2&amp;mdash;&amp;mdash;-3&amp;mdash;&amp;mdash;-4&amp;mdash;&amp;mdash;-5&amp;mdash;&amp;mdash;-6&amp;mdash;&amp;mdash;-7&amp;mdash;&amp;mdash;-8&amp;mdash;&amp;mdash;-9&amp;mdash;&amp;mdash;-0&amp;mdash;&amp;mdash;-
UDNAME  100
AppendingRes
UDNAME  1
resstruct-0.h5
UDNAME  41
radome-41.h5
UDNAME  42
nose-42.h5
UDNAME  43
fwdfuselage-43.h5
UDNAME  44
winginters-44.h5
UDNAME  45
aftwingfuse-45.h5
UDNAME  47
aftfuselage-47.h5
UDNAME  48
tail-48.h5
UDNAME  49
taildome-49.h5
UDNAME  51
leftwing-51.h5
UDNAME  52
rightwing-52.h5
UDNAME  61
lefthorstabi-61.h5
UDNAME  62
righthorstabi-62.h5
UDNAME  63
verticalstabi-63.h5&lt;/p&gt;
&lt;p&gt;89  CHAPTER 4
Modules
Main Index
UDNAME  71
nosepod-71.h5
$&amp;mdash;&amp;mdash;-2&amp;mdash;&amp;mdash;-3&amp;mdash;&amp;mdash;-4&amp;mdash;&amp;mdash;-5&amp;mdash;&amp;mdash;-6&amp;mdash;&amp;mdash;-7&amp;mdash;&amp;mdash;-8&amp;mdash;&amp;mdash;-9&amp;mdash;&amp;mdash;-0&amp;mdash;&amp;mdash;-
HDF5OUT INPUT   YES     GM12    1
$
H5OUT   41
GM12    0
$&amp;mdash;&amp;mdash;-2&amp;mdash;&amp;mdash;-3&amp;mdash;&amp;mdash;-4&amp;mdash;&amp;mdash;-5&amp;mdash;&amp;mdash;-6&amp;mdash;&amp;mdash;-7&amp;mdash;&amp;mdash;-8&amp;mdash;&amp;mdash;-9&amp;mdash;&amp;mdash;-0&amp;mdash;&amp;mdash;-
$
MDBULK,all,,,auto
$
Begin Module=47 Label=&amp;lsquo;Aft Fuselage&amp;rsquo;
include &amp;lsquo;UAV_include\fAft_rev2_renum.bdf&amp;rsquo;
End Module
Begin Module=48 Label=&amp;lsquo;Tail&amp;rsquo;
include &amp;lsquo;UAV_include\fTail_rev2_renum.bdf&amp;rsquo;
End Module
Begin Module=49 Label=&amp;lsquo;Tail Dome&amp;rsquo;
include &amp;lsquo;UAV_include\fTailDome_rev2_renum.bdf&amp;rsquo;
End Module
Begin Module=51 Label=&amp;lsquo;Left Wing&amp;rsquo;
include &amp;lsquo;UAV_include\wLeftWing_rev1_renum_noPLOAD.bdf&amp;rsquo;
End Module
Begin Module=52 Label=&amp;lsquo;Right Wing&amp;rsquo;
include &amp;lsquo;UAV_include\wRightWing_rev4_renum_noPLOAD.bdf&amp;rsquo;
End Module
Begin Module=61 Label=&amp;lsquo;Left Hor Stabilizer&amp;rsquo;
include &amp;lsquo;UAV_include\tLeftHorizontal_rev2_renum.bdf&amp;rsquo;
End Module
Begin Module=62 Label=&amp;lsquo;Right Hor Stabilizer&amp;rsquo;
include &amp;lsquo;UAV_include\tRightHorizontal_rev2_renum.bdf&amp;rsquo;
End Module
Begin Module=63 Label=&amp;lsquo;Vertical Stabilizer&amp;rsquo;
include &amp;lsquo;UAV_include\tVerticalFin_rev2_renum.bdf&amp;rsquo;
End Module
Begin Module=71 Label=&amp;lsquo;Nose Pod&amp;rsquo;
include &amp;lsquo;UAV_include\pNosePod_rev1_renum.bdf&amp;rsquo;
End Module
$
ENDDATA&lt;/p&gt;
&lt;p&gt;90 MSC Nastran 2024.1 Release Guide
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs
Main Index
Output
The results (input and output) of each Module are separately appended to each (previously existing) .h5 file, as shown:
HDF5 Schema (for newly appended groups from new runs):
Below is a snippet of the new data structure appended to the original contents of an existing HDF5 file (which normally
would contain the INDEX and NASTRAN groups from the original Nastran run). As a result of the &amp;lsquo;modules appending&amp;rsquo;
process:
•A &amp;lsquo;collector&amp;rsquo; group (called &amp;lsquo;SUPER-ATTACHMENTS-GROUP&amp;rsquo;) is added to the root of the HDF5 file, to host
any new group (containing the input/output) from a future Nastran run involving MSC modules.
•A &amp;rsquo;time-stamped&amp;rsquo; group (associated with a new Nastran run involving MSC modules) is appended under the
&amp;lsquo;collector&amp;rsquo; group.
•This group is automatically labeled with a &amp;rsquo;timestamp&amp;rsquo; (year_month_day_hour_min_sec),
followed by an optional &amp;lsquo;analysis configuration&amp;rsquo; description (e.g., TORSION-Config, BEND-
Config, etc.) that can be specified in Field 3 of the HDF5DA entry.
•This group contains the INDEX and NASTRAN groups from the new Nastran run.resstruct-0.h5
radome-41.h5
nose-42.h5
fwdfuselage-43.h5
winginters-44.h5
aftwingfuse-45.h5
aftfuselage-47.h5
tail-48.h5taildome-49.h5
leftwing-51.h5
rightwing-52.h5
lefthorstabi-61.h5
righthorstabi-62.h5
verticalstabi-63.h5
nosepod-71.h5&lt;/p&gt;
&lt;p&gt;91  CHAPTER 4
Modules
Main Index
In order to access the newly added &amp;rsquo;time-stamped groups&amp;rsquo; (containing input/output from new Nastran runs involving MSC
modules), some examples (in Python and Matlab) are provided below:
Using h5py
import h5py
fname = &amp;ldquo;rightwing-52.h5&amp;rdquo;;
h5 = h5py.File(fname, &amp;lsquo;r&amp;rsquo;)&lt;/p&gt;
&lt;h1&gt;Original Run: Path to the main groups (INDEX &amp;amp; NASTRAN), directly under the ROOT.&lt;/h1&gt;&lt;p&gt;origINDEXgrp   = h5[&amp;rsquo;/INDEX&amp;rsquo;]
origNASTRANgrp = h5[&amp;rsquo;/NASTRAN&amp;rsquo;]&lt;/p&gt;
&lt;h1&gt;Appended Run: Path to the newly appended main groups (INDEX &amp;amp; NASTRAN), under the Collector&lt;/h1&gt;&lt;p&gt;newINDEXgrp   = h5[&amp;lsquo;SUPER-ATTACHMENTS-GROUP/2024_02_01_10_39_46-AppendingRes/INDEX&amp;rsquo;]
newNASTRANgrp = h5[&amp;lsquo;SUPER-ATTACHMENTS-GROUP/2024_02_01_10_39_46-AppendingRes/NASTRAN&amp;rsquo;]
print(&amp;ldquo;newINDEXgrp: &amp;ldquo;, newINDEXgrp)
print(&amp;ldquo;newNASTRANgrp: &amp;ldquo;, newNASTRANgrp)
h5.close()
Using PyTables
import tables as pt
fname = &amp;ldquo;rightwing-52.h5&amp;rdquo;;
h5 = pt.open_file(fname, &amp;lsquo;r&amp;rsquo;)&lt;/p&gt;
&lt;h1&gt;Original Run: Path to the main groups (INDEX &amp;amp; NASTRAN), directly under the ROOT.&lt;/h1&gt;&lt;p&gt;origINDEXgrp   = h5.get_node(h5.root, &amp;lsquo;INDEX&amp;rsquo;)
origNASTRANgrp = h5.get_node(h5.root,&amp;lsquo;NASTRAN&amp;rsquo;)&lt;/p&gt;
&lt;h1&gt;Appended Run: Path to the newly appended main groups (INDEX &amp;amp; NASTRAN), under the Collector&lt;/h1&gt;&lt;p&gt;newINDEXnode   = h5.get_node(h5.root,&amp;lsquo;SUPER-ATTACHMENTS-GROUP/2024_02_01_10_39_46-
AppendingRes/INDEX&amp;rsquo;)
newNASTRANnode = h5.get_node(h5.root,&amp;lsquo;SUPER-ATTACHMENTS-GROUP/2024_02_01_10_39_46-
AppendingRes/NASTRAN&amp;rsquo;)
print(&amp;ldquo;newINDEXnode :&amp;rdquo;, newINDEXnode)
print(&amp;ldquo;newNASTRANnode: &amp;ldquo;, newNASTRANnode)&lt;/p&gt;
&lt;p&gt;92 MSC Nastran 2024.1 Release Guide
HDF5DA - Dedicated and Appended HDF5 Files for MSC Nastran MODULEs
Main Index
Using Pandas
import pandas as pd
fname = &amp;ldquo;rightwing-52.h5&amp;rdquo;
h5s = pd.HDFStore(fname, &amp;lsquo;r&amp;rsquo;)&lt;/p&gt;
&lt;h1&gt;Appended Run: Path to the newly appended main groups (INDEX &amp;amp; NASTRAN), under the Collector&lt;/h1&gt;&lt;p&gt;newINDEXgrp   = &amp;lsquo;SUPER-ATTACHMENTS-GROUP/2024_02_01_10_39_46-AppendingRes/INDEX&amp;rsquo;
newNASTRANgrp = &amp;lsquo;SUPER-ATTACHMENTS-GROUP/2024_02_01_10_39_46-AppendingRes/NASTRAN&amp;rsquo;&lt;/p&gt;
&lt;h1&gt;Use Pandas to read each dataset (e.g. DOMAINS)&lt;/h1&gt;&lt;p&gt;subgroup     = &amp;lsquo;INPUT&amp;rsquo;
dataset      = &amp;lsquo;DOMAINS&amp;rsquo;
full_path = f&amp;rsquo;{newNASTRANgrp}/{subgroup}/{dataset}&amp;rsquo;&lt;/p&gt;
&lt;h1&gt;Read the dataset into a DataFrame&lt;/h1&gt;&lt;p&gt;dataframe = h5s[full_path]&lt;/p&gt;
&lt;h1&gt;Now &amp;lsquo;dataframe&amp;rsquo; contains the data from the DOMAINS dataset&lt;/h1&gt;&lt;p&gt;print(dataframe)
Using Matlab
fname = &amp;ldquo;rightwing-52.h5&amp;rdquo;;
info = h5info(fname);
% Appended Run: Path to the newly appended main groups (INDEX &amp;amp; NASTRAN), under the Collector
newINDEXpath = &amp;lsquo;/SUPER-ATTACHMENTS-GROUP/2024_02_01_10_39_46-AppendingRes/INDEX&amp;rsquo;;
newNASTRANpath = &amp;lsquo;/SUPER-ATTACHMENTS-GROUP/2024_02_01_10_39_46-AppendingRes/NASTRAN&amp;rsquo;;
newINDEXgrp = find(strcmp({info.Groups.Name}, newINDEXpath));
newNASTRANgrp = find(strcmp({info.Groups.Name}, newNASTRANpath));
% Read a dataset (e.g. DOMAINS)
dataset = h5read(fname, [newNASTRANpath, &amp;lsquo;/INPUT/DOMAINS&amp;rsquo;]);
disp(&amp;lsquo;DOMAINS dataset: &amp;lsquo;);
disp(dataset);&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 5: Rotordynamics Enhancements
5 Rotordynamics Enhancements
SOL 128 Postprocessing Improvements     94
ADAMS MNF Enhancement: Rotordynamics     101&lt;/p&gt;
&lt;p&gt;94 MSC Nastran 2024.1 Release Guide
SOL 128 Postprocessing Improvements
Main Index
SOL 128 Postprocessing Improvements
Introduction
SOL128, nonlinear harmonic balance analysis is used to simulate various events like Windmilling (WM) analysis, stator-
rotor rubs, squeeze film damper simulations. In prior versions, SOL 128 provided requested output only for the f ully
converged solution. There was no possible way to generate intermediate iterative solutions for a divergent solution. A new
case control entry has been created to provide displacement and nonlinear load for selected grid-dof pairs at end of each
iteration. In addition, the user can select a frequency range to get desired output  at end of the fully converged solution.
Benefits
The enhanced post processing capability provides users the key to understand divergent conditions, which can then be used
to improve the solution by tweaking various solution parameters. It also helps in studying detailed solutions at various
frequency ranges of interest.
Feature Description
The new post processing technique is supported only in SOL128 with CONTP set to 2 and DECOMP to QR on the
NHRMPRM entry.
User Interface
NHRMITR case control entry: to generate iterative displacement and nonlinear load output  in CSV file format.
Format:
Example:
set 30=200/t2,200/t3,500/t2,500/t3,500/r1
set 20=200/t2,500/t2,500/t3
NHRMITR DISP=30, NLLOAD=20
NHRMITR DISP=30
NHRMITR NLLOAD=30NHRMITRDISPnone
setdof&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
=
   ,NLLOADnone
setdof&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
=
   &lt;/p&gt;
&lt;p&gt;95 Rotordynamics Enhancements
SOL 128 Postprocessing Improvements
Main Index
Remarks:
1.The output is only available in CSV file format only.
2.DISP and NLLOAD requests each create separate CSV files.
3.The file names will be jobname_disp.csv and jobname_nlload.csv.
Update to the existing NLFREQC entry: select frequency range to create desired output for converged solutions.
Example:
NLFREQC 88      10.0    0.01    0.      0.      6000    10.     43.5
1.0E-5  YES
DFOUT   0.25    5.0     28.     36.
OR
NLFREQC 88      40.0    -0.01   0.      0.      6000    10.     40.
1.0E-5  YES
DFOUT   0.25    5.0     25.     35.Describer Meaning
DISP Requests displacement output  for selected set of GRID points and dof at the end of each
iteration
NLLOAD Requests nonlinear load output  for selected GRID points and dof at the end of each iteration
1 2 3 4 5 6 7 8 9 10
NLFREQC ID FREQINI STEPINI MINSIZE MAXSIZE MAXSTEP MINFREQ MAXFREQ
DERINC PRTOUT
&amp;ldquo;DFOUT&amp;rdquo; DFQ DFQTOL BEGFQ ENDFQ
Describer Meaning
ID Identification number referenced by the NLFREQ field (field 5) of an NLHARM Bulk Data entry.
(Integer &amp;gt; 0).
FREQINI Initial/start frequency f0 for CONTP = 2 (a previous stable frequency solution). (REAL ≥ 0.0)
STEPINI Initial/start step length for CONTP = 2 (Solutions at f0 and f0+STEPINI must be stable to find
converged responses first. STEPINIT can be either a positive or negative value). (REAL  0.0).
MINSIZE Magnitude of the minimum step size for iteration. (REAL ≥ 0.0, default = 1.0E-5  ABS(STEPINIT) )
MAXSIZE Magnitude of the maximum step size for iteration. (REAL ≥ 0.0, default = 100.0  ABS(STEPINIT) )&lt;/p&gt;
&lt;p&gt;96 MSC Nastran 2024.1 Release Guide
SOL 128 Postprocessing Improvements
Main Index
Remarks:
1.This entry is supported only for SOL128.
2.Only one NLFREQC entry with the same ID is allowed.
3.When using CONTP = 2 on the NHRMPRM entry, an NLFREQC entry is required, if not defined, a UFM will
be issued.
4.Use of the DFOUT option will provide output selected by the case control commands for the selected frequency
range from BEGFQ to ENDFQ.
5.Only the output for converged solutions in the requested range will be available.
Example 1:
SOL 128
$
CEND
…
SUBCASE 1001
disp(phase,sort2,phase)=1001
nlload(phase,sort2,phase)=1001MAXSTEP Maximum number of steps allowed when using continuation procedure CONTP=2
MINFREQ Minimum frequency to terminate the continuation procedure CONTP = 2. (REAL ≥ 0.0, default =
0.0)
MAXFREQ Maximum frequency to terminate the continuation procedure CONTP = 2. (REAL ≥ 0.0, default =
FREQINI + ABS(STEPINIT)  MAXSTEP)
DERINC Central difference in computing derivative of linear/nonlinear load
PRTOUT Print output request in case convergence fails: “NO” (default) or “YES”
DFOUT Flag indicating that the next 4 fields are for user specific output request (Character, Optional)
DFQ Frequency step interval for output. The solution frequency BEGFQ + N DFQ  DFQTOL (where N
is an integer &amp;gt;= 0) and BEGFQ + N DFQ is less than or equal to ENDFQ will be saved for output.
(REAL, Required)
DFQTOL Tolerance in terms of % to identify closest frequency step for post-processing. This is given in terms of
percent of DFQ. (REAL, Default = 5.0%)
BEGFQ Initial/start frequency for output request. (REAL, Default = &amp;lsquo;FREQINI&amp;rsquo; value in NLFREQC card)
ENDFQ Maximum frequency for output request. (REAL, Default = &amp;lsquo;MAXFREQ&amp;rsquo; value in NLFREQC card)Describer Meaning&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P6</title>
      <link>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_006/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_006/</guid>
      <description>
        
        
        &lt;p&gt;97 Rotordynamics Enhancements
SOL 128 Postprocessing Improvements
Main Index
DLOAD=201
RGYRO=301
METHOD=1001
RESVEC=NO
nonlinear = 1000
NLHARM=2000
set 30=200/t2,200/t3,200/r1,200/r2,500/t2,500/t3,500/r1
set 20=200/t2,200/t3,500/t2,500/t3
nhrmitr DISP=30, NLLOAD=20
$
BEGIN BULK
NLHARM,2000,1,1,88
NHRMPRM,MNCSF,2,NLHDIAG,1,CONTP,2,NLHRED,0,MXICODE0,1000,DECOMP,QR
$&amp;ndash;01&amp;ndash;$$&amp;ndash;02&amp;ndash;$$&amp;ndash;03&amp;ndash;$$&amp;ndash;04&amp;ndash;$$&amp;ndash;05&amp;ndash;$$&amp;ndash;06&amp;ndash;$$&amp;ndash;07&amp;ndash;$$&amp;ndash;08&amp;ndash;$$&amp;ndash;09&amp;ndash;$
NHRMPRM NLHRED  0       NHPLUS  20      NLHTOL  1.0e-5  NLHTWK 1.1
MXICODE0 500    TICPNCH 0       MNCSF   1000    MFRINT  1.0
NLHDIAG 1       CONTP   2       DECOMP  QR
NLFREQC 88      10.0    0.01    0.      0.      6000    10.     43.5
1.0E-5  YES
DFOUT   0.25    5.0     28.     36.
$
…
ENDDATA
Guidelines and Limitation
•Use of DFOUT on the NLFREQC is allowed only when CONTP is set to 2. A User Fatal Message will be
issued when using with CONTP = 0 or 1.
•Request of NHRMITR (iteration outputs) will result in slower run time as the .csv files are opened to write
the data and closed after each converged solution. This means that if the run fails, the .csv files will be
available up to the last converged solution.&lt;/p&gt;
&lt;p&gt;98 MSC Nastran 2024.1 Release Guide
SOL 128 Postprocessing Improvements
Main Index
Examples
SOL128 with NHRMITR request and DFOUT request are available in TPL directory ( ..\tpl\ rotor128\ )
Below are the results for the decks in TPL.
sol128_dfout_a.datSr. Example file name Setup description
1 sol128_dfout_a.dat NLFREQC with DFOUT request for UNBALNC forward scan
2 sol128_dfout_d.dat NLFREQC with DFOUT request for UNBALNC forward scan
3 nhrmitr_same_id.dat NHRMITR iterative output request with different set ids
4 nhrmitr_unit.dat NHRMITR iterative output request with same set ids&lt;/p&gt;
&lt;p&gt;99 Rotordynamics Enhancements
SOL 128 Postprocessing Improvements
Main Index
sol128_dfout_d.dat
nhrmitr_same_id.dat
set 30=200/t2,200/t3,200/r1,200/r2,500/t2,500/t3,500/r1
nhrmitr DISP=30, NLLOAD=30&lt;/p&gt;
&lt;p&gt;100 MSC Nastran 2024.1 Release Guide
SOL 128 Postprocessing Improvements
Main Index
Output: nhrmitr_same_id_disp.csv
Output: nhrmitr_same_id_nlload.csv&lt;/p&gt;
&lt;p&gt;101 Rotordynamics Enhancements
ADAMS MNF Enhancement: Rotordynamics
Main Index
ADAMS MNF Enhancement: Rotordynamics
Introduction
Many finite element models have significant damping, which means that using the solution to the real eigenvalue problem
to convert them into an MNF file may require a large number of modes in order to accurately represent the damping.
Rotordynamics is a particular case where the damping and stiffness matrices vary with rotor speed and can have a significant
impact on the solution.
This version of MSC Nastran implements the abilities to use complex modes in SOL 107 and transform them into pseudo
real modes to create an MNF file for Adams. The rotor dynamic effects would be included in the MNF to allow Adams to
completely capture rotor dynamic effects if the flexible body is undergoing high rotational speeds.
Benefits
The functionality is of benefit while generating MNFs for flexible body components that will exhibit rotor dynamic effects
and/or significant damping in Adams.
User Interface
The user interface is the same as that used in SOL 103 MNF generation. Essentially, the Case Control command
ADAMSMNF is now supported in SOL 107. If required, the rotordynamics capability is activated through the use of the
RGYRO case control and appropriate bulk data entries similar to traditional complex modes solution with a rotor.
When MNF creation is requested in SOL 107, the program will proceed normally through the complex eigenvalue
solution, with the exception that residual structure CMS is not allowed. The complex eigenvalue solution will be performed
on the O-set matrices and these complex modes will be used in the creation of the MNF file.
Representative sample Nastran Input file for using ADAMSMNF with SOL 107:
$ TRUNCATED REPRESENTATIVE INPUT FILE
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$ SOL 107 MNF Generation Capability $
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&lt;br&gt;
$ Exec. Control Section
SOL 107
CEND
$ Case Control Section
TITLE = Sample Nastran Input File for SOL 107 MNF Capability
$ Sample MNF creation command
ADAMSMNF FLEXBODY=YES OUTGSTRS=YES OUTGSTRN=YES&lt;br&gt;
&amp;hellip;
$ Activate Rotordynamics capability
RGYRO = 1&lt;br&gt;
&amp;hellip;&lt;/p&gt;
&lt;p&gt;102 MSC Nastran 2024.1 Release Guide
ADAMS MNF Enhancement: Rotordynamics
Main Index
$ Select Complex Eigenvalue Extraction Method
CMETHOD = 20&lt;br&gt;
&amp;hellip;
RESVEC = YES
AUTOSPC = YES
BEGIN BULK
$
$ Bulk data section
&amp;hellip;
$ Define data needed to perform Complex Eigenvalue Analysis
EIGC, 20, CLAN, MAX, , , , 50&lt;br&gt;
$ ADAMS REQUIRES DTI, UNITS
DTI, UNITS, 1, LBM, LBF, IN, SEC&lt;br&gt;
$
$ If Required, turn on gridpoint weight generator
PARAM, GRDPNT, 0
$ If Required, use WTMASS, Default value = 1.0
PARAM, WTMASS, 0.00259
&amp;hellip;
$ Rotordynamic analysis parameter and Rotor data
RGYRO,1,SYNC,11,RPM,,,1000.0
ROTOR,11,FIX&lt;br&gt;
,PROP,102,103
,AXIS,50001,60002
RSPINR,11,50001,60002,RPM,1.&lt;br&gt;
,0.02,1.0e-4,1.0e-4,10000.,15000.,12000.
RGYRO,1,SYNC,11,RPM,,,1000.0&lt;br&gt;
$ Interface GRID point selection
ASET1,123456,1091,1111&lt;br&gt;
&amp;hellip;
GRID &amp;hellip;
CHEXA &amp;hellip;
CBUSH &amp;hellip;
PBUSH &amp;hellip;
CDAMP2 &amp;hellip;
&amp;hellip;
ENDDATA
Guidelines
1.An A-set must be defined via the ASET/ASET1 entries in the bulk data section, but no Q-set should be defined (it
is automatically created).&lt;/p&gt;
&lt;p&gt;103 Rotordynamics Enhancements
ADAMS MNF Enhancement: Rotordynamics
Main Index
2.Complex eigenvalue extraction method (CMETHOD case control) with the associated bulk data entry (EIGC)
should be specified to control the number of modes used in creating the MNF.
3.If required, the rotordynamics capability should be activated through the use of the RGYRO case control and
appropriate bulk data entries similar to traditional complex modes solution with a rotor.
4.If you are generating an MNF for rotordynamics, it is recommended that you have a separate MNF for each rotor.
If more than one rotor is in an MNF, they may not be handled properly in Adams.
5.The MNF creation in SOL 107 will only work for rotors using the fixed reference frame.
6.Additionally axisymmetric elements are not supported for this capability.
7.Residual structure component mode synthesis is disabled if MNF creation is requested in SOL 107.
8.If frequencies after MNF orthonormalization are higher than V2ORTHO option of ADAMSMNF casecontrol
(Default = 1.0E08) then the resulting MNF may be incorrect. This issue can be avoided by increasing the
V2ORTHO to be higher than the highest frequency calculated during the MNF orthonormalization process.
9.In Rotordynamics, sometimes there are spurious complex modes found. In order to remove these, there is a new
option. It is controlled by Parameters:
a.PARAM,RMSPMDS - character, default = NO. If this parameter is set to YES, then the program will remove
spurious modes based on user input.
b.PARAM, FREQTOL = real, default = 1.E-8 = tolerance on natural frequency. Any  modes with a natural
frequency less than this value will be considered potential spurious modes.
c.PARAM, DAMPTOL = real, default = 1.E+8 = tolerance on damping (modes with damping greater than
DAMPTOL and natural frequency less than FREQTOL will be considered to be spurious modes and will be
removed)
d.PARAM, REMZERO = character, default=&amp;lsquo;NO&amp;rsquo; - if set to YES, then remove modes with 0.0 natural frequency
but non-zero real part of the eigenvalue
Example
In this section we present an example of how MSC Nastran Rotordynamics can be used to represent a flexible body in
Adams that can capture local effects of high speed rotations.
Figure 5-1 is an Adams rigid body model of a business jet with articulating controls surfaces. Figure 5-2 shows each rigid body
jet engine in red is modeled as flexible body using an MNF generated from SOL 107 that includes rotor dynamic effects.
The same MNF is used to represent each flexible jet engine rotor in the aircraft. Figure 5-3 show the business jet goes through
several handing maneuvers from takeoff to landing with the jet engine rotors undergoing varying angular velocities.
Figure 5-4 shows a Campbell diagram of Mode 56 of the rotor with and without rotor dynamic effects in Adams. Several
examples using the Adams MNF Rotordynamics capability are provided in MSC Nastran Documentation Installation
directory: tpl\adamsmnf3&lt;/p&gt;
&lt;p&gt;104 MSC Nastran 2024.1 Release Guide
ADAMS MNF Enhancement: Rotordynamics
Main Index
Figure 5-1  Adams Business Jet model with Ai lerons and Two Jet Engines
Figure 5-2  (a) Rigid Body Re presentation of Jet Engine               (b) Flexible Body Representation of Jet Engine&lt;/p&gt;
&lt;p&gt;105 Rotordynamics Enhancements
ADAMS MNF Enhancement: Rotordynamics
Main Index
Figure 5-3  (a) Full Aircraft on Takeoff                          (b) Top View of Jet Engines with Flexible Rotors
Figure 5-4  Campbell Diagram Comparison with and without Adams Rotor Dynamics&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 6: Design Optimization
MSC Nastran Implicit Nonlinear (SOL 600) User’s Guide MSC Nastran Release
Guide
6 Design Optimization
Symmetry Constraints on Topometry optimization     107
Optimization Enhancements     113&lt;/p&gt;
&lt;p&gt;107  CHAPTER 6
Design Optimization
Main Index
Symmetry Constraints on Topometry optimization
Introduction
Topometry optimization (element-by-element design) was introduced into SOL 200 of MSC Nastran in the 2008 release
and has been continually enhanced in the subsequent releases. For the 2024.1 release, one enhancement is introduced to
provide: symmetry constraints on topometry optimization.
Benefits
Topometry optimization is a tool that is meant to suggest design proposals, however, topometry optimization often results
in an unsymmetric design that increases manufacturing complexity and cost. The symmetry constraint is used to create
optimized shapes with nearly symmetric results even the loading and/or boundary conditions are not symmetric.
User Interface
The existing TOMVAR entry is extended to support symmetry constraints:
Format:
New Field Contents:1 2 3 4 5 6 7 8 9 10
TOMVAR ID TYPE PID PNAME/FID XINIT XLB XUB DELXV
“DLINK” TID C0 C1
“DDVAL” DSVID
“STRESS” STLIM
“SYM” CID MS1 MS2 MS3 CS NCS SYMPID1
SYMPID2 -etc.- -etc.- SYMPIDn
Describer Meaning
&amp;ldquo;SYM&amp;rdquo; Indicates these lines defines symmetry constraints See Remark 1.
CID Rectangular coordinate system ID used for specifying symmetry constraints. See Remark 2.
(Integer ≥ 0; Default=0)
MSi Mirror symmetry plane. See Remark 3. (Character, &amp;lsquo;XY&amp;rsquo;, &amp;lsquo;YZ&amp;rsquo;, or &amp;lsquo;ZX&amp;rsquo;)
CS Cyclic symmetry axis. (character X, Y, Z). See Remark 4
NCS Number of cyclic symmetric segments in 360 degrees (Integer &amp;gt; 0). See Remark 4.
SYMPIDn Additional property IDs that are symmetric to PID (Integer&amp;gt;0)&lt;/p&gt;
&lt;p&gt;108 MSC Nastran 2021.2 Release Guide
Symmetry Constraints on Topometry optimization
Main Index
Remarks:
1.“SYM” (symmetry constraints) can only be used for PTYPE=PSHELL/PSOLID
2.Only CORD1R and CORD2R can be used as a referenced coordinate system to specify symmetry constraints. Only
one reference coordinate system CID is allowed for each TOMVAR entry. The default is the basic coordinate
system.
3.One, two or three different mirror symmetry planes ca n be present (such as MS1=XY, MS2=YZ, and MS3=ZX).
4.The first cyclic symmetry segment starts at the X-axis when CS = Z (at Z-axis when CS = Y, and at the Y-axis when
CS = X). This feature can also be used for &amp;lt; 360 degrees but NCS must be given in 360 degrees.
Test Cases
The delivery contains a number of simple test cases in subdirectory ..\tpl\optim241 . The following table contains brief
information on a number of these tests:
Mirror Symmetry Constraint Example topm_cs2.dat
Representative results for example topm_cs2.dat are shown in Figure 6-1 through Figure 6-2(b). Figure 6-1 shows the initial
design for the example that has symmetric boundary conditions but unsymmetric loads. The objective is to minimize
structural compliance (i.e., total strain energy) with 60% mass reduction. The shell thickness design variable has initial
value 0.003, lower bound and upper bound are 0.001 and 0.004 respectively. All designed element thickness referencing
PSHELL PID= 1 must be symmetric about YZ plane.Deck Name Salient Features
tomsym1.dat A simple plate model with 4800 CQUAD4 elements. Task is to minimize compliance with
50% mass reduction constraint. A mirror symmetry constraint is applied on a single property
ID
topm_cs3.dat A simple solid element example with a cyclic symmetry constraint on a designed property.
tomsym31.dat A mirror symmetry constraint is applied on two property IDs
topm_cs2.dat A shell element application example. Task is to minimize compliance with a 60% mass
reduction constraint. A mirror symmetry constraint is applied on a single property ID&lt;/p&gt;
&lt;p&gt;109  CHAPTER 6
Design Optimization
Main Index
Figure 6-1  Loads and Boundary Conditions for Example topm_cs2.dat
The input data for this example related to topometry optimization model is given in Listing 1. The coordinate system
CORD2R = 1 is created to be used to specify mirror symmetric constraints.
Listing 1&lt;/p&gt;
&lt;p&gt;110 MSC Nastran 2021.2 Release Guide
Symmetry Constraints on Topometry optimization
Main Index
Figure 6-2  Shell Element Thickness Distribution for topm_cs2.dat
Figure 6-2(a) shows the optimal design result (shell element thickness distribution) when there is no symmetry constraint
applied. Clearly, the optimal design is unsymmetric. Figure 6-2(b) shows the optimal design result when there is a symmetry
constraint applied on the designed PSHELL. Obviously, the optimal design is symmetric about YZ plane in coordinate
system CORD2R = 1 although the loading is unsymmetric.
Cyclic Symmetry Constraint Example topm_cs3.dat
Another example topm_cs3.dat demonstrates a c yclic symmetry constraint shown in Figure 6-3 and Figure 6-4. The finite
element model is show in Figure 6-3. Topometry design variables are element Young&amp;rsquo;s Modulus of PSOLID ID = 2. The
initial value is 210000, lower bound and upper bound are 100000 and 300000 respectively. A cyclic symmetry constraint
is applied on designed elements.
(b): With Symmetry Constraint (a) Without Symmetry Constraint&lt;/p&gt;
&lt;p&gt;111  CHAPTER 6
Design Optimization
Main Index
Figure 6-3  topm_cs3.dat FEM Model
The input data for the example related to topometry optimization model is given in Listing 2. The reference coordinate
system CID = Blank (basic coordinate system) is used to specify cyclical symmetric constraints. The field CS on the SYM
line is Z-axis with NCS (Number of Cyclic Symmetric Segments) =4
Listing 2&lt;/p&gt;
&lt;p&gt;112 MSC Nastran 2021.2 Release Guide
Symmetry Constraints on Topometry optimization
Main Index
Figure 6-4  topm_cs3.dat Element Young&amp;rsquo;s Modulus Distributions
Figure 6-4 shows the optimal element Young&amp;rsquo;s Modulus distributions, the optimal design is cyclic symmetric with four
segments.
Guidelines and Limitations
The symmetry constraint can only be used for PTYPE=PSHELL and PSOLID for topometry optimization, in particularly
for shell thickness. The geometry and mesh for designed property should be reasonably symmetric.
As in any topometry optimization exercise, results have to be displayed via a postprocessor to assess their usefulness. As
described in the MSC Nastran User&amp;rsquo;s Guide for Design Sensitivity and Optimization, this can be done in MSC Patran
through the use of the Design Study, Post Process ing option under the Patran T ools menu.&lt;/p&gt;
&lt;p&gt;113  CHAPTER 6
Design Optimization
Main Index
Optimization Enhancements
Two changes have been made in the user interface for SOL 200 involving changes in parameters input on the DOPTPRM
bulk data entry.
Parameter P3 has been added to deal with initial, intermediate and final output of design variables and properties
associated with topology, topometry and topography optimization.&lt;br&gt;
Topology, topometry and topography optimization typically involve many (thousands to millions) of design variables and
associated designed properties. Outputting these items can take up hundreds of pages in the .f06 file. The user typically
does not want to see this output. On the other hand, for small problems and when more visibility is needed into the design
task, output of these terms can be useful. In previous releases this was enabled by special values of the P2 parameter that
dictated what cycle output was desired. This P2 quantity became overloaded with unpredictable results. P2 was also used
to output the design variable history at the end of a design task. In addition, a additional topology/topography/topometry
output occurred in the preprocessing stage of the design task. A new parameter P3 has been provided that toggles all of this
output:
1.The initial comparison between analysis and design properties
2.The output of current design variables and properties at each design cycle.
3.The output of design variable history at the end of the design task.
The P3 parameter has two options:
P3=0 (default) - Do not print topology/topography/topometry information related to design variables and
properties.
P3=1 - Print these quantities.
A special case has been added to the DPMIN parameter.
The DPMIN parameter is used to set limits on the amount a property can change in the approximate optimization task.&lt;br&gt;
If the user does not want a limit on property movement, they can set DPMIN to a very large number, expecting any value
it takes on will be valid. Property constraints have been retained in these cases and the evaluation and check of these
properties (particularly DVxREL2 properties) can consume a measurable part of the approximate optimization process.&lt;br&gt;
The user can now set DPMIN=1.0E20 and the property constraints will be ignored. There are two cases where this comes
into play:
1.For DVxREL1 quantities that are a function of more than one DESVAR
2.For any DVxREL2 q uantity.
It is expected that ignoring these property constraints will result in a small improvement in performance, so that
DPMIN=1.0E20 should be used only when there is no concern that the designed property could take on a meaningless
value. Any constraints explicitly defined on a DVxRELy e ntry will be honored.&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 7: Numerical Methods and High Performance Computing
MSC Nastran Release Guide
7Numerical Methods and High
Performance Computing
Real Coupled Modes - Support External SE and Residual Vectors Computation for
METHOD(SYMCOUP)     115
Linear Statics Performance Improvement     120
Automatic Multilevel Static Reduction (AMSR) for External Superelements and External
Modules     123
Mumps Out-of-core Support and Mumps DMP in Lanczos     127&lt;/p&gt;
&lt;p&gt;115  CHAPTER 7
Numerical Methods and High Performance Computing
Main Index
Real Coupled Modes - Support External SE and Residual
Vectors Computation for METHOD(SYMCOUP)
Introduction
Since the real coupled modes feature was introduced in MSC Nastran in 2019, it has been used in various industries like
aerospace rocket engine or automotive powertrain. In order to compute real coupled modes, a subspace iteration method
was first implemented and improved with the acceleration method. However, to solve large problems with singular modes,
there was still a performance issue. T o resolve the issue, we have introduced the Lanczos method in 2023.4, which uses the
augmented symmetric matrix form for the unsymmetric structure-fluid coupled system matrices.  With MUMPS
decomposition support for Lanczos method, SOL 103 jobs show a significant performance improvement.
In this release, we introduce the new residual vector computation for the coupled modes unsymmetric system, which
supports modal dynamic analysis solution using the r eal coupled modes. Also, we support the Lanczos method for the
external superelement generation run for the coupled system so that we can improve the Craig-Bampton real coupled modes
computation time.
Advantages of the New Features
In Nastran 2024.1, external superelement generation for the real coupled modes of the fluid-structure can be computed
using Lanczos by specifying METHOD(SYMCOUP) in the case control. With MUMPS support for Lanczos method, the
new real coupled modes computation greatly improves the performance of the program for large problems. Also, a new
residual vector computation is implemented avoiding the subspace iteration method for unsymmetric structure-fluid
coupled system and improves the accuracy of the modal dynamic analysis results in SOL 111/ SOL 112 .
User Interface
To use the new method for external superelement generation, a Case Control request METHOD(SYMCOUP) is required
to run the new Lanczos real coupled modes computation. Its corresponding EIGR/EIGRL bulk card can be used along with
F1/F2 and ND fields.  For better computational performance, enable MUMPS support for Lanczos method by specifying
SPARSESOLVER READ(FACTMETH=MUMPS).
Limitations
In general, we recommend the use of METHOD(SYMCOUP) for models with more than 1M DOF .
•As the previous version, the default CMS reduction method with real coupled modes for the external superelement is
Craig-Bampton. The boundary points of the external superelement are held fixed during the computation of the
eigenvalues. If it is desired to have one or more of the boundary points free during the CMS reduction, these points
should be placed on an ACCSSPT (Access Points) entry rather than placing them on CSETi or BNDFREi entries.
Note that sufficient boundary degrees of freedom must be defined in the B set to prevent rigid body motion of the
fluid-structure component.
Test Case
Several examples using the new coupled modes computation method are available in the …\tpl\coupmods\  and
…\tpl\se_coupm\  folder. A brief description of these test cases follows:&lt;/p&gt;
&lt;p&gt;116 MSC Nastran 2024.1 Release Guide
Real Coupled Modes - Support External SE and Residual Vectors Computation for METHOD(SYMCOUP)
Main Index
Job Name SOL Feature Demonstrated Description
acoweak1coupl SOL 111 Lanczos with
METHOD(SYMCOUP)
both interior/external fluid exist
2 constant pressure modes exist
acoweak2coupl SOL 111 Lanczos with
METHOD(SYMCOUP)
both interior/external fluid exist
2 constant pressure modes exist
coup11106 SOL 111 Lanczos with
METHOD(SYMCOUP)One cavity box; 1 constant pressure mode&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P7</title>
      <link>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_007/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_007/</guid>
      <description>
        
        
        &lt;p&gt;117  CHAPTER 7
Numerical Methods and High Performance Computing
Main Index
coup11107 SOL 111 Lanczos with
METHOD(SYMCOUP)One cavity box; 1 constant pressure mode
coup11108 SOL 111 Lanczos with
METHOD(SYMCOUP)One cavity box; 1 constant pressure mode
oiltank111lanr SOL 111 Lanczos with
METHOD(SYMCOUP)
Oil tank model (200K DOFs)Job Name SOL Feature Demonstrated Description&lt;/p&gt;
&lt;p&gt;118 MSC Nastran 2024.1 Release Guide
Real Coupled Modes - Support External SE and Residual Vectors Computation for METHOD(SYMCOUP)
Main Index
New residual vector computation result s on structure/fluid point:
The following shows the frequency response results on a structural and fluid GRID point using a customer&amp;rsquo;s coupled system
model with (73K DOF G-size).&lt;/p&gt;
&lt;p&gt;119  CHAPTER 7
Numerical Methods and High Performance Computing
Main Index
Performance comparison between METHOD(COUPLED) and METHOD(SYMCOUP) for the oil tank model in SOL
103 (F1=10.0 &amp;amp; F2=300.0) Craig Bampton external superelement generation run is shown below.Job Name SOL Feature Demonstrated Description
red_coup1dn SOL 103 External superelement generation run with Lanczos
method using METHOD(SYMCOUP)Cabin example
Compared with red_coup1d :
METHOD(COUPLED)
assm_coup1dn SOL 111 Assembly run with red_coup1dn op2 file
red_coup2dn SOL 103 External superelement generation run with Lanczos
method using METHOD(SYMCOUP)Cabin example
Compared with red_coup2d :
METHOD(COUPLED)
assm_coup2dn SOL 111 Assembly run with red_coup2dn op2 file
coupse2n SOL 103 External superelement generation run with Lanczos
method using METHOD(SYMCOUP)Compared with coupse2 :
METHOD(COUPLED)
coupse22n SOL 111 Assembly run with coupse2n op2 file&lt;/p&gt;
&lt;p&gt;120 MSC Nastran 2024.1 Release Guide
Linear Statics Performance Improvement
Main Index
Linear Statics Performance Improvement
Introduction
Linear static analysis (SOL 101) provides powerful analysis capabilities for a wide range of modeling and analysis
requirements. As software and hardware capabilities continue to improve, model size and complexity increase accordingly.
The MUMPS linear equation solver provides fast and robust solutions in static analysis, reducing the time required for the
numerical solution. As numerical solution time decreases, other compute tasks emerge as targets for efficiency
improvement. T wo such areas are addressed in this version of Nastran: MAX-MIN calculation, and solution quality
measurement.
Benefits
Large models, especially those with large numbers of load cases, will run faster in linear static analysis SOL 101. This will
naturally lead to increased user productivity.
Technical Discussion
T wo key developments which lead to performance improvement are in this version of Nastran:
1.Performance of MAX-MIN calculations for PARAM,PRTMAXIM,YES
2.Performance of “epsilon” calculations to measure the quality of the numerical solution.
MAX-MIN calculation for PARAM,PRTMAXIM,YES
When PARAM,PRTMAXIM,YES  is specified in the bulk data section of the input file, MSC Nastran calculates maximum
and minimum values for output quantities that are requested in Case Control. These quantities include applied loads,
single-point forces of constraint, multipoint forces of constraint, and displacements. Values are calculated for each load case
and printed in the F06 file.
These calculations are carried out by the VECPLOT module (option 5). These calculations have been optimized for
rectangular coordinate systems, as well as the case where there are no user-specified coordinate systems in the model.
Solution “epsilon” calculation
MSC Nastran computes EPSILON and EXTERNAL WORK values to check numerical solution quality. These are based
on a residual calculation and are carried out in the SSG3 module (Static Solution Generator, Phase 3). Performance of the
EPSILON calculation is improved for this version of MSC Nastran.
For details on these operations, please see the SSG3 module description in the MSC Nastran DMAP Programmer&amp;rsquo;s Guide .&lt;/p&gt;
&lt;p&gt;121  CHAPTER 7
Numerical Methods and High Performance Computing
Main Index
User Interface
There are no required user actions. Performance is improved simply by running the new version of MSC Nastran.
Guidelines and Limitations
Performance improvements for MAX-MIN calculations are limited to typical use cases in linear static analysis. MAX-MIN
calculations for complex data, or for non-rectangular coordinate systems, are not affected.
Both of these improvements are evident primarily when the number of load cases is large.
Example
An example of these performance improvements is shown below.
Model and analysis details:
•Number of grid points: 9.1 million
•Number of global DOF: 56 million
•Number of 2-d elements: 8.1 million
•Number of fastener elements: 42 thousand
•Number of rigid elements: 16 thousand
•Number of load cases: 245
Command line memory specification: mem=max memorymax=500gb smp=32  (32 threads used)
Machine characteristics:
Architecture: linux64i8
Platform: Intel Linux 4.18.0-477.15.1.el8_8.x86_64
Model: Intel(R) Xeon(R) Gold 6226R CPU @ 2.90GHz
CPU: GenuineIntel
Clock frequency: 2900 MHz
Number of CPUs: 32
Physical memory: 1546774 MB&lt;/p&gt;
&lt;p&gt;122 MSC Nastran 2024.1 Release Guide
Linear Statics Performance Improvement
Main Index
The speedup for VECPLOT (MAX-MIN calculation) is 1233 to 144 seconds (8.5x). The epsilon calculation in the SSG3
module improved from 966 to 331 seconds (2.9x). The total analysis time improved from 4899 to 3199 seconds, an
improvement of 34.4%.&lt;/p&gt;
&lt;p&gt;123  CHAPTER 7
Numerical Methods and High Performance Computing
Main Index
Automatic Multilevel Static Reduction (AMSR) for External
Superelements and External Modules
Introduction
External Superelement technology is an important tool for a variety of uses. Advantages include reduced solution times for
large systems, fast turnaround time for design iterations, and the ability to keep secure data private. External Modules offer
similar advantages.
External Superelement “Creation Run” jobs are used to reduce desired analysis quantities (e.g. stiffness, mass, and loads) to
model boundary definitions. The Creation Run (also known as a “Reduction Run”) is typically the most time-consuming
portion of the entire analysis. Much of the Creation Run time is spent computing the static reduction global transformation
matrix. For Creation Runs in SOL 103 and 111, the ACMS method can be used to compute this transformation matrix
very efficiently. However, for static analysis this transformation matrix is computed using a conventional solution of
equations. This can be very time consuming, especially if there is a large number of boundary (A-set) points.
This version of Nastran introduces the Automatic Multilevel Static Reduction method, which is designed to compute the
global transformation matrix in a very efficient manner, resulting in significant performance improvements.
Benefits
Analysis using External Superelements or External Modules in SOL 101 will run faster.  The same benefit is present in SOL
200 and SOL 400 for ANALYSIS=STATICS.
Technical Discussion
In static analysis, the global transformation matrix is computed by solving the following system of equations:
where,
K = Stiffness matrix
O = Interior DOF (O-set)
A = Exterior (boundary) DOF (A-set)
G = Global boundary transformation matrix
This calculation is performed in two steps: A factorization of , and a solve step using the lower factor matrix via forward-
backward substitution (FBS). When A is large, the FBS operation can be very time consuming.KooGao Kao=
Koo&lt;/p&gt;
&lt;p&gt;124 MSC Nastran 2024.1 Release Guide
Automatic Multilevel Static Reduction (AMSR) for External Superelements and External Modules
Main Index
The new Automatic Multilevel Static Reduction (AMSR) capability computes the  matrix, and the required reduced
quantities (for example stiffness, mass, or loads) efficiently. The AMSR method employs a domain decomposition to
automatically generate sub-components of [Koo], and then performs a multi-level static condensation. This numerical
procedure is exact; no approximation is introduced.
User Interface
You must select the Automatic Multilevel Static Reduction method by specifying a DOMAINSOLVER entry in the
Executive Section of your input data. The format specification is:
DOMAINSOLVER STATRED ( REDOPT = {DIRECT|AMSR} )
STATRED is a new DOMAINSOLVER method. The REDOPT keyword is used to select the desired Reduction Option.&lt;br&gt;
The choices for REDOPT are DIRECT or AMSR. The default Reduction Option is DIRECT, which uses a linear solution
of equations to solve for . T o use the new AMSR method, specify:
DOMAINSOLVER STATRED ( REDOPT = AMSR )
Guidelines and Limitations
The Automatic Multilevel Static Reduction (AMSR) method is not supported if any of the following are present in the
model:
•Enforced motion
•SPCF output request
•Monitor points
For modal solutions, use of DOMAINSOLVER ACMS to compute component modes and related quantities is
recommended. If ACMS is not used, The AMSR method is not supported: User Warning Message 11711 is issued, and
the standard Direct method is used.
The AMSR method is highly threaded. Use of SMP is recommended for optimal performance.
Example
An example of improved performance using the AMSR method is presented below.
Model and analysis details:
•Number of grid points:  2.1 million
•Number of global DOF:  12 million
•Number of 3-d elements:  1.2 millionGao
Gao&lt;/p&gt;
&lt;p&gt;125  CHAPTER 7
Numerical Methods and High Performance Computing
Main Index
•A-set size:  36,000
Command line memory specification: mem=max memorymax=500gb
Machine characteristics:
Architecture: linux64i8
Platform: AMD Linux 4.18.0-477.15.1.el8_8.x86_64
Model: 2445.529053 MHz
CPU: AuthenticAMD
Clock frequency: 2446 MHz
Number of CPUs: 128
Physical memory: 1031654 MB
Figure 7-1  Chart key: SMP=1, 2, 4, 8, 16, 32
Below is more information on the execution details for the smp=8 case:&lt;/p&gt;
&lt;p&gt;126 MSC Nastran 2024.1 Release Guide
Automatic Multilevel Static Reduction (AMSR) for External Superelements and External Modules
Main Index
Old file Disk Highwater: 1735.403 GB
Old File Total I/O:      3414.941 GB (104.64 MB/Elapsed second)
New file Disk Highwater: 123.008 GB
New File Total I/O:      139.695 GB (67.10 MB/Elapsed second)
Module           2023.4         2024.1       Diff    Ratio  Comment&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;FBS               31756                                     Not in 2024.1
MPYAD               795              3        792   265.00  FASTER
DCMP                368                                     Not in 2024.1
SDR2                154            151          3     1.02
OUTPUT4             117            174        -57     0.67  SLOWER
ACMS1                             1009                      Not in 2023.4
DECOMP                             398                      Not in 2023.4&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;               33192           1808      31384    73.45  FASTER
                 2023.4         2024.1       Diff   Ratio  Comment
         -------------- -------------- ---------- --------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EXIT (CPU)      1371566.5        18673.4  1352893.1    73.45  FASTER
ELAPSED           33417           2132      31285      15.67  FASTER
Note the improved efficiency:
•Large, expensive FBS module avoided
•Overall reduction in runtime more than 15X
•Database I/O reduced from 3.4TB to 139GB
•Scratch database required reduced from 1.7TB to 123GB&lt;/p&gt;
&lt;p&gt;127  CHAPTER 7
Numerical Methods and High Performance Computing
Main Index
Mumps Out-of-core Support and Mumps DMP in Lanczos
Introduction
The MUMPS sparse solver is a state-of-the-art, highly scalable solver for systems of linear equations.  Version 2024.1 of
MSC Nastran includes two enhancements which can enable the use of the MUMPS solver on hardware with reduced
memory resources:
1.Out-of-core support for MUMPS in any solution sequence where MUMPS is available; and
2.DMP support for MUMPS with the real Lanczos eigenvalue solver.
Benefits
Larger models can be analyzed using hardware with limited memory resources by storing the factor data structures out of
core, and/or by distributing the factorization across multiple nodes using DMP . In addition, the DMP feature can provide
reduced analysis time and better performance.
Technical Discussion
The Lanczos eigenvalue solver offers multiple parallel options. Each step of the Lanczos procedure requires the solution of
a system of linear equations, which can now be performed in parallel using the MUMPS solver. In addition, when a large
number of eigenvalues must be computed, it is possible to split the eigenvalue range into multiple segments, and process
each segment in parallel. Moreover, it is possible to take advantage of both options in a “Multi-level” paradigm, where the
eigenvalue range is split into segments, and multiple DMP processes can be assigned to each segment.
User Interface
The Mumps solver is not yet the default for any solution sequence, but can be requested with the SPARSESOLVER
executive control statement. For linear statics, the following entry should be used:
SPARSESOLVER DCMP (FACTMETH=MUMPS)
While for real Lanczos, one should use:
SPARSESOLVER READ (FACTMETH=MUMPS)
Note that SMP parallelism may be used in addition to any of the DMP parallel options supported. When using DMP , each
DMP process can run with SMP parallelism, resulting in a total of DMP X SMP CPU cores being utilized.
1.Out-of-core support. If there is insufficient memory to perform an in-core factorization, this option is automatically
selected.
2.DMP support for Mumps in Lanczos. This can be requested by specifying the DMP and HOSTS keywords on the
Nastran command line, in addition to the DOMAINSOLVER executive control statement:
DOMAINSOLVER MODES (PARTOPT=DOF)&lt;/p&gt;
&lt;p&gt;128 MSC Nastran 2024.1 Release Guide
Mumps Out-of-core Support and Mumps DMP in Lanczos
Main Index
The same DOMAINSOLVER entry is used for both normal modes and buckling.
3.Splitting the eigenvalue range: This can be requested by specifying the DMP and HOSTS keywords on the Nastran
command line in addition to the DOMAINSOLVER executive control statement:
DOMAINSOLVER MODES (PARTOPT=FREQ)
This will automatically split the eigenvalue range into multiple segments, with one segment for each DMP process.
For example, when running with DMP=4, the eigenvalue range is split into 4 segments. The best performance can
be obtained by specifying multiple hosts, preferably the same number of hosts as DMP processes. So, with DMP=4,
best performance is expected when using 4 hosts.
Again, the same DOMAINSOLVER entry is used for both normal modes and buckling.
When using this feature, V2 must be specified on the EIGR or EIGRL bulk data entry. V2 is the upper bound of
the desired eigenvalue range (for buckling), or the upper bound of the frequency range (for normal modes). It is
highly recommended to also specify V1, the lower bound. The ND value on the EIGR or EIGRL entry is not used
with this option.
4.Multi-level DMP: To split the eigenvalue range into multiple segments, and then use multiple DMP processes on
each segment, include the executive control statement:
DOMAINSOLVER MODES (PARTOPT=DOF)
Then on the Nastran command line, in addition to specifying DMP and HOSTS, use the CLUSTSZ keyword,
where the value of the CLUSTSZ keyword should be the number of DMP processes assigned to each segment. For
example, to split the eigenvalue range into 4 segments, and then assign 2 DMP processes to each segment, use:
DMP=8 CLUSTSZ=2 .
The eigenvalue range is automatically split into DMP/CLUSTSZ segments.
Alternatively, in place of the CLUSTSZ keyword, the NCLUST keyword can be specified. The value of the
NCLUST keyword is the number of eigenvalue segments. To split the eigenvalue range into 3 segments and assign
2 DMP processes to each segment, use
DMP=6 NCLUST=3
When specifying NCLUST, the number of DMP processes assigned to each segment is DMP/NCLUST.
Guidelines and Limitations
The out-of-core factorization requires (20-50)% of the memory needed by the in-core factorization. However, the
performance can degrade by more than 50%, depending on the model and solution sequence. Linear statics may have very
little performance degradation, while Lanczos in normal modes or buckling may have a greater performance degradation
when a large number of eigenvalues must be calculated.
The DMP feature can only reduce memory requirements when multiple hosts are used, one per each DMP process.&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 8: General Analysis Enhancements
8 General Analysis Enhancements
LOG File Summary Output Enhancement     130&lt;/p&gt;
&lt;h1&gt;130 MSC Nastran 2024.1 Release Guide
LOG File Summary Output Enhancement
Main Index
LOG File Summary Output Enhancement
A new section of output is now present in the jid.log file.  The output is produced automatically for linear static analysis
(SOL 101) jobs that do not contain superelements or modules and do not feature restart.  There is no user interface.  The
output summarizes some of the key items that are available throughout the jid.f06 and jid.f04 files.  For 2024.1, the
summary includes the following items:
•Input BDF Entry Summary Information:  A listing and count of the entries in the BEGIN BULK section.
•Solution Summary: Solution Model Element Summary Information: A listing and count of finite elements in
the solution
•Solution Summary: GP4 RBE Model Summary Information: Counts for the various r-element (linear) types in
the solution
•Solution Summary: Displacement DOF Sets Summary Information: Popular displacement DOF set counts
•Solution Summary: Model Summary Information: General information about the solution
•Solution Summary: Disk Utilization Information: Same output as shown at the end of the jid.f04 file
A sample of the output produced:&lt;/h1&gt;&lt;h1&gt;=========================== M O D E L  S O L U T I O N  S U M M A R Y  O U T P U T  ======================================&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Solution Summary: Input BDF Entry Summary Information:
 INPUT BDF MODEL SUMMARY  (Totals for ALL BEGIN BULK sections)
  ENTRY NAME        NUMBER OF ENTRIES
  ----------        -----------------
  BCBDPRP                           3
  BCBODY1                           3
  BCONECT                           3
  BCONPRG                           3
  BCONPRP                           3
  BCPARA                            1
  BCPROP                            3
  BCTABL1                           2
  CQUAD4                          923
  CTRIA3                           13
  GRDSET                            1
  GRID                           1159
  MAT1                              2
  NLPARM                            1
  PSHELL                            3
  RBE2                              1
  SPC1                              1
  SPCD                              1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;========================================================================================================================
Solution Summary: Solution Model Element Summary Information:
FEM summary: the solution model contains the following element types
923 QUAD4    (EST typeID: 33) elements
13 TRIA3    (EST typeID: 74) elements
936 TOTAL    number of elements.&lt;/p&gt;
&lt;p&gt;========================================================================================================================
Solution Summary: Model Element Geometry Check Summary Information:&lt;/p&gt;
&lt;p&gt;131  CHAPTER 8
General Analysis Enhancements
Main Index
E L E M E N T   G E O M E T R Y   T E S T   R E S U L T S   S U M M A R Y
TOTAL NUMBER OF TIMES TOLERANCES WERE EXCEEDED
ELEMENT        SKEW       ASPECT/     MINIMUM      MAXIMUM    SURFACE/FACE    OFFSET     EDGE POINT   EDGE POINT &lt;br&gt;
JACOBIAN&lt;br&gt;
TYPE       ANGLE      TAPER RATIO INTER. ANGLE INTER. ANGLE  WARP FACTOR    RATIO     LENGTH RATIO ANGLE LIMIT&lt;br&gt;
DETERMINANT
QUAD4           0            0            1            0            0          N/A          N/A          N/A          N/A     &lt;br&gt;
TRIA3           0          N/A          N/A            0          N/A          N/A          N/A          N/A          N/A     &lt;br&gt;
N/A IN THE ABOVE TABLE INDICATES TESTS THAT ARE NOT APPLICABLE TO THE ELEMENT TYPE AND WERE NOT PERFORMED.
FOR ALL ELEMENTS WHERE GEOMETRY TEST RESULTS HAVE EXCEEDED TOLERANCES,
QUAD4    ELEMENT ID       98 PRODUCED SMALLEST INTERIOR ANGLE   OF      28.01 (TOLERANCE =       30.00).&lt;/p&gt;
&lt;p&gt;========================================================================================================================
Solution Summary: GP4 RBE Model Summary Information:
Number of R-elements in GP4 :           1
Total Number of  RBE2    elements    :           1, Number actually used for solution:           1&lt;/p&gt;
&lt;p&gt;========================================================================================================================
Solution Summary: Displacement DOF Sets Summary Information:
**** U S E T   D E F I N I T I O N   T A B L E ****
DOF SET              SB       SG        L        A        F        N        G        R        O        S        M      &lt;br&gt;
DOF SET TOTALS       16     4572     3635     3635     3635     8223     8319        0        0     4588       96&lt;/p&gt;
&lt;p&gt;========================================================================================================================
Solution Summary: Model Summary Information:
Number of Structure GRIDs              :        1159
Number of LM (Contact) Points          :         455
Number of MPC/RBE Constraint Equations :          96
Number of Nonzero K-matrix terms       :       36007
Number of Solution Equations           :        3635&lt;/p&gt;
&lt;p&gt;========================================================================================================================
Solution Summary: Disk Utilization Information:
*** TOTAL DISK USAGE STATISTICS ***
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- MAXIMUM DISK USAGE &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+
HIWATER               SUB_DMAP        DMAP
(MB)   DAY_TIME      NAME         MODULE
0.875   11:44:08    PREFACE     0  PREFACE
*** DATABASE USAGE STATISTICS ***&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- LOGICAL DBSETS &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; DBSET FILES &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+
DBSET     ALLOCATED  BLOCKSIZE       USED   USED     FILE      ALLOCATED  ALLOCATED    HIWATER       HIWATER  I/O
TRANSFERRED
(BLOCKS)    (WORDS)   (BLOCKS)      %                (BLOCKS)       (GB)   (BLOCKS)          (GB)             (GB)&lt;/p&gt;
&lt;p&gt;MASTER        25000       8192         99   0.40     MASTER        25000       1.53        106         0.006            0.000
DBALL      10000000       8192         42   0.00     DBALL      10000000     610.35         42         0.003            0.000
OBJSCR        25000       8192        505   2.02     OBJSCR        25000       1.53        519         0.032            0.000
SCRATCH    20000100       8192        158   0.00    (MEMFILE         100       0.01        100         0.006         &lt;br&gt;
0.000)
SCRATCH    10000000     610.35        260         0.016            0.000
SCR300     10000000     610.35        138         0.008            0.000
==============
TOTAL:          0.001&lt;/p&gt;
&lt;p&gt;*** BUFFER POOL AND SCRATCH 300 USAGE STATISTICS ***&lt;/p&gt;
&lt;p&gt;132 MSC Nastran 2024.1 Release Guide
LOG File Summary Output Enhancement
Main Index&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; BUFFER POOL &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+      +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; SCRATCH 300 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+
OPTION        BLOCKS      BLOCKS      BLOCKS           OPTION    HIWATER               SUB_DMAP        DMAP     OPN/CLS
SELECTED     ALLOCATED     REUSED     RELEASED         SELECTED  (BLOCKS)   DAY_TIME      NAME         MODULE    COUNTER
BPOOL4          6544       73703           0              2         138    11:44:10    LNRCNTCT  121  NLSOLV        1&lt;/p&gt;
&lt;p&gt;========================================================================================================================&lt;/p&gt;
&lt;p&gt;Main Index
Chapter 9: Platform Support
MSC Nastran Release Guide
9 Platform Support
Supported Hardware and Operating Systems     134&lt;/p&gt;
&lt;p&gt;134 MSC Nastran 2024.1 Release Guide
Supported Hardware and Operating Systems
Main Index
Supported Hardware and Operating Systems
Certified and Supported Operating Systems can be found at:
Platform Support
This release uses the Cuda 12.2. This change means K40 GPUs are no longer supported. 
Note:
1.Windows 10 may require installation/enabling .NET Framework.
2.For details see the MSC Nastran Installation and Operations Guide.
Software Development Kit (SDK)
The MSC Software Development Kit (SDK)  may be used  for users who want to customize MSC Nastran 2024. 1 with
features like User Subroutines, User Defined Modules, OpenFSI, and Beam Libraries. The SDK can be downloaded&lt;br&gt;
separately from the “MSC Software Development Kit” product page.
UDS users on window’s machines require PYTHON.exe to be in the user’s path. Python 3.6  or great er must be used.
An alternative method to SDK to use User Defined Routines has been added. This method uses simple scripts to compile
and link. Additional information may be found in the User Defined Services Guide and the Installation Guide with UDR
or UDRPATH.VendorFORTRAN
Version C Version Default MPI
Linux (64-bit) Intel oneAPI 2023.1 Intel oneAPI 2023.1 Intel MPI 2021.10
Microsoft (64-bit)  Intel oneAPI 2023.1 MSVC 14.35
Visual Studio 2022 17.5
Microsoft .NET 6Intel MPI 2021.10&lt;/p&gt;
&lt;p&gt;Main Index
Ap.A: Python Code for Post Processing TPA HDF5 File&lt;br&gt;
APython Code for Post
Processing TPA HDF5 File&lt;/p&gt;
&lt;p&gt;136 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
Python Code for Post Processing TPA
HDF5 File
There are two approaches to display the TPA results by Python snippet code.
Approach 1: Postprocessing (by GUI) for Targeted TPA Results
We illustrate how users can postprocess and create TPA plots using the HDF5 file generated by a Single-step TPA run. The
code snippets provided in this section can be expanded and customized as needed. We recommend using these snippets to
create a Jupyter notebook for convenient and interactive generation of TPA plots (each snippet can be written as a cell in
the Jupyter notebook). In fact, user inputs appearing in the snippets (e.g., H5 filename, SUBCASE ID, Resp GRID ID,
etc.) can be provided interactively within the Jupyter notebook framework.
Import Python Libraries:&lt;/p&gt;
&lt;h1&gt;h5&lt;/h1&gt;&lt;p&gt;import h5py&lt;/p&gt;
&lt;h1&gt;math&lt;/h1&gt;&lt;p&gt;import numpy as np
import pandas as pd&lt;/p&gt;
&lt;h1&gt;plot&lt;/h1&gt;&lt;p&gt;import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
from matplotlib.cm import ScalarMappable
import matplotlib.ticker as ticker
from mpl_toolkits.mplot3d import Axes3D&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;User Interface:&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#                   Retrieving i nfo from the Single-Step TPA H5 File&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def get_user_input():&lt;/p&gt;
&lt;h1&gt;U.I. to retreive H5-filename, SUBCASE ID, RespGRID ID, RespTYPE, RespDIR, Number of Peaks of&lt;/h1&gt;&lt;p&gt;interest, etc.
while True:
try:
h5file = input(&amp;ldquo;Enter FILENAME (filename.h5): &amp;ldquo;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        S = int(input(&amp;quot;Enter &#39;SUBCASE&#39; ID: &amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P8</title>
      <link>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_008/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_008/</guid>
      <description>
        
        
        &lt;p&gt;137  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
if S &amp;lt;= 0:
print(&amp;ldquo;Please enter a positive integer.&amp;rdquo;)
continue&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        G = int(input(&amp;quot;Enter &#39;Response GRID&#39; ID: &amp;quot;))
        if G &amp;lt;= 0:
            print(&amp;quot;Please enter a positive integer.&amp;quot;)
            continue
        respTYPE = input(&amp;quot;Enter Response TYPE (Press/Disp/Velo/Acce): &amp;quot;)
        if respTYPE not in [&#39;Press&#39;,&#39;Disp&#39;,&#39;Velo&#39;,&#39;Acce&#39;]:
            raise ValueError(&amp;quot;Invalid Resp TYPE. Please enter &#39;Press&#39; or &#39;Disp&#39; or &#39;Velo&#39; or &#39;Acce&#39;.&amp;quot;)
        respDIR = &amp;quot;&amp;quot;
        units =&amp;quot;&amp;quot;
        if respTYPE != &#39;Press&#39;:
            respDIR = input(&amp;quot;Enter Response DIR (X/Y/Z): &amp;quot;)
        else:
            units   = input(&amp;quot;Enter Analysis Units (mmtNs/mkgs): &amp;quot;)
            if units not in [&#39;mmtNs&#39;, &#39;mkgs&#39;]:
                raise ValueError(&amp;quot;Invalid units. Please enter &#39;mmtNs&#39; or &#39;mkgs&#39;.&amp;quot;)
    
        numPEAKs = int(input(&amp;quot;Number of Peaks: &amp;quot;))
        if numPEAKs &amp;lt;= 0:
            print(&amp;quot;Please enter a positive integer.&amp;quot;)
            continue
            
        numContr = int(input(&amp;quot;Number of Constribution Plots: &amp;quot;))
        if numContr &amp;lt;= 0:
            print(&amp;quot;Please enter a positive integer.&amp;quot;)
            continue
            
        interfaceG = int(input(&amp;quot;Enter &#39;Interface GRID&#39; ID: &amp;quot;))
        if interfaceG &amp;lt;= 0:
            print(&amp;quot;Please enter a positive integer.&amp;quot;)
            continue 
        userin = [h5file, S, G, respTYPE, respDIR, units, numPEAKs, numContr, interfaceG]
        return userin 
    except ValueError:
        print(&amp;quot;Invalid input.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Get inputs&lt;/h1&gt;&lt;p&gt;userin_L = get_user_input()&lt;/p&gt;
&lt;p&gt;138 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index&lt;/p&gt;
&lt;h1&gt;Example:&lt;/h1&gt;&lt;h1&gt;h5file = &amp;lsquo;ostpa_yaris.h5&amp;rsquo;&lt;/h1&gt;&lt;h1&gt;S = 1&lt;/h1&gt;&lt;h1&gt;G = 48067  # DVA&lt;/h1&gt;&lt;h1&gt;PDVA = &amp;lsquo;Acce&amp;rsquo;&lt;/h1&gt;&lt;h1&gt;XYZ = &amp;lsquo;X&amp;rsquo;&lt;/h1&gt;&lt;h1&gt;units = &#39;&#39;&lt;/h1&gt;&lt;h1&gt;numPEAKs = 3&lt;/h1&gt;&lt;h1&gt;numContr = 4&lt;/h1&gt;&lt;h1&gt;interfaceG = 202&lt;/h1&gt;&lt;h1&gt;H5 file main groups&lt;/h1&gt;&lt;p&gt;h5file = userin_L[0]
S = userin_L[1]
G = userin_L[2]&lt;/p&gt;
&lt;h1&gt;Total Response LinePlot&lt;/h1&gt;&lt;p&gt;PDVA = userin_L[3]
XYZ = userin_L[4]
units = userin_L[5]&lt;/p&gt;
&lt;h1&gt;Peak Contributors BarCharts&lt;/h1&gt;&lt;p&gt;numPEAKs = userin_L[6]
numContr = userin_L[7]&lt;/p&gt;
&lt;h1&gt;FRF + GPForce (from InterfaceGRID @ RespGRID) Plots&lt;/h1&gt;&lt;p&gt;interfaceG = userin_L[8]
if units == &amp;lsquo;mkgs&amp;rsquo;:
pref = 2.0e-5  # m-kg-N-s
else:
pref = 2.0e-11 # mm-t-N-s&lt;/p&gt;
&lt;h1&gt;Display the User Input&lt;/h1&gt;&lt;p&gt;if PDVA != &amp;lsquo;Press&amp;rsquo;:
print(f&amp;quot;H5filename: {h5file}, SUBCASE: {S}, Resp GRID: {G}, RespType: {PDVA}-{XYZ}&amp;quot;)
else:
print(f&amp;quot;H5filename: {h5file}, SUBCASE: {S}, Resp GRID: {G}, RespType: {PDVA}, Analyis Units: {units}&amp;quot;)
2. Read the Single-Step TPA H5 File:
if PDVA != &amp;lsquo;Press&amp;rsquo;:   # &amp;lsquo;Disp&amp;rsquo; or &amp;lsquo;Velo&amp;rsquo; or &amp;lsquo;Acce&amp;rsquo;
ds_paths = [
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/{PDVA}-{XYZ}/Contrib-M&amp;rsquo;,&lt;/p&gt;
&lt;p&gt;139  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/{PDVA}-{XYZ}/Contrib-PH&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/{PDVA}-{XYZ}/FRF/FRF-IM&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/{PDVA}-{XYZ}/FRF/FRF-RE&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/{PDVA}-{XYZ}/TPA-M&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/{PDVA}-{XYZ}/TotalRes&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/InterfaceForce&amp;rsquo;
]
else:
ds_paths = [
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/Contrib-M&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/Contrib-PH&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/FRF/FRF-IM&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/FRF/FRF-RE&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/TPA-M&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/TotalRes&amp;rsquo;,
f&amp;rsquo;/SUBCASE {S}/Grid {G}/{PDVA}/InterfaceForce&amp;rsquo;
]
try:
with h5py.File(h5file, &amp;lsquo;r&amp;rsquo;) as hf5:
df_ContribM  = pd.DataFrame(hf5[ds_paths[0]][:])
df_ContribPH = pd.DataFrame(hf5[ds_paths[1]][:])
df_FRF_IM    = pd.DataFrame(hf5[ds_paths[2]][:])
df_FRF_RE    = pd.DataFrame(hf5[ds_paths[3]][:])
df_TPA_M     = pd.DataFrame(hf5[ds_paths[4]][:])
df_TotRes    = pd.DataFrame(hf5[ds_paths[5]][:])
df_InterF    = pd.DataFrame(hf5[ds_paths[6]][:])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    # Press Reference Levels
    if PDVA == &#39;Press&#39;:
        print(&#39;PRESSURE!&#39;)
        df_TPA_M.iloc[:, 1:] = df_TPA_M.iloc[:, 1:].applymap(lambda x: 20*np.log10(x/pref))
        df_TotRes.iloc[:, 1:] = df_TotRes.iloc[:, 1:].applymap(lambda x: 20*np.log10(x/pref))  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;except Exception as e:
print(f&amp;quot;An error occurred: {e} &amp;hellip;check your inputs&amp;quot;)
3. PostProcessin g
TPA - Total Response Plot :&lt;/p&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#                      TPA: Total Response Comparisons&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def plotTPA_TotRes(mydf_Tot,S,G,DVA,XYZ):&lt;/p&gt;
&lt;p&gt;140 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
# TPA Complex Sum vs. Solver&lt;br&gt;
fig, ax = plt.subplots(figsize=(10, 5))
ax.set_title(f&amp;rsquo;TPA: {DVA}{XYZ} Total Response - ComplexSum vs. AssemblyRun&amp;rsquo;, fontsize=14, color=&amp;lsquo;blue&amp;rsquo; )&lt;br&gt;
ax.set_xlabel(&amp;lsquo;Freq [Hz]&amp;rsquo;, fontsize=11)
ax.set_ylabel(f&amp;rsquo;{DVA}{XYZ}  [dB]&amp;rsquo; if PDVA == &amp;lsquo;Press&amp;rsquo; else f&amp;rsquo;{DVA}{XYZ}&amp;rsquo;, fontsize=11)
ax.tick_params(axis=&amp;lsquo;both&amp;rsquo;, which=&amp;lsquo;major&amp;rsquo;, labelsize=10)
ax.plot(mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;], mydf_Tot[&amp;lsquo;Complex Sum&amp;rsquo;], color=&amp;lsquo;pink&amp;rsquo;, linewidth=5, label=&amp;lsquo;Complex Sum&amp;rsquo;)&lt;br&gt;
ax.plot(mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;], mydf_Tot[&amp;lsquo;Assembly Run Response&amp;rsquo;], marker=&amp;lsquo;o&amp;rsquo;, markerfacecolor=&amp;lsquo;green&amp;rsquo;, label=&amp;lsquo;Solver&amp;rsquo;)&lt;br&gt;
ax.legend(fontsize=9)
ax.grid(True)
plt.show()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return fig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;plot1 = plotTPA_TotRes(df_TotRes,S,G,PDVA,XYZ)
TPA - Contributing Paths:&lt;/p&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#                     TPA: Contributing Paths (HeatMap Plots)&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def plotTPA_HeatMaps(mydf_TPA_M,S,G,DVA,XYZ):
end_column = mydf_TPA_M.shape[1]&lt;/p&gt;
&lt;p&gt;141  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
step = 6
dir_map =   {
2: &amp;lsquo;X&amp;rsquo;,
3: &amp;lsquo;Y&amp;rsquo;,
4: &amp;lsquo;Z&amp;rsquo;,
5: &amp;lsquo;RX&amp;rsquo;,
6: &amp;lsquo;RY&amp;rsquo;,
7: &amp;lsquo;RZ&amp;rsquo;&lt;br&gt;
}
fig, axs = plt.subplots(3, 2, figsize=(8, 10))
fig.suptitle(f&amp;rsquo;TPA: {DVA}{XYZ} - Contributing Paths @ RespGRID {G}&amp;rsquo;, fontsize=14, color=&amp;lsquo;blue&amp;rsquo;)
axs = axs.T.flatten()
ic=0
for start_column in range (2,8):
dir = dir_map.get(start_column, &amp;lsquo;Unknown&amp;rsquo;)
located_columns = []
i_L=[]
for i in range(start_column - 1, end_column, step):
located_columns.append(mydf_TPA_M.iloc[:, i])
i_L.append(i)
X = mydf_TPA_M[&amp;lsquo;F [Hz]&amp;rsquo;]
Z_columns = located_columns
Y = np.arange(1, len(located_columns)+1)
Z = np.vstack(Z_columns)
ax = axs[ic]
pcm = ax.pcolormesh(X, Y, Z, cmap=&amp;lsquo;jet&amp;rsquo;)
ax.set_title(f&amp;rsquo;{DVA}{XYZ} from {dir}-DIR of Interf-GRIDs @ GRID {G}&amp;rsquo;, fontsize=9, color=&amp;lsquo;blue&amp;rsquo;)
cbar = fig.colorbar(pcm, ax=ax, cmap=&amp;lsquo;jet&amp;rsquo;)
label_dB = f&amp;rsquo;{DVA}{XYZ} [dB]&amp;rsquo; if PDVA == &amp;lsquo;Press&amp;rsquo; else f&amp;rsquo;{DVA}{XYZ}&amp;rsquo;
cbar.set_label(label_dB)
ax.set_xlabel(&amp;lsquo;Freq [Hz]&amp;rsquo;, fontsize=8)
ax.set_ylabel(&amp;lsquo;InterfaceGRID-DOF&amp;rsquo;, fontsize=8)
yticks_values = Y
yticks_labels = [f&amp;rsquo;{mydf_TPA_M.columns[ii]}&amp;rsquo; for ii in i_L]
ax.set_yticks(yticks_values+0, yticks_labels)
ax.tick_params(labelsize=6)
ic += 1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plt.tight_layout()  # Adjust layout to prevent overlap
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;142 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
return fig
plot2 = plotTPA_HeatMaps(df_TPA_M,S,G,PDVA,XYZ)
TPA - Top Contributors To Total Response:&lt;/p&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#       TPA: TotalResponse with Peaks and Comparison Bar Charts (@ Peaks)&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def plotTPA_TotRes_Comp_Bars(mydf_Tot, rank,row_M,row_PH, S,G,DVA,XYZ,numContr):&lt;/p&gt;
&lt;p&gt;143  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
Fpeak_value = row_M[&amp;lsquo;Fpeaks [Hz]&amp;rsquo;]
peakN=int(rank)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fig, axs = plt.subplots(2,1,figsize=(8, 4))  # Create a figure and an axis
fig.suptitle(f&#39;TPA: {DVA}{XYZ} - Top {numContr} Contributors to Tot Resp @ Peak {peakN} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;({round(Fpeak_value,2)} Hz)&amp;rsquo;, fontsize=14, color=&amp;lsquo;blue&amp;rsquo;)
row_M_NoF_NoChk = row_M.drop(&amp;lsquo;Fpeaks [Hz]&amp;rsquo;)
largest_indices_M = row_M_NoF_NoChk.nlargest(numContr).index
largest_values_M = list(row_M_NoF_NoChk.nlargest(numContr))
# Plot the bars of the MAGNITUDE for the largest &amp;rsquo;numTopPaths&amp;rsquo; contributors to the TPA Magnitude
bars1 = axs[0].bar(range(len(largest_indices_M)), largest_values_M, color=&amp;lsquo;cyan&amp;rsquo;)
for i, bar in enumerate(bars1):
yval = bar.get_height()
axs[0].text(bar.get_x() + bar.get_width()/2, yval, f&amp;rsquo;{round(yval,1)}%&amp;rsquo;, va=&amp;lsquo;bottom&amp;rsquo;,
ha=&amp;lsquo;center&amp;rsquo;, fontsize=8, color=&amp;lsquo;blue&amp;rsquo;)
axs[0].set_ylabel(&amp;lsquo;Path Contribution [%]&amp;rsquo;,fontsize=9, labelpad=15)
axs[0].tick_params(axis=&amp;lsquo;both&amp;rsquo;, which=&amp;lsquo;major&amp;rsquo;, labelsize=7)
axs[0].set_xticks(list(range(len(largest_indices_M))))
axs[0].set_xticklabels(list(largest_indices_M) )
# Plot the bars of the PHASE for the largest &amp;rsquo;numTopPaths&amp;rsquo; contributors to the TPA Magnitude
row_data_PH = row_PH.drop(&amp;lsquo;Fpeaks [Hz]&amp;rsquo;)
largest_values_PH_list=[]
for col_index in largest_indices_M:
value = row_data_PH[col_index]
largest_values_PH_list.append(value)
bars2=axs[1].bar(range(len(largest_indices_M)), largest_values_PH_list, color=(0, 1, 0))
for bar in bars2:
yval = bar.get_height()
text_pos = yval-35 if yval &amp;lt; 0 else yval
axs[1].text(bar.get_x() + bar.get_width()/2, text_pos, f&amp;rsquo;{round(yval,1)}°&amp;rsquo;, va=&amp;lsquo;bottom&amp;rsquo;,
ha=&amp;lsquo;center&amp;rsquo;, fontsize=8, color=&amp;lsquo;green&amp;rsquo;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;axs[1].set_xticks(range(len(largest_indices_M)), largest_indices_M)
axs[1].set_ylabel(&#39;Phase [deg]&#39;,fontsize=9, labelpad=8)
y_ticks2=[-180,-120,-60,0,60,120,180]
axs[1].set_yticks(y_ticks2)    
axs[1].set_xlabel(&#39;Contributing Paths: InterfaceGRID-DOF&#39;,fontsize=9)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;144 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
axs[1].tick_params(axis=&amp;lsquo;both&amp;rsquo;, which=&amp;lsquo;major&amp;rsquo;, labelsize=7)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return fig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mydf_ContrM = df_ContribM.copy()
mydf_Tot = df_TotRes.copy()
mydf_ContrPH = df_ContribPH.copy()
Fpeaks = mydf_ContrM[&amp;lsquo;Fpeaks [Hz]&amp;rsquo;]
bool_mydf_Tot = mydf_Tot[ mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;].isin(Fpeaks) ]
Mpeaks = bool_mydf_Tot[&amp;lsquo;Complex Sum&amp;rsquo;].tolist()
dfnew = pd.DataFrame({ &amp;lsquo;ff&amp;rsquo;: Fpeaks, &amp;lsquo;mm&amp;rsquo;: Mpeaks })
dfnew[&amp;lsquo;my_order&amp;rsquo;] = dfnew[&amp;lsquo;mm&amp;rsquo;].rank(method=&amp;lsquo;dense&amp;rsquo;, ascending=False)
dfnew_sorted_by_order = dfnew.sort_values(&amp;lsquo;my_order&amp;rsquo;)
ordered_indexes = dfnew_sorted_by_order.index.tolist()
plot3={}
for i in range(numPEAKs):
idx = ordered_indexes[i]
rank = dfnew[&amp;lsquo;my_order&amp;rsquo;][idx]
row_M = mydf_ContrM.iloc[idx]
row_PH = mydf_ContrPH.iloc[idx]
fig_name = f&amp;rsquo;plot3_{idx + 1}&amp;rsquo;
plot3[fig_name] = plotTPA_TotRes_Comp_Bars(df_TotRes, rank,row_M,row_PH,
S,G,PDVA,XYZ,numContr)&lt;/p&gt;
&lt;p&gt;145  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
FRF and Interface Loads:&lt;/p&gt;
&lt;h1&gt;FRF Magnitude&lt;/h1&gt;&lt;p&gt;dfMag = pd.DataFrame()
for column in df_FRF_RE.columns[1:]:  # Exclude the first column by starting from index 1&lt;/p&gt;
&lt;p&gt;146 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
dfMag[column] = np.sqrt(df_FRF_RE[column]**2 + df_FRF_IM[column]**2)
dfMag.insert(0, &amp;lsquo;F [Hz]&amp;rsquo;, df_FRF_RE[&amp;lsquo;F [Hz]&amp;rsquo;])
fig, axs = plt.subplots(nrows=6, ncols=2, figsize=(8, 15))
fig.suptitle(f&amp;rsquo;FRF and InterfaceLoads from InterfGRID {interfaceG} @ RespGRID {G}\n&amp;rsquo;, fontsize=14,
color=&amp;lsquo;blue&amp;rsquo;)&lt;/p&gt;
&lt;p&gt;col_interfaceG  = [col for col in dfMag.columns if str(interfaceG) in col]
fcol_interfaceG = col_interfaceG[0] if col_interfaceG else None
if fcol_interfaceG is not None:
idx_fcol_interfaceG = dfMag.columns.get_loc(fcol_interfaceG)
else:
print(&amp;ldquo;Interface GRID ID does not exist in this .h5 file&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;for i in range(1, 7):
ax_left = axs[i-1, 0]
ax_right = axs[i-1, 1]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# FRF Plots (Left Subplots)
freqs = dfMag.iloc[:, 0]
FRF_M = dfMag.iloc[:, idx_fcol_interfaceG+i-1] 
path = dfMag.columns[idx_fcol_interfaceG+i-1]
ax_left.set_title(f&#39;FRF from {path} @ RespGRID {G}&#39;, fontsize=9, color=&#39;green&#39;)
ax_left.set_xlabel(&#39;Freq [Hz]&#39;)
ax_left.set_ylabel(f&#39;Load on Path {path}&#39;)
ax_left.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=7)
ax_left.plot(freqs, FRF_M, marker=&#39;o&#39;, markersize=3, color=&#39;green&#39;)

# Interface Force Plots (Right Subplots)
IF_M = df_InterF.iloc[:, idx_fcol_interfaceG+i-1]
ax_right.set_title(f&#39;InterfaceLoad from {path} @ RespGRID {G}&#39;, fontsize=9, color=&#39;blue&#39;)
ax_right.set_xlabel(&#39;Freq [Hz]&#39;)
ax_right.set_ylabel(f&#39;Load on Path {path}&#39;)
ax_right.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=7)
ax_right.plot(freqs, IF_M, marker=&#39;o&#39;, markersize=3, color=&#39;blue&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;plt.tight_layout()
plt.show()&lt;/p&gt;
&lt;p&gt;147  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index&lt;/p&gt;
&lt;p&gt;148 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
Approach 2: Postprocessing (by PDF)
We illustrate how users can postprocess and create TPA plots directly to a .pdf document, using the HDF5 file generated
by a Single-step TPA run. The code snippets provided in this section can be expanded and customized as needed. We
recommend using these snippets to create a Jupyter notebook for convenient and interactive generation of TPA plots (each
snippet can be written as a cell in the Jupyter notebook). In this example, TPA plots will be generated for &amp;ldquo;all datasets&amp;rdquo;
contained in the HDF5 file (per each SUBCASE, per each Response GRID, per each Response TYPE, per each Response
DIR).&lt;/p&gt;
&lt;p&gt;149  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
Importing Python Libraries:&lt;/p&gt;
&lt;h1&gt;h5&lt;/h1&gt;&lt;p&gt;import h5py&lt;/p&gt;
&lt;h1&gt;math&lt;/h1&gt;&lt;p&gt;import numpy as np
import pandas as pd&lt;/p&gt;
&lt;h1&gt;plot&lt;/h1&gt;&lt;p&gt;import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
from matplotlib.cm import ScalarMappable
import matplotlib.ticker as ticker
from mpl_toolkits.mplot3d import Axes3D&lt;/p&gt;
&lt;h1&gt;pdf&lt;/h1&gt;&lt;p&gt;import PyPDF2
from matplotlib.backends.backend_pdf import PdfPages&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;List of All Functions&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#                            Extract all Datasets&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def collect_dataset_paths(group, path=&amp;quot;&amp;quot;, dataset_paths=[]):
# Iterate over ITEMS
for key, item in group.items():
current_path = f&amp;quot;{path}/{key}&amp;quot;
if isinstance(item, h5py.Dataset):
# If DATASET -&amp;gt; Append it to the path
dataset_paths.append(current_path)
elif isinstance(item, h5py.Group):
# If GROUP -&amp;gt; Recurse in the group
collect_dataset_paths(item, current_path, dataset_paths)
return dataset_paths&lt;/p&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#                       Plot and Print (Each Response Block)&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def process_datasets(idx,i,mylist, all_paths, h_file, pdfs):
dfs = {}
for j in range(i,mylist[idx+1]):
ds = h_file[all_paths[j]]&lt;/p&gt;
&lt;p&gt;150 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
df = pd.DataFrame(ds[:])
dfn = dfname(all_paths[j])
dfs[dfn] = df
print(&amp;lsquo;dfs_keys: &amp;lsquo;, dfs.keys())
return plot_and_pdf(dfs, pdfs, PDVA)&lt;/p&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#                            Process the Dataset-Path&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def dfname(input_string):
tokens = input_string.split(&amp;rsquo;/&amp;rsquo;)
result_string = &amp;rsquo;&amp;rsquo;
for itok in tokens[1:]:
result_string = result_string + itok + &amp;lsquo;_&amp;rsquo;
result_string=result_string[:-1]
return result_string&lt;/p&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#                      TPA: Total Response Comparisons&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def plotTPA_TotRes(mydf_Tot,S,G,DVA,XYZ):
if DVA==&amp;lsquo;Press&amp;rsquo;:
pref = 2.0e-11 # mm-t-N-s
# pref = 2.0e-5  # m-kg-N-s
mydf_Tot.iloc[:, 1:] = mydf_Tot.iloc[:, 1:].applymap(lambda x: 20*np.log10(x/pref))&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fig, axs = plt.subplots(3, 1, figsize=(8, 10)) 
fig.suptitle(f&#39;TPA - {DVA}{XYZ} Total Response\n&#39;, fontsize=15, color=&#39;red&#39;, 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fontweight=&amp;lsquo;bold&amp;rsquo;)
fig.text(0.5, 0.95, f&amp;rsquo;SUB {S}:  RespGRID {G}&amp;rsquo;, fontsize=10, ha=&amp;lsquo;center&amp;rsquo;, va=&amp;lsquo;center&amp;rsquo;,
color=&amp;lsquo;red&amp;rsquo;)
# TPA Total Resp Sum Comparisons&lt;br&gt;
axs[0].set_title(f&amp;rsquo;TPA: {DVA}{XYZ} Total Response - InPhaseSum vs. ComplexSum&amp;rsquo;, fontsize=11,
color=(0.666, 0, 1) )
axs[0].set_ylabel(f&amp;rsquo;{DVA}{XYZ}  [dB]&amp;rsquo; if DVA == &amp;lsquo;Press&amp;rsquo; else f&amp;rsquo;{DVA}{XYZ}&amp;rsquo;, fontsize=9)
axs[0].tick_params(axis=&amp;lsquo;both&amp;rsquo;, which=&amp;lsquo;major&amp;rsquo;, labelsize=7)
axs[0].plot(mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;], mydf_Tot[&amp;lsquo;InPhase Sum (Worst Case)&amp;rsquo;], color=&amp;lsquo;blue&amp;rsquo;,
label=&amp;lsquo;InPhase Sum&amp;rsquo;)&lt;/p&gt;
&lt;p&gt;151  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
axs[0].plot(mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;], mydf_Tot[&amp;lsquo;Complex Sum&amp;rsquo;], color=&amp;rsquo;#FFCCFF&amp;rsquo;, linewidth=5,
label=&amp;lsquo;Complex Sum&amp;rsquo;)
axs[0].plot(mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;], mydf_Tot[&amp;lsquo;Assembly Run Response&amp;rsquo;], marker=&amp;lsquo;o&amp;rsquo;, markersize=2,
markerfacecolor=&amp;lsquo;green&amp;rsquo;, label=&amp;lsquo;Solver&amp;rsquo;)
axs[0].legend(fontsize=9)
axs[0].grid(True)
# TPA Total Resp Sum Comparisons&lt;br&gt;
axs[1].set_title(f&amp;rsquo;TPA: {DVA}{XYZ} Total Response - ComplexSum vs. AssemblyRun&amp;rsquo;, fontsize=11,
color=(0.666, 0, 1) )
axs[1].set_ylabel(f&amp;rsquo;{DVA}{XYZ}  [dB]&amp;rsquo; if DVA == &amp;lsquo;Press&amp;rsquo; else f&amp;rsquo;{DVA}{XYZ}&amp;rsquo;, fontsize=9)
axs[1].tick_params(axis=&amp;lsquo;both&amp;rsquo;, which=&amp;lsquo;major&amp;rsquo;, labelsize=7)
axs[1].plot(mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;], mydf_Tot[&amp;lsquo;Complex Sum&amp;rsquo;], color=&amp;rsquo;#FFCCFF&amp;rsquo;, linewidth=5,
label=&amp;lsquo;Complex Sum&amp;rsquo;)
axs[1].plot(mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;], mydf_Tot[&amp;lsquo;Assembly Run Response&amp;rsquo;], marker=&amp;lsquo;o&amp;rsquo;,
markerfacecolor=&amp;lsquo;green&amp;rsquo;, label=&amp;lsquo;Solver&amp;rsquo;)
axs[1].legend(fontsize=9)
axs[1].grid(True)
# TPA Total Resp Sum Difference
axs[2].set_title(f&amp;rsquo;TPA: {DVA}{XYZ} Total Response - Diff = (ComplexSum - AssemblyRun)&amp;rsquo;,
fontsize=11, color=&amp;lsquo;red&amp;rsquo;)
axs[2].set_xlabel(&amp;lsquo;Freq (Hz)&amp;rsquo;, fontsize=9)
axs[2].set_ylabel(f&amp;rsquo;{DVA}{XYZ} Diff  [dB]&amp;rsquo; if DVA == &amp;lsquo;Press&amp;rsquo; else f&amp;rsquo;{DVA}{XYZ} Diff&amp;rsquo;,
fontsize=9)
y_lims = axs[1].get_ylim()
axs[2].set_ylim(y_lims)
axs[2].tick_params(axis=&amp;lsquo;both&amp;rsquo;, which=&amp;lsquo;major&amp;rsquo;, labelsize=7)
axs[2].plot(mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;], mydf_Tot[&amp;lsquo;Complex Sum&amp;rsquo;] - mydf_Tot[&amp;lsquo;Assembly Run Response&amp;rsquo;],
color=&amp;lsquo;red&amp;rsquo;, linestyle=&amp;rsquo;&amp;ndash;&amp;rsquo;, label=&amp;lsquo;Diff&amp;rsquo;)
axs[2].legend(fontsize=9)
axs[2].grid(True)
# plt.show()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return fig
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#               TPA: Contributing Paths (Heat Map &amp;amp; WaterFall Plots)&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def plotTPA_HeatMaps(mydf_TPA_M,S,G,DVA,XYZ,figrange):
end_column = mydf_TPA_M.shape[1]
step = 6&lt;/p&gt;
&lt;p&gt;152 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
dir_map =   {
2: &amp;lsquo;X&amp;rsquo;,
3: &amp;lsquo;Y&amp;rsquo;,
4: &amp;lsquo;Z&amp;rsquo;,
5: &amp;lsquo;RX&amp;rsquo;,
6: &amp;lsquo;RY&amp;rsquo;,
7: &amp;lsquo;RZ&amp;rsquo;&lt;br&gt;
}
fig = plt.figure(figsize=(8, 10))
if figrange[0]&amp;lt;5:
mycolor = &amp;lsquo;blue&amp;rsquo;
else:
mycolor = (0.933,0.933,0.933)
fig.suptitle(f&amp;rsquo;TPA: {DVA}{XYZ} - Contributing Paths\n&amp;rsquo;, fontsize=15, fontweight=&amp;lsquo;bold&amp;rsquo;,
color=mycolor)
fig.text(0.5, 0.95, f&amp;rsquo;SUB {S}:  RespGRID {G}&amp;rsquo;, fontsize=10, ha=&amp;lsquo;center&amp;rsquo;, va=&amp;lsquo;center&amp;rsquo;,
color=mycolor)
ic=0
for start_column in range (figrange[0],figrange[1]):
dir = dir_map.get(start_column, &amp;lsquo;Unknown&amp;rsquo;)
located_columns = []
i_L=[]
for i in range(start_column - 1, end_column, step):
located_columns.append(mydf_TPA_M.iloc[:, i])
i_L.append(i)
X = mydf_TPA_M[&amp;lsquo;F [Hz]&amp;rsquo;]
Z_columns = located_columns
Y = np.arange(1, len(located_columns)+1)
Z = np.vstack(Z_columns)
ax1 = fig.add_subplot(3, 2, ic*2+1)
ax1.set_title(f&amp;rsquo;{DVA}{XYZ} from {dir}-DIR of Interf-GRIDs @ GRID {G}&amp;rsquo;, fontsize=8,
color=&amp;lsquo;blue&amp;rsquo;)
# HeatMap Plot
pcm = ax1.pcolormesh(X, Y, Z, cmap=&amp;lsquo;jet&amp;rsquo;)
cbar = fig.colorbar(pcm, ax=ax1, cmap=&amp;lsquo;jet&amp;rsquo;)
label_text = f&amp;rsquo;{DVA}{XYZ} [dB]&amp;rsquo; if DVA == &amp;lsquo;Press&amp;rsquo; else f&amp;rsquo;{DVA}{XYZ}&amp;rsquo;
cbar.set_label(label_text)
cbar.ax.yaxis.label.set_size(8)
cbar.ax.yaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))&lt;/p&gt;
&lt;p&gt;153  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
cbar.ax.yaxis.get_offset_text().set(va=&amp;lsquo;bottom&amp;rsquo;, ha=&amp;lsquo;right&amp;rsquo;, rotation=0, fontsize=8)
cbar.ax.tick_params(labelsize=7)
formatter = ticker.ScalarFormatter(useMathText=True)
formatter.set_powerlimits((0, 0))
cbar.ax.yaxis.set_major_formatter(formatter)
fig.canvas.draw()
offset_text = cbar.ax.yaxis.get_offset_text().get_text()
cbar.ax.yaxis.get_offset_text().set_visible(False)
if offset_text:
cbar.ax.text(1.05, 0, offset_text, transform=cbar.ax.transAxes, ha=&amp;lsquo;left&amp;rsquo;, va=&amp;lsquo;bottom&amp;rsquo;,
fontsize=7)
ax1.pcolormesh(X, Y, Z, cmap=&amp;lsquo;jet&amp;rsquo;)
ax1.set_xlabel(&amp;lsquo;Freq [Hz]&amp;rsquo;, fontsize=8)
ax1.set_ylabel(&amp;lsquo;InterfaceGRID-DOF&amp;rsquo;, fontsize=8)
yticks_values = Y
yticks_labels = [f&amp;rsquo;{mydf_TPA_M.columns[ii]}&amp;rsquo; for ii in i_L]
ax1.set_yticks(yticks_values+0, yticks_labels)
ax1.tick_params(labelsize=6)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    # 3D Plot
    ax2 = fig.add_subplot(3, 2, ic*2+2, projection=&#39;3d&#39;, proj_type=&#39;ortho&#39;)
    ax2.set_title(f&#39;{DVA}{XYZ} from {dir}-DIR of Interf-GRIDs @ GRID {G}&#39;, fontsize=8, 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;color=&amp;lsquo;blue&amp;rsquo;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    for j in range(len(Y)):
        x_values = X
        y_values = np.ones_like(x_values)*Y[j]
        z_values = Z[j]
        # Normalized Colormap
        norm = Normalize(vmin=min(z_values), vmax=max(z_values))
        scalar_map = ScalarMappable(cmap=&#39;jet&#39;, norm=norm)
        scalar_map.set_array([]) 
        for i in range(len(x_values) - 1):
            ax2.plot([x_values[i], x_values[i + 1]], [y_values[i], y_values[i + 1]], 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[z_values[i], z_values[i + 1]],
color=scalar_map.to_rgba(z_values[i]))
ax2.set_xlabel(&amp;lsquo;Freq [Hz]&amp;rsquo;, fontsize=8)
ax2.set_ylabel(&amp;lsquo;InterfaceGRID-DOF&amp;rsquo;, labelpad=10, fontsize=8)
label_text = f&amp;rsquo;{DVA}{XYZ} [dB]&amp;rsquo; if DVA == &amp;lsquo;Press&amp;rsquo; else f&amp;rsquo;{DVA}{XYZ}&amp;rsquo;
ax2.set_zlabel(label_text)
ax2.zaxis.label.set_size(8)&lt;/p&gt;
&lt;p&gt;154 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    ax2.zaxis.set_tick_params(labelleft=False) 
    yticks_labels = [f&#39;{mydf_TPA_M.columns[i]}&#39; for i in i_L]        
    ax2.set_yticks(yticks_values, yticks_labels)
    ax2.yaxis.set_major_locator(plt.MaxNLocator(integer=True)) 
    for tick in ax2.get_yticklabels():
        tick.set_rotation(20)
    ax2.set_ylim(0, ax2.get_ylim()[1])
    ax2.view_init(elev=20, azim=-135)
    ax2.tick_params(labelsize=6) 
    plt.subplots_adjust(wspace=0.2) 
    ic+=1
fig.subplots_adjust(hspace=0.3)
# plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;return fig&lt;/p&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#       TPA: TotalResponse with Peaks and Comparison Bar Charts (@ Peaks)&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def plotTPA_TotRes_Comp_Bars(mydf_Tot, rank,row_M,row_PH, S,G,DVA,XYZ):
Fpeak_value = row_M[&amp;lsquo;Fpeaks [Hz]&amp;rsquo;]
peakN=int(rank)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fig, axs = plt.subplots(2, 1, figsize=(8, 10))  # 3 rows, 1 column
fig.suptitle(f&#39;TPA: {DVA}{XYZ} - Tot Resp Contributions @ Peak {peakN} ({round(Fpeak_value,2)} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hz)\n&amp;rsquo;, fontsize=15, color=(0.1882,0.3098,0.9960), fontweight=&amp;lsquo;bold&amp;rsquo;)
fig.text(0.5, 0.95, f&amp;rsquo;SUB {S}:  RespGRID {G}&amp;rsquo;, fontsize=10, ha=&amp;lsquo;center&amp;rsquo;, va=&amp;lsquo;center&amp;rsquo;,
color=(0.1882,0.3098,0.9960) )&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# TPA Tot Resp Plot     
axs[0].set_title(f&#39;TPA: {DVA}{XYZ} - Tot Resp (ComplexSum)&#39;, fontsize=11, color=(0.666, 0, 1) )
axs[0].plot(mydf_Tot[&#39;F [Hz]&#39;], mydf_Tot[&#39;Complex Sum&#39;], color=&#39;#FFCCFF&#39;, linewidth=3) 
axs[0].grid(True)
y_value = mydf_Tot.loc[mydf_Tot[&#39;F [Hz]&#39;] == Fpeak_value, &#39;Complex Sum&#39;].values[0]
axs[0].vlines(x=Fpeak_value, ymin=mydf_Tot[&#39;Complex Sum&#39;].min(), ymax=y_value, color=&#39;red&#39;, 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;linestyle=&amp;rsquo;&amp;ndash;&amp;rsquo;, label=&amp;lsquo;Vertical Line&amp;rsquo;, linewidth=1)
axs[0].scatter(x=Fpeak_value, y=y_value, color=&amp;lsquo;red&amp;rsquo;, marker=&amp;lsquo;o&amp;rsquo;, edgecolors=&amp;lsquo;red&amp;rsquo;, s=50,
label=&amp;lsquo;Circle Marker&amp;rsquo;, zorder=3)&lt;/p&gt;
&lt;p&gt;155  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
axs[0].tick_params(axis=&amp;lsquo;both&amp;rsquo;, which=&amp;lsquo;major&amp;rsquo;, labelsize=7)
axs[0].set_xlabel(&amp;lsquo;Freq (Hz)&amp;rsquo;, fontsize=9)
axs[0].set_ylabel(f&amp;rsquo;{DVA}{XYZ}  [dB]&amp;rsquo; if DVA == &amp;lsquo;Press&amp;rsquo; else f&amp;rsquo;{DVA}{XYZ}&amp;rsquo;, fontsize=8)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# TPA Path Contributions Bar Plots
numTopPaths = 5
axs[1].set_title(f&#39;Top {numTopPaths} Paths to Tot Resp (Projected Mag) @ f = 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{round(Fpeak_value,2)} Hz&amp;rsquo;, fontsize=11, color=&amp;lsquo;blue&amp;rsquo; )
axs[1].axis(&amp;lsquo;off&amp;rsquo;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Create the first sub-subplot (above)
ax_M = axs[1].inset_axes([0.1, 0.6, 0.9, 0.4]) 
# Create the second sub-subplot (below)
ax_PH = axs[1].inset_axes([0.1, 0.1, 0.9, 0.4]) 
row_M_NoF = row_M.drop(&#39;Fpeaks [Hz]&#39;)
row_M_NoF_NoChk = row_M_NoF.drop(&#39;PercentSumCheck&#39;)
largest_indices_M = row_M_NoF_NoChk.nlargest(numTopPaths).index
largest_values_M = list(row_M_NoF_NoChk.nlargest(numTopPaths))
# Plot the bars of the MAGNITUDE for the largest &#39;numTopPaths&#39; contributors to the TPA 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Magnitude
bars1 = ax_M.bar(range(len(largest_indices_M)), largest_values_M, color=&amp;lsquo;cyan&amp;rsquo;)
for i, bar in enumerate(bars1):
yval = bar.get_height()
ax_M.text(bar.get_x() + bar.get_width()/2, yval, f&amp;rsquo;{round(yval,1)}%&amp;rsquo;, va=&amp;lsquo;bottom&amp;rsquo;,
ha=&amp;lsquo;center&amp;rsquo;, fontsize=8, color=&amp;lsquo;blue&amp;rsquo;)
# Add the &amp;lsquo;PercentSumCheck&amp;rsquo; bar
percent_sum_check_value = row_M[&amp;lsquo;PercentSumCheck&amp;rsquo;]
percent_sum_check_bar   = ax_M.bar(len(largest_indices_M), round(percent_sum_check_value),
color=&amp;rsquo;#FFCCFF&amp;rsquo;)
for bar in percent_sum_check_bar:
yval = bar.get_height()
ax_M.text(bar.get_x() + bar.get_width()/2, yval, f&amp;rsquo;{round(yval,1)}%&amp;rsquo;, va=&amp;lsquo;bottom&amp;rsquo;,
ha=&amp;lsquo;center&amp;rsquo;, fontsize=8, color=(0.666, 0, 1))&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ax_M.set_xticks(list(range(len(largest_indices_M) + 1)))  # Include extra tick for 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PercentSumCheck
ax_M.set_xticklabels(list(largest_indices_M) + [&amp;lsquo;All Paths&amp;rsquo;])
tick_labels = ax_M.get_xticklabels()
tick_labels[-1].set_color((0.666, 0, 1))
ax_M.set_ylabel(&amp;lsquo;Path Contribution [%]&amp;rsquo;,fontsize=9, labelpad=15)
ax_M.tick_params(axis=&amp;lsquo;both&amp;rsquo;, which=&amp;lsquo;major&amp;rsquo;, labelsize=7)&lt;/p&gt;
&lt;p&gt;156 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
ax_M.yaxis.grid(False)
ax_M.xaxis.grid(True)
# Plot the bars of the PHASE for the largest &amp;rsquo;numTopPaths&amp;rsquo; contributors to the TPA Magnitude
row_data_PH = row_PH.drop(&amp;lsquo;Fpeaks [Hz]&amp;rsquo;)
largest_values_PH_list=[]
for col_index in largest_indices_M:
value = row_data_PH[col_index]
largest_values_PH_list.append(value)
bars2=ax_PH.bar(range(len(largest_indices_M)), largest_values_PH_list, color=(0, 1, 0))
for bar in bars2:
yval = bar.get_height()
text_pos = yval-35 if yval &amp;lt; 0 else yval
ax_PH.text(bar.get_x() + bar.get_width()/2, text_pos, f&amp;rsquo;{round(yval,1)}°&amp;rsquo;, va=&amp;lsquo;bottom&amp;rsquo;,
ha=&amp;lsquo;center&amp;rsquo;, fontsize=8, color=&amp;lsquo;green&amp;rsquo;)
blank_value = 0
blank_bar   = ax_PH.bar(len(largest_indices_M), blank_value, color=&amp;lsquo;white&amp;rsquo;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ax_PH.set_xticks(range(len(largest_indices_M)), largest_indices_M)
ax_PH.set_ylabel(&#39;Phase [deg]&#39;,fontsize=9, labelpad=8)
y_ticks2=[-180,-120,-60,0,60,120,180]
ax_PH.set_yticks(y_ticks2)    
ax_PH.set_xlabel(&#39;Contributing Paths: InterfaceGRID-DOF&#39;,fontsize=9)
ax_PH.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=7)
ax_PH.yaxis.grid(False) 
ax_PH.xaxis.grid(True) 
ax_PH.axhline(0, color=&#39;gray&#39;, linewidth=0.5) 
# plt.show()

return fig
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#                         Add a page number to a figure&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def add_page_number(fig, page_number, pdf_pagename):
# Add text for page number
fig.text(0.5, 0.05, f&amp;rsquo;{pdf_pagename} - Page {page_number}&amp;rsquo;, fontsize=8, ha=&amp;lsquo;center&amp;rsquo;, va=&amp;lsquo;bottom&amp;rsquo;,
color=&amp;lsquo;gray&amp;rsquo;)&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>User&#39;s Manual P9</title>
      <link>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_009/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//uildDrafts:1313/docs/release_guide/msc_nastran_2024.1_release_guide_009/</guid>
      <description>
        
        
        &lt;p&gt;157  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index&lt;/p&gt;
&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;h1&gt;#                                   Plot to PDF&lt;/h1&gt;&lt;h1&gt;# =============================================================================&lt;/h1&gt;&lt;p&gt;def plot_and_pdf(df, pdfs_list,DVA=False):
first_key = list(df.keys())[0]
interfGs_List = []
string = first_key
tokens = string.split(&amp;rsquo;_&amp;rsquo;)
token0_parts = tokens[0].split(&amp;rsquo; &amp;lsquo;)
S = token0_parts[1]
token1_parts = tokens[1].split(&amp;rsquo; &amp;lsquo;)
R_G = token1_parts[1]
token2_parts = tokens[2]
token3_parts = tokens[3]
mydf_ContrM  = df[ list(df.keys())[0] ]
mydf_ContrPH = df[ list(df.keys())[1] ]
if DVA:
PDVAXYZ = token3_parts.split(&amp;rsquo;-&amp;rsquo;)
PDVA = PDVAXYZ[0]
XYZ  = PDVAXYZ[1]
mydf_TPA_M   = df[ list(df.keys())[4] ]
mydf_Tot     = df[ list(df.keys())[6] ]
else:
PDVA = token2_parts
XYZ = &amp;quot;&amp;quot;         &lt;br&gt;
mydf_TPA_M   = df[ list(df.keys())[5] ]
mydf_Tot     = df[ list(df.keys())[7] ]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    # Press Reference Levels
    pref = 2.0e-11 # mm-t-N-s
    # pref = 2.0e-5  # m-kg-N-s
    mydf_TPA_M.iloc[:, 1:] = mydf_TPA_M.iloc[:, 1:].applymap(lambda x: 20*np.log10(x/pref))
    mydf_Tot.iloc[:, 1:] = mydf_Tot.iloc[:, 1:].applymap(lambda x: 20*np.log10(x/pref))
    
columnPH_names = mydf_ContrPH.columns.tolist()[1:]
columnPH_interfGs = [name.split(&#39;-&#39;)[0] for name in columnPH_names]
interfGs_Set = sorted(list(set(columnPH_interfGs)))
interfGs_Set = [int(x) for x in interfGs_Set]
mydf_ContrM.insert(0, &#39;PercentSumCheck&#39;, mydf_ContrM.iloc[:,1:].sum(axis=1))
Fpeaks = mydf_ContrM[&#39;Fpeaks [Hz]&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;158 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
bool_mydf_Tot = mydf_Tot[ mydf_Tot[&amp;lsquo;F [Hz]&amp;rsquo;].isin(Fpeaks) ]
Mpeaks = bool_mydf_Tot[&amp;lsquo;Complex Sum&amp;rsquo;].tolist()
dfnew = pd.DataFrame({ &amp;lsquo;ff&amp;rsquo;: Fpeaks, &amp;lsquo;mm&amp;rsquo;: Mpeaks })
dfnew[&amp;lsquo;my_order&amp;rsquo;] = dfnew[&amp;lsquo;mm&amp;rsquo;].rank(method=&amp;lsquo;dense&amp;rsquo;, ascending=False)
dfnew_sorted_by_order = dfnew.sort_values(&amp;lsquo;my_order&amp;rsquo;)
ordered_indexes = dfnew_sorted_by_order.index.tolist()
# TPA: Comparison -&amp;gt; InPhaseSum vs. ComplexSum vs. Solver (Diff)
fig1 = plotTPA_TotRes(mydf_Tot,S,R_G,PDVA,XYZ)
# TPA: HeatMaps
figrange=(2,5)
fig2a = plotTPA_HeatMaps(mydf_TPA_M,S,R_G,PDVA,XYZ,figrange)
figrange=(5,8)
fig2b = plotTPA_HeatMaps(mydf_TPA_M,S,R_G,PDVA,XYZ,figrange)
# TPA Peaks: TotResp at Peaks &amp;amp; Contribution Bar-Charts
myfig3s = {}
for idx in ordered_indexes:
rank = dfnew[&amp;lsquo;my_order&amp;rsquo;][idx]
row_M = mydf_ContrM.iloc[idx]
row_PH = mydf_ContrPH.iloc[idx]
fig_name = f&amp;rsquo;fig3_{idx + 1}&amp;rsquo;
myfig3s[fig_name] = plotTPA_TotRes_Comp_Bars(mydf_Tot, rank, row_M, row_PH, S, R_G, PDVA, XYZ)
# Filename for the PDF
pdf_filename = f&amp;rsquo;SUB{S}-G{R_G}-{PDVA}{XYZ}.pdf&amp;rsquo;
pdf_pagename = f&amp;rsquo;SUB{S} GRID{R_G} {PDVA}{XYZ}&amp;rsquo;
with PdfPages(pdf_filename) as pdf:
# List or dict of figures to save
figures = [fig1, fig2a, fig2b] + list(myfig3s.values())
for i, fig in enumerate(figures, start=1):
add_page_number(fig, i, pdf_pagename)  # Add page number to figure
pdf.savefig(fig)                       # Save the figure to PDF
plt.close(fig)                         # Close the figure to free memory
pdfs_list.append(pdf_filename)
print(f&amp;quot;{pdf_filename} with page numbers has been created and saved.&amp;quot;)
return pdfs_list&lt;/p&gt;
&lt;p&gt;159  CHAPTER A
Python Code for Post Processing TPA HDF5 File
Main Index
2. Read the SingleStep TPA H5 File
H5filename = &amp;lsquo;ostpa_yaris&amp;rsquo;
try:
with h5py.File(H5filename+&amp;rsquo;.h5&amp;rsquo;, &amp;lsquo;r&amp;rsquo;) as hf5:
# Collect all dataset paths
all_dataset_paths = collect_dataset_paths(hf5)
for path in all_dataset_paths:
print(path)
except Exception as ex:
print(&amp;ldquo;An error occurred:&amp;rdquo;, str(ex))
all_dataset_paths=[]
i = 0
recorded_indices = {}&lt;/p&gt;
&lt;h1&gt;Loop through the list using the index&lt;/h1&gt;&lt;p&gt;while i &amp;lt; len(all_dataset_paths):
string = all_dataset_paths[i]
if &amp;lsquo;Disp&amp;rsquo; in string:
i += 22  # Jump 22 elements ahead
recorded_indices[i]=&amp;lsquo;D&amp;rsquo;
# continue
elif &amp;lsquo;Velo&amp;rsquo; in string:
i += 22
recorded_indices[i]=&amp;lsquo;V&amp;rsquo;
elif &amp;lsquo;Acce&amp;rsquo; in string:
i += 22
recorded_indices[i]=&amp;lsquo;A&amp;rsquo;
elif &amp;lsquo;Press&amp;rsquo; in string:
i += 8  # Jump 8 elements ahead
recorded_indices[i]=&amp;lsquo;P&amp;rsquo;
3. Print a PDF (for each Response Grid, for each Response Type, along each DIR)
try:
with h5py.File(H5filename+&amp;rsquo;.h5&amp;rsquo;, &amp;lsquo;r&amp;rsquo;) as hf5:
pdfs_list = []
for item in recorded_indices.items():
end  = item[0]
PDVA = item[1]
if PDVA == &amp;lsquo;A&amp;rsquo; or PDVA == &amp;lsquo;D&amp;rsquo;:
end = item[0]-1&lt;/p&gt;
&lt;p&gt;160 MSC Nastran 2024.1 Release Guide
Python Code for Post Processing TPA HDF5 File
Main Index
start = end-21
mylist = list(range(start, end+1, 7))
elif PDVA == &amp;lsquo;V&amp;rsquo;:
end = item[0]
start = end-21
mylist = list(range(start, end+1, 7))
else:
end = item[0]
start = end-8
mylist = list(range(start, end+1, 8))
for idx,i in enumerate(mylist[:-1]):
pdfs_list = process_datasets(idx,i,mylist, all_dataset_paths, hf5, pdfs_list)&lt;/p&gt;
&lt;p&gt;except Exception as ex:
print(&amp;ldquo;An error occurred:&amp;rdquo;, str(ex))
pdfs_list=[]
4. Merge all PDFs and Bookmark them into a Single PDF&lt;/p&gt;
&lt;h1&gt;Create a PdfMerger object&lt;/h1&gt;&lt;p&gt;merger = PyPDF2.PdfMerger()
current_page_count = 0
if pdfs_list:
# Loop through PDFs
for pdf in pdfs_list:
with open(pdf, &amp;lsquo;rb&amp;rsquo;) as f:
pdf_reader = PyPDF2.PdfReader(f)
num_pages = len(pdf_reader.pages)
merger.append(f)
bookmark_title = pdf[:-4]
merger.add_outline_item(bookmark_title, current_page_count)
current_page_count += num_pages
# Combined PDFs
with open(f&amp;rsquo;{H5filename}-AllCombined.pdf&amp;rsquo;, &amp;lsquo;wb&amp;rsquo;) as output_pdf:
merger.write(output_pdf)
merger.close()
print(&amp;ldquo;Combined all PDFs (with Bookmarks).&amp;rdquo;)
else:
print(&amp;ldquo;PDFs not found.&amp;rdquo;)&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
